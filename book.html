<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      
   <title>HBase 官方文档 0.97</title><link rel="stylesheet" href="css/freebsd_docbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><meta name="description" content="这是 Apache HBase的官方文档, HBase是一个分布式,版本化，构建在 Apache Hadoop和 Apache ZooKeeper上的列数据库."><script>window["_GOOG_TRANS_EXT_VER"] = "1";</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="HBase 官方文档">
   <h1><a href="http://www.hbase.org/" target="_top"> Apache HBase™ 参考指南</a></h1>
   <div class="titlepage"><div><div>
     <h1 class="title"><a href="http://www.hbase.org/"><img src="images/hbase_logo.png" width="266" height="66" alt="HBase" longdesc="http://www.hbase.org"></a><a name="d613e2"></a>  <a class="link" href="http://www.hbase.org/" target="_top">HBase</a>
    官方文档中文版</h1></div><div>
      <p class="copyright">Copyright © 2012 Apache Software Foundation。保留所有权利。 Apache Hadoop, Hadoop, MapReduce, HDFS, Zookeeper, HBase 及 HBase项目 logo 是Apache Software Foundation的商标。</p>
</div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tbody><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.97.0-SNAPSHOT</td><td align="left">2013-04-07T14:59</td></tr><tr><td align="left" colspan="2"><span class="copyright">中文版翻译整理 <a href="http://abloz.com">周海汉</a></span></td></tr></tbody></table></div></div><div><div class="abstract" title="Abstract">
          <p>          
          <hr size="1">
          <p class="QUESTION"><strong>译者</strong>：HBase新版 0.97 文档和0.90版相比，变化较大，文档补充更新了很多内容，章节调整较大。本翻译文档的部分工作基于<a href="http://www.yankay.com" target="_blank">颜开</a>工作。英文原文地址在<a href="http://hbase.apache.org/book.html" target="_blank">此处</a>。旧版0.90版由颜开翻译文档在<a href="http://www.yankay.com/wp-content/hbase/book.html" target="_blank">此处</a>。0.97版翻译最后更新请到<a href="http://abloz.com/hbase/book.html" target="_blank">此处</a>(  <a href="http://abloz.com/hbase/book.html" target="_blank">http://abloz.com/hbase/book.html</a> )浏览。反馈和参与请到<a href="https://code.google.com/p/hbasedoc-cn/" target="_blank">此处 (https://code.google.com/p/hbasedoc-cn/)</a>或访问我的<a href="http://abloz.com" target="_blank">blog(http://abloz.com)</a>，或给我发email。</p>
          <p class="QUESTION"> 最终版生成<a href="https://hbasedoc-cn.googlecode.com/files/HBase 官方文档.pdf">pdf</a>供下载。
            </p>
          </p>
         <p />
          贡献者：
<p class="QUESTION">周海汉邮箱：ablozhou@gmail.com, QQ:7268188 网址：<a href="http://abloz.com/" target="_blank">http://abloz.com/</a> <br>
          颜开邮箱: yankaycom@gmail.com, 网址：<a href="http://www.yankay.com/" target="_blank">http://www.yankay.com/</a></p>
<hr size="1">
        <p class="title"><b>摘要</b></p>
<p>这是
  <a class="link" href="http://www.hbase.org/" target="_top">Apache HBas</a><a href="http://www.hbase.org/" target="_top">e (TM)</a>的官方文档。
  HBase是一个分布式，版本化，面向列的数据库，构建在
  <a class="link" href="http://hadoop.apache.org/" target="_top">Apache Hadoop</a>和
  <a class="link" href="http://zookeeper.apache.org/" target="_top">Apache ZooKeeper</a>之上。
</p>
            <p>&nbsp;</p>
</div>
        </div></div><hr></div><div class="toc">
          <p><b>目录</b></p><dl>
          <div>
            <dl>
              <dt><span class="preface"><a href="#preface">序</a></span></dt>
              <dt><span class="chapter"><a href="#getting_started">1. 入门</a></span></dt>
              <dd>
                <dl>
                  <dt><span class="section"><a href="#d613e75">1.1. 介绍</a></span></dt>
                  <dt><span class="section"><a href="#quickstart">1.2. 快速开始</a></span></dt></dl></dd>
              <dt><a href="#configuration">2. Apache HBase (TM)</a><a href="#configuration">配置</a></dt>
              <dd>
                <dl>
                  <dt><a href="#basic.prerequisites">2.1. 基础条件</a></dt>
                  <dt><a href="#standalone_dist">2.2. HBase 运行模式: 独立和分布式</a></dt>
                  <dt><a href="#config.files">2.3. </a><a href="#config.files">配置文件</a></dt>
                  <dt><a href="#example_config">2.4. 配置示例</a><a href="#example_config"></a></dt>
                  <dt><a href="#important_configurations">2.5. </a><a href="#important_configurations">重要配置</a></dt>
                  <dt>&nbsp;</dt></dl></dd>
              <dt><a href="#upgrading">3. 升级</a></dt>
              <dd>
                <dl>
                  <dt><a href="#upgrade0.96">3.1. 从 0.94.x 升级到 0.96.x</a></dt>
                  <dt><a href="#upgrade0.94">3.2. 从 0.92.x 升级到 0.94.x</a></dt>
                  <dt><a href="#upgrade0.92">3.3. 从 0.90.x 升级到 0.92.x</a></dt>
                  <dt><a href="#upgrade0.90">3.4. 从0.20x或0.89x升级到0.90.x </a></dt>
                  <dt>&nbsp;</dt></dl></dd>
              <dt><a href="#shell">4. HBase Shell</a></dt>
              <dd>
                <dl>
                  <dt><a href="#scripting">4.1. </a><a href="#scripting">使用脚本</a></dt>
                  <dt><a href="#shell_tricks">4.2. </a><a href="#shell_tricks">Shell 技巧</a></dt></dl></dd>
              <dt><a href="#datamodel">5. </a><a href="#datamodel">数据模型</a></dt>
              <dd>
                <dl>
                  <dt><a href="#conceptual.view">5.1. </a><a href="#conceptual.view">概念视图</a></dt>
                  <dt><a href="#physical.view">5.2. </a><a href="#physical.view">物理视图</a></dt>
                  <dt><a href="#table">5.3. </a><a href="#table">表</a></dt>
                  <dt><a href="#row">5.4. </a><a href="#row">行</a></dt>
                  <dt><a href="#columnfamily">5.5. 列族</a></dt>
                  <dt><a href="#cells">5.6. Cells</a></dt>
                  <dt><a href="#data_model_operations">5.7. Data Model Operations</a></dt>
                  <dt><a href="#versions">5.8. 版本</a></dt>
                  <dt><a href="#dm.sort">5.9. 排序</a></dt>
                  <dt><a href="#dm.column.metadata">5.10. 列元数据</a></dt>
                  <dt><a href="#joins">5.11. Joins</a></dt>
                  <dd><a href="#joins"></a><a href="#joins"></a><a href="#acid">5.12. ACID</a></dd>
                </dl>
              </dd>
              <dt><a href="#schema">6. HBase 和 Schema 设计</a></dt>
              <dd>
                <dl>
                  <dt><a href="#schema.creation">6.1. Schema </a><a href="#schema.creation">创建</a></dt>
                  <dt><a href="#number.of.cfs">6.2. </a><a href="#number.of.cfs">column families的数量</a></dt>
                  <dt><a href="#rowkey.design">6.3. Rowkey 设计</a></dt>
                  <dt><a href="#schema.versions">6.4. 版本数量</a></dt>
                  <dt><a href="#supported.datatypes">6.5. 支持的数据类型</a></dt>
                  <dt><a href="#schema.joins">6.6. Joins</a></dt>
                  <dt><a href="#ttl">6.7. 生存时间 (TTL)</a></dt>
                  <dt><a href="#cf.keep.deleted">6.8. 保留删除的单元</a></dt>
                  <dt><a href="#secondary.indexes">6.9. 第二索引和替代查询路径</a></dt>
                  <dt><a href="#constraints">6.10. 限制</a></dt>
                  <dd><a href="#constraints"></a><a href="#schema.smackdown">6.11. 模式设计用例</a></dd>
                  <dt><a href="#schema.ops">6.12. 操作和性能配置选项</a></dt>
                  <dt>&nbsp;</dt>
                </dl>
              </dd>
              <dt><a href="#mapreduce">7. HBase 和 MapReduce</a></dt>
              <dd>
                <dl>
                  <dt><a href="#splitter">7.1. Map-Task 分割</a></dt>
                  <dt><a href="#mapreduce.example">7.2. HBase MapReduce 示例</a></dt>
                  <dt><a href="#mapreduce.htable.access">7.3. 在MapReduce工作中访问其他 HBase 表  </a></dt>
                  <dt><a href="#mapreduce.specex">7.4. 推测执行</a></dt></dl></dd>
              <dt><a href="#security">8. HBase安全</a></dt>
              <dd>
                <dl>
                  <dt><a href="#hbase.secure.configuration">8.1. 安全客户端访问 HBase</a></dt>
                  <dt><a href="#hbase.accesscontrol.configuration">8.2. 访问控制</a></dt>
                  <dd><a href="#hbase.secure.bulkload">8.3. 安全批量加载</a></dd>
                </dl>
              </dd>
              <dt><a href="#architecture">9. 架构</a></dt>
              <dd>
                <dl>
                  <dt><a href="#arch.overview">9.1. 概述</a></dt>
                  <dt><a href="#arch.catalog">9.2. 目录表</a></dt>
                  <dt><a href="#client">9.3. 客户端</a></dt>
                  <dt><a href="#client.filter">9.4. 客户请求过滤器</a></dt>
                  <dt><a href="#master">9.5. Master</a></dt>
                  <dt><a href="#regionserver.arch">9.6. RegionServer</a></dt>
                  <dt><a href="#regions.arch">9.7. 分区(Regions</a>)</dt>
                  <dt><a href="#arch.bulk.load">9.8. 批量加载</a></dt>
                  <dt><a href="#arch.hdfs">9.9. HDFS</a></dt>
                </dl>
              </dd>
              <dt><a href="#external_apis">10. 外部 APIs</a></dt>
              <dd>
                <dl>
                  <dt><a href="#nonjava.jvm">10.1. 非Java语言和 JVM交互</a></dt>
                  <dt><a href="#rest">10.2. REST</a></dt>
                  <dt><a href="#thrift">10.3. Thrift</a></dt>
                  <dt><a href="#c">10.4. C/C++ Apache HBase Client</a></dt>
                </dl>
              </dd>
              <dt><a href="#performance">11. 性能调优</a></dt>
              <dd>
                <dl>
                  <dt><a href="#perf.os">11.1. 操作系统</a></dt>
                  <dt><a href="#perf.network">11.2. 网络</a></dt>
                  <dt><a href="#jvm">11.3. Java</a></dt>
                  <dt><a href="#perf.configurations">11.4. HBase 配置</a></dt>
                  <dt><a href="#perf.zookeeper">11.5. ZooKeeper</a></dt>
                  <dt><a href="#perf.schema">11.6. Schema 设计</a></dt>
                  <dd><a href="#perf.general">11.7. HBase General Patterns</a></dd>
                  <dt><a href="#perf.writing">11.8. 写到 HBase</a></dt>
                  <dt><a href="#perf.reading">11.9. 从 HBase读取</a></dt>
                  <dt><a href="#perf.deleting">11.10. 从 HBase删除</a></dt>
                  <dt><a href="#perf.hdfs">11.11. HDFS</a></dt>
                  <dt><a href="#perf.ec2">11.12. Amazon EC2</a></dt>
                  <dt><a href="#perf.casestudy">11.13. 案例</a></dt>
                </dl>
              </dd>
              <dt><a href="#trouble">12. 故障排除和调试 HBase</a></dt>
              <dd>
                <dl>
                  <dt><a href="#trouble.general">12.1. 通用指引</a></dt>
                  <dt><a href="#trouble.log">12.2. Logs</a></dt>
                  <dt><a href="#trouble.resources">12.3. 资源</a></dt>
                  <dt><a href="#trouble.tools">12.4. 工具</a></dt>
                  <dt><a href="#trouble.client">12.5. 客户端</a></dt>
                  <dt><a href="#trouble.mapreduce">12.6. MapReduce</a></dt>
                  <dt><a href="#trouble.namenode">12.7. NameNode</a></dt>
                  <dt><a href="#trouble.network">12.8. 网络</a></dt>
                  <dt><a href="#trouble.rs">12.9. RegionServer</a></dt>
                  <dt><a href="#trouble.master">12.10. Master</a></dt>
                  <dt><a href="#trouble.zookeeper">12.11. ZooKeeper</a></dt>
                  <dt><a href="#trouble.ec2">12.12. Amazon EC2</a></dt>
                  <dt><a href="#trouble.versions">12.13. HBase 和 Hadoop 版本相关</a></dt>
                  <dt><a href="#trouble.casestudy">12.14. 案例</a></dt>
                </dl>
              </dd>
              <dt><a href="#casestudies">13. 案例研究</a></dt>
              <dd>
                <dl>
                  <dt><a href="#casestudies.overview">13.1. 概要</a></dt>
                  <dt><a href="#casestudies.schema">13.2. Schema 设计</a></dt>
                  <dt><a href="#casestudies.perftroub">13.3. 性能/故障排除</a></dt>
                </dl>
              </dd>
              <dt><a href="#ops_mgt">14. HBase 运维管理</a></dt>
              <dd>
                <dl>
                  <dt><a href="#tools">14.1. HBase 工具和实用程序</a></dt>
                  <dt><a href="#ops.regionmgt">14.2. 分区管理</a></dt>
                  <dt><a href="#node.management">14.3. 节点管理</a></dt>
                  <dt><a href="#hbase_metrics">14.4. HBase 度量(Metrics)</a></dt>
                  <dt><a href="#ops.monitoring">14.5. HBase 监控</a></dt>
                  <dt><a href="#cluster_replication">14.6. Cluster 复制</a></dt>
                  <dt><a href="#ops.backup">14.7. HBase 备份</a></dt>
                  <dt><a href="#ops.capacity">14.8. 容量规划</a></dt>
                </dl>
              </dd>
              <dt><a href="#developer">15. 创建和开发 HBase</a></dt>
              <dd>
                <dl>
                  <dt><a href="#repos">15.1. HBase 仓库</a></dt>
                  <dt><a href="#ides">15.2. IDEs</a></dt>
                  <dt><a href="#build">15.3. 创建 HBase</a></dt>
                  <dt><a href="#mvn_repo">15.4. 添加 Apache HBase 发行版到Apache的 Maven Repository</a></dt>
                  <dd><a href="#documentation">15.5. 生成HBase 参考指南</a></dd>
                  <dt><a href="#hbase.org">15.6. 更新 hbase.apache.org</a></dt>
                  <dt><a href="#hbase.tests">15.7. 测试</a></dt>
                  <dt><a href="#maven.build.commands">15.8. Maven 创建命令</a></dt>
                  <dt><a href="#getting.involved">15.9. 加入</a></dt>
                  <dt><a href="#developing">15.10. 开发</a></dt>
                  <dt><a href="#submitting.patches">15.11. 提交补丁</a></dt>
                </dl>
              </dd>
              <dt><a href="#zookeeper">16. ZooKeeper</a></dt>
              <dd>
                <dl>
                  <dt><a href="#d352e10721">16.1. <span class="title">和已有的ZooKeeper一起使用</span></a></dt>
                  <dt><a href="#zk.sasl.auth">16.2. <span class="title">通过ZooKeeper 的SASL 认证</span></a></dt>
                </dl>
              </dd>
              <dt><a href="#community">17. 社区</a></dt>
              <dd>
                <dl>
                  <dt><a href="#decisions">17.1. 决策</a></dt>
                  <dt><a href="#community.roles">17.2. 社区角色</a></dt>
                </dl>
              </dd>
              <dt><a href="#faq">A. FAQ</a></dt>
              <dd><a href="#faq"></a><a href="#hbck.in.depth">B. 深入hbck </a></dd>
              <dd>
                <dl>
                  <dt><a href="#d1934e10593">B.1. 运行 hbck 以查找不一致</a></dt>
                  <dt><a href="#apbs02">B.2. 不一致(Inconsistencies)</a></dt>
                  <dt><a href="#apbs03">B.3. 局部修补</a></dt>
                  <dt><a href="#apbs04">B.4. 分区重叠修补</a></dt>
                </dl>
              </dd>
              <dt><a href="#compression">C.  HBase中的压缩</a></dt>
              <dd>
                <dl>
                  <dt><a href="#compression.test">C.1. CompressionTest 工具</a></dt>
                  <dt><a href="#hbase.regionserver.codecs">C.2. hbase.regionserver.codecs</a></dt>
                  <dt><a href="#lzo.compression">C.3. LZO</a></dt>
                  <dt><a href="#gzip.compression">C.4. GZIP</a></dt>
                  <dt><a href="#snappy.compression">C.5. SNAPPY</a></dt>
                  <dt><a href="#changing.compression">C.6. 修改压缩 Schemes</a></dt>
                </dl>
              </dd>
              <dt><a href="#apd">D. YCSB: Yahoo! 云服务评估和 HBase</a></dt>
              <dt>&nbsp;</dt>
              <dd><a href="#hfilev2">E. HFile 格式版本 2</a></dd>
              <dd>
                <dl>
                  <dt><a href="#d1934e10848">E.1. Motivation</a></dt>
                  <dt><a href="#apes02">E.2. HFile 格式版本 1 概览</a></dt>
                  <dt><a href="#apes03">E.3. HBase 文件格式带 inline blocks (version 2)</a></dt></dl></dd>
              <dt><a href="#other.info">F.  HBase的其他信息</a></dt>
              <dd>
                <dl>
                  <dt><a href="#other.info.videos">F.1. HBase 视频</a></dt>
                  <dt><a href="#other.info.pres">F.2. HBase 展示 (Slides)</a></dt>
                  <dt><a href="#other.info.papers">F.3. HBase 论文</a></dt>
                  <dt><a href="#other.info.sites">F.4. HBase 网站</a></dt>
                  <dt><a href="#other.info.books">F.5. HBase 书籍</a></dt>
                  <dt><a href="#other.info.books.hadoop">F.6. Hadoop 书籍</a></dt>
                </dl>
              </dd>
              <dt><a href="#hbase.history">G. HBase 历史</a></dt>
              <dt>&nbsp;</dt>
              <dd><a href="#asf">H. HBase 和 Apache 软件基金会(ASF)</a></dd>
              <dd>
                <dl>
                  <dt><a href="#asf.devprocess">H.1. ASF开发进程</a></dt>
                  <dt><a href="#asf.reporting">H.2. ASF 报告板</a></dt>
                  <dt><a href="#tracing">I. Enabling Dapper-like Tracing in HBase</a></dt>
                  <dd>
                    <dl>
                      <dt><a href="#tracing.spanreceivers">I.1. SpanReceivers</a></dt>
                      <dt><a href="#tracing.client.modifications">I.2. Client Modifications</a></dt>
                    </dl>
                  </dd>
                </dl>
              </dd>
              <dt><a href="#hbase.rpc">J. 0.95 RPC Specification</a></dt>
              <dd>
                <dl>
                  <dt><a href="#d2520e13181">J.1. Goals</a></dt>
                  <dt><a href="#d2520e13194">J.2. TODO</a></dt>
                  <dt><a href="#d2520e13210">J.3. RPC</a></dt>
                  <dt><a href="#d2520e13331">J.4. Notes</a></dt>
                </dl>
              </dd>
              <dt><a href="#book_index">词汇表</a></dt>
            </dl>
          </div>
          <div>
            <p><strong>表索引</strong></p>
            <dl>
              <dt>2.1. <a href="#d2520e486">Hadoop version support matrix</a></dt>
              <dd>5.1. <a href="#d1934e3221">Table webtable</a></dd>
              <dt>5.2. <a href="#d1934e3305">ColumnFamily anchor</a></dt>
              <dt>5.3. <a href="#d1934e3344">ColumnFamily contents</a></dt>
              <dt>8.1. <a href="#d1934e4513">Operation To Permission Mapping</a></dt>
            </dl>
          </div>
<dt>&nbsp;</dt></dl></div><div class="list-of-tables"></div><div class="preface" title="序"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>序</h2></div></div></div>
    <p>这本书是 <a class="link" href="http://hbase.apache.org/" target="_top">HBase</a> 的官方指南。
  版本为  <em>0.95-SNAPSHOT</em> 。可以在HBase官网上找到它。也可以在 <a class="link" href="http://hbase.apache.org/docs/current/api/index" target="_top">javadoc</a>,
  <a class="link" href="https://issues.apache.org/jira/browse/HBASE" target="_top">JIRA</a>
和 <a class="link" href="http://wiki.apache.org/hadoop/HBase" target="_top">wiki</a> 找到更多的资料。</p><p>此书正在编辑中。 可以向 HBase 官方提供补丁<a class="link" href="https://issues.apache.org/jira/browse/HBASE" target="_top">JIRA</a>.</p><p>这个版本系译者水平限制，没有理解清楚或不需要翻译的地方保留英文原文。</p><div class="note" title="最前面的话" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="headsup"></a>最前面的话</h3><p>
	      若这是你第一次踏入分布式计算的精彩世界，你会感到这是一个有趣的年代。分布式计算是很难的，做一个分布式系统需要很多软硬件和网络的技能。你的集群可以会因为各式各样的错误发生故障。比如HBase本身的Bug,错误的配置(包括操作系统)，硬件的故障(网卡和磁盘甚至内存)
		  如果你一直在写单机程序的话，你需要重新开始学习。这里就是一个好的起点:

          <a class="link" href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing" target="_top">分布式计算的谬论</a>.
      </p></div></div><div class="chapter" title="Chapter 1. 入门"><div class="titlepage"><div><div><h2 class="title"><a name="getting_started"></a>Chapter&nbsp;1.&nbsp;入门<a name="getting_started" id="getting_started"></a></h2>
      </div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d613e75">1.1. 介绍</a></span></dt><dt><span class="section"><a href="#quickstart">1.2. 快速开始</a></span></dt><dd><dl><dt><span class="section"><a href="#d613e91">1.2.1. 下载解压最新版本</a></span></dt><dt><span class="section"><a href="#start_hbase">1.2.2. 启动 HBase</a></span></dt><dt><span class="section"><a href="#shell_exercises">1.2.3. Shell 练习</a></span></dt><dt><span class="section"><a href="#stopping">1.2.4. 停止 HBase</a></span></dt><dt><span class="section"><a href="#d613e242">1.2.5. 下一步该做什么</a></span></dt></dl></dd><dd>&nbsp;</dd></dl></div><div class="section" title="1.1. 介绍"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d613e75"></a>1.1.&nbsp;介绍</h2></div></div></div>
      <p><a class="xref" href="#quickstart" title="1.2. 快速开始">Section&nbsp;1.2, “快速开始”</a>会介绍如何运行一个单机版的HBase.他运行在本地磁盘上。
    <a class="xref" href="#notsoquick" title="2. 慢速开始(相对快速开始)">Section&nbsp;2, “配置”</a> 会介绍如何运行一个分布式的HBase。他运行在HDFS上</p></div><div class="section" title="1.2. 快速开始"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart"></a>1.2.&nbsp;快速开始</h2></div></div></div><p>本指南介绍了在单机安装HBase的方法。会引导你通过<span class="command"><strong>shell</strong></span>创建一个表，插入一行，然后删除它，最后停止HBase。只要10分钟就可以完成以下的操作。</p><div class="section" title="1.2.1. 下载解压最新版本"><div class="titlepage"><div><div><h3 class="title"><a name="d613e91"></a>1.2.1.&nbsp;下载解压最新版本</h3></div></div></div><p>选择一个 <a class="link" href="http://www.apache.org/dyn/closer.cgi/hbase/" target="_top">Apache 下载镜像</a>，下载 <span class="emphasis"><em>HBase Releases</em></span>. 点击
      <code class="filename">stable</code>目录，然后下载后缀为 
      <code class="filename">.tar.gz</code> 的文件; 例如
      <code class="filename">hbase-0.95-SNAPSHOT.tar.gz</code>.</p><p>解压缩，然后进入到那个要解压的目录.</p><pre class="programlisting">$ tar xfz hbase-0.95-SNAPSHOT.tar.gz
$ cd hbase-0.95-SNAPSHOT
</pre><p>现在你已经可以启动HBase了。但是你可能需要先编辑 <code class="filename">conf/hbase-site.xml</code> 去配置<code class="varname">hbase.rootdir</code>，来选择HBase将数据写到哪个目录
      . </p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;file:///DIRECTORY/hbase&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;

</pre><p> 将 <code class="varname">DIRECTORY</code> 替换成你期望写文件的目录. 默认
      <code class="varname">hbase.rootdir</code> 是指向
      <code class="filename">/tmp/hbase-${user.name}</code> ，也就说你会在重启后丢失数据(重启的时候操作系统会清理<code class="filename">/tmp</code>目录)</p></div><div class="section" title="1.2.2. 启动 HBase"><div class="titlepage"><div><div><h3 class="title"><a name="start_hbase"></a>1.2.2.&nbsp;启动 HBase</h3></div></div></div><p>现在启动HBase:</p><pre class="programlisting">$ ./bin/start-hbase.sh
starting Master, logging to logs/hbase-user-master-example.org.out</pre>
      <p>现在你运行的是单机模式的Hbaes。所有的服务都运行在一个JVM上，包括HBase和Zookeeper。HBase的日志放在<code class="filename">logs</code>目录,当你启动出问题的时候，可以检查这个日志。
      </p><div class="note" title="是否安装了 java ?" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">是否安装了 <span class="application">java</span> ?</h3><p>你需要确认安装了Oracle的1.6 版本的<span class="application">java</span>.如果你在命令行键入java有反应说明你安装了Java。如果没有装，你需要先安装，然后编辑<code class="filename">conf/hbase-env.sh</code>，将其中的<code class="envar">JAVA_HOME</code>指向到你Java的安装目录。</p></div></div><div class="section" title="1.2.3. Shell 练习"><div class="titlepage"><div><div><h3 class="title"><a name="shell_exercises"></a>1.2.3.&nbsp;Shell 练习</h3></div></div></div><p>用<span class="command"><strong>shell</strong></span>连接你的HBase</p><pre class="programlisting">$ ./bin/hbase shell
HBase Shell; enter 'help&lt;RETURN&gt;' for list of supported commands.
Type "exit&lt;RETURN&gt;" to leave the HBase Shell
Version: 0.90.0, r1001068, Fri Sep 24 13:55:42 PDT 2010

hbase(main):001:0&gt; </pre><p>输入 <span class="command"><strong>help</strong></span> 然后
      <span class="command"><strong>&lt;RETURN&gt;</strong></span> 可以看到一列shell命令。这里的帮助很详细，要注意的是表名，行和列需要加引号。</p><p>创建一个名为 <code class="varname">test</code> 的表，这个表只有一个 列族 为 <code class="varname">cf</code>。可以列出所有的表来检查创建情况，然后插入些值。
</p><pre class="programlisting">hbase(main):003:0&gt; create 'test', 'cf'
0 row(s) in 1.2200 seconds
hbase(main):003:0&gt; list 'table'
test
1 row(s) in 0.0550 seconds
hbase(main):004:0&gt; put 'test', 'row1', 'cf:a', 'value1'
0 row(s) in 0.0560 seconds
hbase(main):005:0&gt; put 'test', 'row2', 'cf:b', 'value2'
0 row(s) in 0.0370 seconds
hbase(main):006:0&gt; put 'test', 'row3', 'cf:c', 'value3'
0 row(s) in 0.0450 seconds</pre><p>以上我们分别插入了3行。第一个行key为<code class="varname">row1</code>, 列为 <code class="varname">cf:a</code>， 值是
      <code class="varname">value1</code>。HBase中的列是由 列族前缀和列的名字组成的，以冒号间隔。例如这一行的列名就是<code class="varname">a</code>.</p><p>检查插入情况.</p><p>Scan这个表，操作如下</p><pre class="programlisting">hbase(main):007:0&gt; scan 'test'
ROW        COLUMN+CELL
row1       column=cf:a, timestamp=1288380727188, value=value1
row2       column=cf:b, timestamp=1288380738440, value=value2
row3       column=cf:c, timestamp=1288380747365, value=value3
3 row(s) in 0.0590 seconds</pre><p>Get一行，操作如下</p><pre class="programlisting">hbase(main):008:0&gt; get 'test', 'row1'
COLUMN      CELL
cf:a        timestamp=1288380727188, value=value1
1 row(s) in 0.0400 seconds</pre><p>disable 再 drop 这张表，可以清除你刚刚的操作</p><pre class="programlisting">hbase(main):012:0&gt; disable 'test'
0 row(s) in 1.0930 seconds
hbase(main):013:0&gt; drop 'test'
0 row(s) in 0.0770 seconds </pre><p>关闭shell</p><pre class="programlisting">hbase(main):014:0&gt; exit</pre></div><div class="section" title="1.2.4. 停止 HBase"><div class="titlepage"><div><div><h3 class="title"><a name="stopping"></a>1.2.4.&nbsp;停止 HBase</h3></div></div></div><p>运行停止脚本来停止HBase.</p><pre class="programlisting">$ ./bin/stop-hbase.sh
stopping hbase...............</pre></div><div class="section" title="1.2.5. 下一步该做什么"><div class="titlepage"><div><div><h3 class="title"><a name="d613e242"></a>1.2.5.&nbsp;下一步该做什么</h3></div></div></div>
<p>以上步骤仅仅适用于实验和测试。接下来你可以看 <a class="xref" href="#notsoquick" title="2. 配置">Section&nbsp;2., “配置”</a> ，我们会介绍不同的HBase运行模式，运行分布式HBase中需要的软件 和如何配置。</p></div></div><div class="section" title="2. 慢速开始(相对快速开始)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration" id="configuration"></a>2.&nbsp;配置</h2></div></div></div><div class="section" title="2.1. 需要的软件"><div class="titlepage"><div><div><h3 class="title">&nbsp;</h3></div></div></div>
<p>本章是慢速开始配置指导。</p>
    <p>HBase有如下需要，请仔细阅读本章节以确保所有的需要都被满足。如果需求没有能满足，就有可能遇到莫名其妙的错误甚至丢失数据。</p>
    <p>HBase使用和Hadoop一样配置系统。要配置部署，编辑conf/hbase-env.sh文件中的环境变量——该配置文件主要启动脚本用于获取已启动的集群——然后增加配置到XML文件，如同覆盖HBase缺省配置，告诉HBase用什么文件系统， 全部ZooKeeper位置 [<a name="d1934e270" href="#zoo1">1</a>] 。</p>
    <p>在分布模式下运行时，在编辑HBase配置文件之后，确认将conf目录复制到集群中的每个节点。HBase不会自动同步。使用<strong>rsync</strong>.</p>
    <p> [<a name="zoo1"></a><a href="#d1934e270">1</a>] 小心编辑XML。确认关闭所有元素。采用 <strong>xmllint</strong> 或类似工具确认文档编辑后是良好格式化的。 </p>
    <div>
      <div>
        <div>
          <h2>2.1. 基础条件</h2>
        </div>
      </div>
    </div>
    <p>This section lists required services and some required system configuration.</p>
<div class="section" title="2.1. java"><div class="titlepage"><div><div>
  <h3 class="title"><a name="java"></a>2.1.1&nbsp;java</h3>
</div></div></div><p>和Hadoop一样，HBase需要Oracle版本的<a class="link" href="http://www.java.com/download/" target="_top">Java6</a>.除了那个有问题的u18版本其他的都可以用，最好用最新的。
		</p></div>
<div class="section" title="2.2. 操作系统"><div class="titlepage"><div><div>
  <h3 class="title"><a name="os"></a>2.1. 操作系统</h3></div></div></div>
        <div class="section" title="2.1.3. ssh"><div class="titlepage"><div><div>
          <h4 class="title"><a name="ssh"></a>2.1.2.1.&nbsp;ssh</h4></div></div></div><p>必须安装<span class="command"><strong>ssh</strong></span> ，
        <span class="command"><strong>sshd</strong></span> 也必须运行，这样Hadoop的脚本才可以远程操控其他的Hadoop和HBase进程。ssh之间必须都打通，不用密码都可以登录，详细方法可以Google一下 ("ssh passwordless login").</p></div><div class="section" title="2.1.4. DNS"><div class="titlepage"><div><div>
          <h4 class="title"><a name="dns"></a>2.1.2.2.&nbsp;DNS</h4></div></div></div><p>HBase使用本地 hostname 才获得IP地址.
       正反向的DNS都是可以的.</p><p>如果你的机器有多个接口，HBase会使用hostname指向的主接口.</p><p>如果还不够，你可以设置
        <code class="varname">hbase.regionserver.dns.interface</code> 来指定主接口。当然你的整个集群的配置文件都必须一致，每个主机都使用相同的网络接口 </p><p>还有一种方法是设置
        <code class="varname">hbase.regionserver.dns.nameserver</code>来指定nameserver，不使用系统带的.</p></div>
        <div class="section" title="2.2.3.&nbsp;Loopback IP"><div class="titlepage"><div><div>
          <h3 class="title"><a name="loopback.ip"></a>2.1.2.3.&nbsp;Loopback IP</h3></div></div></div><p>HBase expects the loopback IP address to be 127.0.0.1.  Ubuntu and some other distributions,
        for example, will default to 127.0.1.1 and this will cause problems for you.
        </p><p><code class="filename">/etc/hosts</code> should look something like this:
</p><pre class="programlisting">            127.0.0.1 localhost
            127.0.0.1 ubuntu.ubuntu-domain ubuntu
</pre><p>
        </p></div>
        <div class="section" title="2.1.5. NTP"><div class="titlepage"><div><div>
          <h4 class="title"><a name="ntp"></a>2.1.2.4.&nbsp;NTP</h4></div></div></div><p>集群的时钟要保证基本的一致。稍有不一致是可以容忍的，但是很大的不一致会造成奇怪的行为。 运行
        <a class="link" href="http://en.wikipedia.org/wiki/Network_Time_Protocol" target="_top">NTP</a>
        或者其他什么东西来同步你的时间.</p><p>如果你查询的时候或者是遇到奇怪的故障，可以检查一下系统时间是否正确!</p></div><div class="section" title="2.1.6.  ulimit 和 nproc"><div class="titlepage"><div><div>
          <h4 class="title"><a name="ulimit"></a>2.1.2.5.&nbsp;
          <code class="varname">ulimit</code><a class="indexterm" name="d613e365"></a>
            和
          <code class="varname">nproc</code><a class="indexterm" name="d613e371"></a>
        </h4></div></div></div><p>HBase是数据库，会在同一时间使用很多的文件句柄。大多数linux系统使用的默认值1024是不能满足的，会导致<a class="link" href="http://wiki.apache.org/hadoop/HBase/FAQ#A6" target="_top">FAQ: Why do I
        see "java.io.IOException...(Too many open files)" in my logs?</a>异常。还可能会发生这样的异常
         </p><pre class="programlisting">      2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException
      2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901
      </pre>
         <p> 所以你需要修改你的最大文件句柄限制。可以设置到10k。大致的数学运算如下：每列族至少有1个存储文件(StoreFile) 可能达到5-6个如果区域有压力。将每列族的存储文件平均数目和每区域服务器的平均区域数目相乘。例如：假设一个模式有3个列族，每个列族有3个存储文件，每个区域服务器有100个区域，JVM 将打开3 * 3 * 100 = 900 个文件描述符(不包含打开的jar文件，配置文件等)</p>
      <p>你还需要修改 hbase 用户的 <code class="varname">nproc</code>，在压力下，如果过低会造成 <code class="classname">OutOfMemoryError</code>异常[<a name="d352e399" href="#ftn.d352e399">3</a>] [<a name="d352e406" href="#ftn.d352e406">4</a>]。</p>
      <p>需要澄清的，这两个设置是针对操作系统的，不是HBase本身的。有一个常见的错误是HBase运行的用户，和设置最大值的用户不是一个用户。在HBase启动的时候，第一行日志会现在ulimit信息，确保其正确。[<a name="d352e418" href="#ftn.d352e418">5</a>]</p>
      <div class="section" title="2.1.6.1. 在Ubuntu上设置ulimit"><div class="titlepage"><div><div>
          <h5 class="title"><a name="ulimit_ubuntu"></a>2.1.2.5.1.&nbsp;在Ubuntu上设置<code class="varname">ulimit</code></h5></div></div></div><p>如果你使用的是Ubuntu,你可以这样设置:</p><p>在文件 <code class="filename">/etc/security/limits.conf</code> 添加一行，如: </p><pre class="programlisting">hadoop  -       nofile  32768</pre><p>
          可以把 <code class="varname">hadoop</code> 替换成你运行HBase和Hadoop的用户。如果你用两个用户，你就需要配两个。还有配nproc hard 和 soft
          limits.  如: </p><pre class="programlisting">hadoop soft/hard nproc 32000</pre><p>.</p><p>在 <code class="filename">/etc/pam.d/common-session</code> 加上这一行: </p><pre class="programlisting">session required  pam_limits.so</pre><p>
          否则在 <code class="filename">/etc/security/limits.conf</code>上的配置不会生效.</p><p>还有注销再登录，这些配置才能生效!</p></div></div><div class="section" title="2.1.7. dfs.datanode.max.xcievers"><div class="titlepage"><div><div></div></div></div></div><div class="section" title="2.1.8. Windows"><div class="titlepage"><div><div>
            <h4 class="title"><a name="windows"></a>2.1.2.6.&nbsp;Windows</h4>
          </div></div></div><p>HBase没有怎么在Windows下测试过。所以不推荐在Windows下运行.</p>
            <p>如果你实在是想运行，需要安装<a class="link" href="http://cygwin.com/" target="_top">Cygwin</a> 并虚拟一个unix环境.详情请看 <a class="link" href="http://hbase.apache.org/cygwin.html" target="_top">Windows
        安装指导</a> . 或者 
        <a class="link" href="http://search-hadoop.com/?q=hbase+windows&fc_project=HBase&fc_type=mail+_hash_+dev" target="_top">搜索邮件列表</a>找找最近的关于windows的注意点</p>
            <div class="section" title="2.1.2. hadoop">
              <div class="titlepage">
                <div>
                  <div>
                    <h3 class="title"><a name="hadoop"></a>2.1.3.&nbsp;<a class="link" href="http://hadoop.apache.org/" target="_top">hadoop</a><a class="indexterm" name="d613e269"></a></h3>
                  </div>
                </div>
              </div>
              <p>选择 Hadoop 版本对HBase部署很关键。下表显示不同HBase支持的Hadoop版本信息。基于HBase版本，应该选择合适的Hadoop版本。我们没有绑定 Hadoop 发行版选择。可以从Apache使用 Hadoop 发行版，或了解一下Hadoop发行商产品： <a href="http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support" target="_top">http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support</a></p>
              <div><a name="d2520e486"></a>
                <p><strong>Table 2.1. Hadoop version support matrix</strong></p>
                <div>
                  <table summary="Hadoop version support matrix" border="1">
                    <colgroup>
                      <col align="left">
                      <col align="center">
                      <col align="center">
                      <col align="center">
                    </colgroup>
                    <thead>
                      <tr>
                        <th align="left"></th>
                        <th align="center">HBase-0.92.x</th>
                        <th align="center">HBase-0.94.x</th>
                        <th align="center">HBase-0.96</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td align="left">Hadoop-0.20.205</td>
                        <td align="center">S</td>
                        <td align="center">X</td>
                        <td align="center">X</td>
                      </tr>
                      <tr>
                        <td align="left">Hadoop-0.22.x</td>
                        <td align="center">S</td>
                        <td align="center">X</td>
                        <td align="center">X</td>
                      </tr>
                      <tr>
                        <td align="left">Hadoop-1.0.x</td>
                        <td align="center">S</td>
                        <td align="center">S</td>
                        <td align="center">S</td>
                      </tr>
                      <tr>
                        <td align="left">Hadoop-1.1.x</td>
                        <td align="center">NT</td>
                        <td align="center">S</td>
                        <td align="center">S</td>
                      </tr>
                      <tr>
                        <td align="left">Hadoop-0.23.x</td>
                        <td align="center">X</td>
                        <td align="center">S</td>
                        <td align="center">NT</td>
                      </tr>
                      <tr>
                        <td align="left">Hadoop-2.x</td>
                        <td align="center">X</td>
                        <td align="center">S</td>
                        <td align="center">S</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p><br>
              </p>
              <table border="0" summary="Simple list">
                <tbody>
                  <tr>
                    <td>S = supported and tested,支持</td>
                  </tr>
                  <tr>
                    <td>X = not supported,不支持</td>
                  </tr>
                  <tr>
                    <td>NT =  not tested enough.可以运行但测试不充分</td>
                  </tr>
                </tbody>
              </table>
              <p>由于 HBase 依赖 Hadoop，它配套发布了一个Hadoop jar 文件在它的 lib 下。该套装jar仅用于独立模式。在分布式模式下，Hadoop版本必须和HBase下的版本一致。用你运行的分布式Hadoop版本jar文件替换HBase lib目录下的Hadoop jar文件，以避免版本不匹配问题。确认替换了集群中所有HBase下的jar文件。Hadoop版本不匹配问题有不同表现，但看起来都像挂掉了。</p>
              <div title="2.1.3.1. Apache HBase 0.92 and 0.94">
                <div>
                  <div>
                    <div>
                      <h4><a name="hadoop.hbase-0.94"></a>2.1.3.1. Apache HBase 0.92 and 0.94</h4>
                    </div>
                  </div>
                </div>
                <p>HBase 0.92 and 0.94 versions can work with Hadoop versions, 0.20.205, 0.22.x, 1.0.x, and 1.1.x. HBase-0.94 can additionally work with Hadoop-0.23.x and 2.x, but you may have to recompile the code using the specific maven profile (see top level pom.xml)</p>
              </div>
              <div title="2.1.3.2. Apache HBase 0.96">
                <div>
                  <div>
                    <div>
                      <h4><a name="hadoop.hbase-0.96"></a>2.1.3.2. Apache HBase 0.96</h4>
                    </div>
                  </div>
                </div>
                <p>Apache HBase 0.96.0 requires Apache Hadoop 1.x at a minimum, and it can run equally well on hadoop-2.0. As of Apache HBase 0.96.x, Apache Hadoop 1.0.x at least is required. We will no longer run properly on older Hadoops such as 0.20.205 or branch-0.20-append. Do not move to Apache HBase 0.96.x if you cannot upgrade your Hadoop[<a name="d2520e586" href="#ftn.d2520e586">6</a>].</p>
              </div>
              <div title="2.1.3.3. Hadoop versions 0.20.x - 1.x">
                <div>
                  <div>
                    <div>
                      <h4><a name="hadoop.older.versions"></a>2.1.3.3. Hadoop versions 0.20.x - 1.x</h4>
                    </div>
                  </div>
                </div>
                <p>HBase will lose data unless it is running on an HDFS that has a durable sync implementation. DO NOT use Hadoop 0.20.2, Hadoop 0.20.203.0, and Hadoop 0.20.204.0 which DO NOT have this attribute. Currently only Hadoop versions 0.20.205.x or any release in excess of this version -- this includes hadoop-1.0.0 -- have a working, durable sync[<a name="d2520e600" href="#ftn.d2520e600">7</a>]. Sync has to be explicitly enabled by setting dfs.support.append equal to true on both the client side -- in hbase-site.xml -- and on the serverside in hdfs-site.xml (The sync facility HBase needs is a subset of the append code path).</p>
                <pre>  &lt;property&gt;      &lt;name&gt;dfs.support.append&lt;/name&gt;      &lt;value&gt;true&lt;/value&gt;    &lt;/property&gt;          </pre>
                <p>You will have to restart your cluster after making this edit. Ignore the chicken-little comment you'll find in the hdfs-default.xml in the description for thedfs.support.append configuration.</p>
              </div>
              <div class="section" title="2.3.1. Hadoop 安全性" >
                <h4 class="title">2.1.3.4. Hadoop 安全性</h4>
                <p>HBase运行在Hadoop 0.20.x上，就可以使用其中的安全特性 -- 只要你用这两个版本0.20S 和CDH3B3，然后把hadoop.jar替换掉就可以了.</p>
            </div>
            </div>
          </div></div>
          <div class="section" title="2.3.2.&nbsp;dfs.datanode.max.xcievers"><div class="titlepage"><div><div>
            <h4 class="title"><a name="dfs.datanode.max.xcievers"></a>2.1.3.5.&nbsp;<code class="varname">dfs.datanode.max.xcievers</code><a class="indexterm" name="d613e451"></a></h4></div></div></div><p>一个 Hadoop HDFS Datanode 有一个同时处理文件的上限. 这个参数叫 <code class="varname">xcievers</code> (Hadoop的作者把这个单词拼错了). 在你加载之前，先确认下你有没有配置这个文件<code class="filename">conf/hdfs-site.xml</code>里面的<code class="varname">xceivers</code>参数，至少要有4096:
        </p><pre class="programlisting">      &lt;property&gt;
        &lt;name&gt;dfs.datanode.max.xcievers&lt;/name&gt;
        &lt;value&gt;4096&lt;/value&gt;
      &lt;/property&gt;
      </pre><p>对于HDFS修改配置要记得重启.</p><p>如果没有这一项配置，你可能会遇到奇怪的失败。你会在Datanode的日志中看到xcievers exceeded，但是运行起来会报 missing blocks错误。例如:
        <code class="code">10/12/08 20:10:31 INFO hdfs.DFSClient: Could not obtain block
        blk_XXXXXXXXXXXXXXXXXXXXXX_YYYYYYYY from any node:
        java.io.IOException: No live nodes contain current block. Will get new
        block locations from namenode and retry...</code>
        <sup>[<a name="d613e474" href="#ftn.d613e474" class="footnote">5</a>]</sup></p>
      <p>See also <a href="#casestudies.xceivers" title="13.3.4. Case Study #4 (xcievers Config)">Section 13.3.4, &ldquo;Case Study #4 (xcievers Config)&rdquo;</a></p>
        </div>
          <div class="section" title="2.2. HBase运行模式:单机和分布式"><div class="titlepage"><div><div>
            <h3 class="title"><a name="standalone_dist"></a>2.2.&nbsp;HBase运行模式:单机和分布式</h3></div></div></div>
          <p>HBase有两个运行模式: <a class="xref" href="#standalone" title="2.2.1. 单机模式">Section&nbsp;2.4.1, “单机模式”</a> 和 <a class="xref" href="#distributed" title="2.2.2. 分布式模式">Section&nbsp;2.4.2, “分布式模式”</a>. 默认是单机模式，如果要分布式模式你需要编辑 <code class="filename">conf</code>
      文件夹中的配置文件.</p><p>不管是什么模式，你都需要编辑
      <code class="code">conf/hbase-env.sh</code>来告知HBase
      <span class="command"><strong>java</strong></span>的安装路径.在这个文件里你还可以设置HBase的运行环境，诸如 heapsize和其他
      <span class="application">JVM</span>有关的选项, 还有Log文件地址，等等. 设置 <code class="varname">JAVA_HOME</code>指向
      <span class="command"><strong>java</strong></span>安装的路径.</p><div class="section" title="2.2.1. 单机模式"><div class="titlepage"><div><div>
        <h4 class="title"><a name="standalone"></a>2.21.&nbsp;单机模式</h4></div></div></div>
      <p>这是默认的模式，在 <a class="xref" href="#quickstart" title="1.2. 快速开始">Section&nbsp;1.2, “快速开始”</a> 一章中介绍的就是这个模式. 在单机模式中，HBase使用本地文件系统，而不是HDFS ，所有的服务和zooKeeper都运作在一个JVM中。zookeep监听一个端口，这样客户端就可以连接HBase了。</p></div><div class="section" title="2.2.2. 分布式模式"><div class="titlepage"><div><div>
          <h4 class="title"><a name="distributed"></a>2.2.2.&nbsp;分布式模式</h4></div></div></div><p>分布式模式分两种。<span class="emphasis"><em>伪分布式模式</em></span>是把进程运行在一台机器上，但不是一个JVM.而<span class="emphasis"><em>完全分布式模式</em></span>就是把整个服务被分布在各个节点上了 <sup>[<a name="d613e543" href="#ftn.d613e543" class="footnote">6</a>]</sup>.</p><p>分布式模式需要使用 <span class="emphasis"><em>Hadoop
        Distributed File System</em></span> (HDFS).可以参见 <a class="link" href="http://hadoop.apache.org/common/docs/current/api/overview-summary.html#overview_description" target="_top">
        HDFS需求和指导</a>来获得关于安装HDFS的指导。在操作HBase之前，你要确认HDFS可以正常运作。</p><p>在我们安装之后，你需要确认你的<span class="emphasis"><em>伪分布式模式</em></span>或者
        <span class="emphasis"><em>完全分布式模式</em></span>的配置是否正确。这两个模式可以使用同一个验证脚本<a class="xref" href="#confirm" title="2.2.3. 运行和确认你的安装">Section&nbsp;2.2.3, “运行和确认你的安装”</a>。</p><div class="section" title="2.2.2.1. 伪分布式模式"><div class="titlepage"><div><div>
          <h5 class="title"><a name="pseudo"></a>2.2.2.1.&nbsp;伪分布式模式</h5></div></div></div><p>伪分布式模式是一个相对简单的分布式模式。这个模式是用来测试的。不能把这个模式用于生产环节，也不能用于测试性能。</p>
          <p>你确认HDFS安装成功之后，就可以先编辑
          <code class="filename">conf/hbase-site.xml</code>。在这个文件你可以加入自己的配置，这个配置会覆盖
          <a class="xref" href="#hbase_default_configurations" title="3.1.1. HBase 默认配置">Section&nbsp;2.6.1.1, “HBase 默认配置”</a> and <a class="xref" href="#hdfs_client_conf" title="2.2.2.2.3. HDFS客户端配置">Section&nbsp;2.2.2.2.3, “HDFS客户端配置”</a>. 运行HBase需要设置<code class="varname">hbase.rootdir</code> 属性.该属性是指HBase在HDFS中使用的目录的位置。例如，要想
          <code class="filename">/hbase</code> 目录，让namenode 监听locahost的9000端口，只有一份数据拷贝(HDFS默认是3份拷贝)。可以在
          <code class="filename">hbase-site.xml</code> 写上如下内容</p><pre class="programlisting">&lt;configuration&gt;
  ...
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;dfs.replication&lt;/name&gt;
    &lt;value&gt;1&lt;/value&gt;
    &lt;description&gt;The replication count for HLog &amp; HFile storage. Should not be greater than HDFS datanode count.
    &lt;/description&gt;
  &lt;/property&gt;
  ...
&lt;/configuration&gt;
</pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>让HBase自己创建 <code class="varname">hbase.rootdir</code>
</p></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>上面我们绑定到 <code class="varname">localhost</code>. 也就是说除了本机，其他机器连不上HBase。所以你需要设置成别的，才能使用它。</p></div>
            <p>现在可以跳到 <a class="xref" href="#confirm" title="2.2.3. 运行和确认你的安装">Section&nbsp;2.2.3, “运行和确认你的安装”</a> 来运行和确认你的伪分布式模式安装了。 <sup>[<a name="d613e606" href="#ftn.d613e606" class="footnote">7</a>]</sup></p></div><div class="section" title="2.2.2.2. 完全分布式模式"><div class="titlepage"><div><div>
              <div title="2.4.2.1. Pseudo-distributed">
                <div title="2.4.2.1.1. Pseudo-distributed Configuration Files">
                  <div>
                    <div>
                      <div>
                        <h5>2.2.2.1.1. 伪分布模式配置文件</h5>
                      </div>
                    </div>
                  </div>
                  <p>下面是伪分布模式设置的配置文件示例。</p>
                  hdfs-site.xml
                  <pre>&lt;configuration&gt;    ...    &lt;property&gt;      &lt;name&gt;dfs.name.dir&lt;/name&gt;      &lt;value&gt;/Users/local/user.name/hdfs-data-name&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;dfs.data.dir&lt;/name&gt;      &lt;value&gt;/Users/local/user.name/hdfs-data&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;dfs.replication&lt;/name&gt;      &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;    ...  &lt;/configuration&gt;  </pre>
                  hbase-site.xml
                  <pre>&lt;configuration&gt;    ...    &lt;property&gt;      &lt;name&gt;hbase.rootdir&lt;/name&gt;      &lt;value&gt;hdfs://localhost:8020/hbase&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;      &lt;value&gt;localhost&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;      &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;      &lt;value&gt;true&lt;/value&gt;    &lt;/property&gt;    ...  &lt;/configuration&gt;  </pre>
                </div>
                <div title="2.4.2.1.2. Pseudo-distributed Extras">
                  <div>
                    <div>
                      <div>
                        <h5><a name="pseudo.extras"></a>2.2.2.1.2. 伪分布模式附加</h5>
                      </div>
                    </div>
                  </div>
                  <div title="2.4.2.1.2.1. Startup">
                    <div>
                      <div>
                        <div>
                          <h6><a name="pseudo.extras.start"></a>2.2.2.1.2.1. 启动</h6>
                        </div>
                      </div>
                    </div>
                    <p>启动初始 HBase 集群...</p>
                    <pre>% bin/start-hbase.sh</pre>
                    <p>在同一服务器启动额外备份主服务器</p>
                    <pre>% bin/local-master-backup.sh start 1</pre>
                    <p>...  '1' 表示使用端口 60001 &amp; 60011, 该备份主服务器及其log文件放在logs/hbase-${USER}-1-master-${HOSTNAME}.log.</p>
                    <p>启动多个备份主服务器...</p>
                    <pre>% bin/local-master-backup.sh start 2 3</pre>
                    <p>可以启动到 9 个备份服务器 (总数10 个).</p>
                    <p>启动更多 regionservers...</p>
                    <pre>% bin/local-regionservers.sh start 1</pre>
                    <p>  '1' 表示使用端口 60201 &amp; 60301 ，log文件在 logs/hbase-${USER}-1-regionserver-${HOSTNAME}.log.</p>
                    <p>在刚运行的regionserver上增加 4 个额外 regionservers ...</p>
                    <pre>% bin/local-regionservers.sh start 2 3 4 5</pre>
                    <p>支持到 99 个额外regionservers (总100个).</p>
                  </div>
                  <div title="2.4.2.1.2.2. Stop">
                    <div>
                      <div>
                        <div>
                          <h6><a name="pseudo.options.stop"></a>2.2.2.1.2.2. 停止</h6>
                        </div>
                      </div>
                    </div>
                    <p>假设想停止备份主服务器 # 1, 运行...</p>
                    <pre>% cat /tmp/hbase-${USER}-1-master.pid |xargs kill -9</pre>
                    <p>注意 bin/local-master-backup.sh 停止 1 会尝试停止主服务器相关集群。</p>
                    <p>停止单独 regionserver, 运行...</p>
                    <pre>% bin/local-regionservers.sh stop 1  	                </pre>
                  </div>
                </div>
              </div>
              <div title="2.4.2.2. Fully-distributed">
                <div>
                  <div>
                    <div>
                      <h4><a name="fully_dist"></a>2.2.2.2. <span class="title">完全分布式模式</span></h4>
                    </div>
                  </div>
                </div>
              </div>
            </div></div></div><p>要想运行完全分布式模式，你要进行如下配置，先在
          <code class="filename">hbase-site.xml</code>, 加一个属性
          <code class="varname">hbase.cluster.distributed</code> 设置为
          <code class="varname">true</code> 然后把
          <code class="varname">hbase.rootdir</code> 设置为HDFS的NameNode的位置。
          例如，你的namenode运行在namenode.example.org，端口是9000 你期望的目录是
          <code class="filename">/hbase</code>,使用如下的配置</p><pre class="programlisting">&lt;configuration&gt;
  ...
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://namenode.example.org:9000/hbase&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;The mode the cluster will be in. Possible values are
      false: standalone and pseudo-distributed setups with managed Zookeeper
      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)
    &lt;/description&gt;
  &lt;/property&gt;
  ...
&lt;/configuration&gt;
</pre><div class="section" title="2.2.2.2.1. regionservers"><div class="titlepage"><div><div>
  <h6 class="title"><a name="regionserver"></a>2.2.2.2.1.&nbsp;<code class="filename">regionservers</code></h6></div></div></div>
<p>完全分布式模式的还需要修改<code class="filename">conf/regionservers</code>. 在
            <a class="xref" href="#regionservers" title="2.3.1.2. regionservers">Section&nbsp;2.7.1.2, “<code class="filename">regionservers</code>”</a> 列出了你希望运行的全部
            <span class="application">HRegionServer</span>，一行写一个host (就像Hadoop里面的 <code class="filename">slaves</code>
            一样). 列在这里的server会随着集群的启动而启动，集群的停止而停止.</p></div><div class="section" title="2.2.2.2.2. ZooKeeper"><div class="titlepage"><div><div>
              <h6 class="title"><a></a>2.2.2.2.2.&nbsp;ZooKeeper 和 HBase<a class="indexterm" name="d613e654"></a></h6></div></div></div><p>&nbsp;</p><div class="section" title="2.2.2.2.2.1. 使用现有的ZooKeeper例子"></div></div><div class="section" title="2.2.2.2.3. HDFS客户端配置"><div class="titlepage"><div><div>
                <h6 class="title"><a name="hdfs_client_conf"></a>2.2.2.2.3.&nbsp;HDFS客户端配置</h6></div></div></div><p>如果你希望Hadoop集群上做<span class="emphasis"><em>HDFS 客户端配置
            </em></span>，例如你的HDFS客户端的配置和服务端的不一样。按照如下的方法配置，HBase就能看到你的配置信息:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>在<code class="filename">hbase-env.sh</code>里将<code class="varname">HBASE_CLASSPATH</code>环境变量加上<code class="varname">HADOOP_CONF_DIR</code>
                。</p></li><li class="listitem"><p>在<code class="filename">${HBASE_HOME}/conf</code>下面加一个 <code class="filename">hdfs-site.xml</code> (或者
                <code class="filename">hadoop-site.xml</code>) ，最好是软连接</p></li><li class="listitem"><p>如果你的HDFS客户端的配置不多的话，你可以把这些加到 <code class="filename">hbase-site.xml</code>上面.</p></li></ul></div><p>例如HDFS的配置
            <code class="varname">dfs.replication</code>.你希望复制5份，而不是默认的3份。如果你不照上面的做的话，HBase只会复制3份。</p></div></div></div><div class="section" title="2.2.3. 运行和确认你的安装"><div class="titlepage"><div><div>
              <h4 class="title"><a name="confirm"></a>2.2.3.&nbsp;运行和确认你的安装</h4></div></div></div><p>首先确认你的HDFS是运行着的。你可以运行<code class="varname">HADOOP_HOME</code>中的 <code class="filename">bin/start-hdfs.sh</code> 来启动HDFS.你可以通过<span class="command"><strong>put</strong></span>命令来测试放一个文件，然后有<span class="command"><strong>get</strong></span>命令来读这个文件。通常情况下HBase是不会运行mapreduce的。所以比不需要检查这些。</p><p><span class="emphasis"><em>如果</em></span>你自己管理ZooKeeper集群，你需要确认它是运行着的。如果是HBase托管，ZoopKeeper会随HBase启动。</p><p>用如下命令启动HBase:</p><pre class="programlisting">bin/start-hbase.sh</pre>

         这个脚本在<code class="varname">HBASE_HOME</code>目录里面。

        <p>你现在已经启动HBase了。HBase把log记在 <code class="filename">logs</code> 子目录里面. 当HBase启动出问题的时候，可以看看Log. </p><p>HBase也有一个界面，上面会列出重要的属性。默认是在Master的60010端口上H (HBase RegionServers 会默认绑定
        60020端口，在端口60030上有一个展示信息的界面 ).如果Master运行在
        <code class="varname">master.example.org</code>，端口是默认的话，你可以用浏览器在 
        <code class="filename">http://master.example.org:60010</code>看到主界面.
        .</p><p>一旦HBase启动，参见<a class="xref" href="#shell_exercises" title="1.2.3. Shell 练习">Section&nbsp;1.2.3, “Shell 练习”</a>可以看到如何建表，插入数据，scan你的表，还有disable这个表，最后把它删掉。</p><p>可以在HBase Shell停止HBase
    </p><pre class="programlisting">$ ./bin/stop-hbase.sh
stopping hbase...............</pre><p> 停止操作需要一些时间，你的集群越大，停的时间可能会越长。如果你正在运行一个分布式的操作，要确认在HBase彻底停止之前，Hadoop不能停.</p></div></div><div class="section" title="2.3. 配置例子"><div class="titlepage"><div><div>
  <div>
    <div>
      <div></div>
    </div>
  </div>
  <div class="section" title="2.5.&nbsp;ZooKeeper"><div class="section" title="2.5.2.&nbsp;SASL Authentication with ZooKeeper"><div class="section" title="2.5.2.7.&nbsp;Future improvements"><div class="section" title="2.5.2.7.3.&nbsp;Elimination of kerberos.removeHostFromPrincipal and kerberos.removeRealmFromPrincipal"><div class="titlepage"><div></div></div></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
                    <p>&nbsp;</p></div></div></div>
  <div title="2.5.2. SASL Authentication with ZooKeeper">
    <div>
      <div>
        <div></div>
      </div>
    </div>
  </div>
  <div> </div>
<h3 class="title"><a name="config.files" id="config.files"></a>2.3.&nbsp;配置文件</h3></div></div></div><div class="section" title="2.3.1. 简单的分布式HBase安装"><div class="titlepage"><div><div>
  <div class="titlepage">
    <div>
      <div>
        <h2 class="title">&nbsp;</h2>
      </div>
    </div>
  </div>
<p> HBase的配置系统和Hadoop一样。在<code class="filename">conf/hbase-env.sh</code>配置系统的部署信息和环境变量。 -- 这个配置会被启动shell使用 -- 然后在XML文件里配置信息，覆盖默认的配置。告知HBase使用什么目录地址，ZooKeeper的位置等等信息。 <sup>[<a name="d613e1048" href="#ftn.d613e1048" class="footnote">10</a>]</sup> . </p>
  <p>当你使用分布式模式的时间，当你编辑完一个文件之后，记得要把这个文件复制到整个集群的<code class="filename">conf</code> 目录下。HBase不会帮你做这些，你得用 <span class="command"><strong>rsync</strong></span>.</p>
  <div class="section" title="3.1. hbase-site.xml 和 hbase-default.xml">
    <div class="titlepage">
      <div>
        <div>
          <h3 class="title" style="clear: both"><a name="hbase.site"></a>2.3.1.&nbsp;<code class="filename">hbase-site.xml</code> 和 <code class="filename">hbase-default.xml</code></h3>
        </div>
      </div>
    </div>
    <p>正如Hadoop放置HDFS的配置文件<code class="filename">hdfs-site.xml</code>，HBase的配置文件是 <code class="filename">conf/hbase-site.xml</code>.
      你可以在 <a class="xref" href="#hbase_default_configurations" title="3.1.1. HBase 默认配置">Section&nbsp;2.3.1.1, “HBase 默认配置”</a>找到配置的属性列表。你也可以看有代码里面的<code class="filename">hbase-default.xml</code>文件，他在<code class="filename">src/main/resources</code>目录下。 </p>
    <p> 不是所有的配置都在 <code class="filename">hbase-default.xml</code>出现.只要改了代码，配置就有可能改变，所以唯一了解这些被改过的配置的办法是读源代码本身。 </p>
    <p> 要注意的是，要重启集群才能是配置生效。 </p>
    <div class="section" title="3.1.1. HBase 默认配置">
      <div class="titlepage">
        <div>
          <div>
            <h3 class="title"><a name="hbase_default_configurations"></a>2.3.1.1.&nbsp;HBase 默认配置</h3>
          </div>
        </div>
      </div>
      <p></p>
      <div class="glossary" title="HBase 默认配置">
        <div class="titlepage">
          <div>
            <div>
              <h4 class="title"><a name="hbase.default.configuration"></a>HBase 默认配置</h4>
            </div>
          </div>
        </div>
        <p> 该文档是用hbase默认配置文件生成的，文件源是 <code class="filename">hbase-default.xml</code></p>
        <dl>
          <dt><a name="hbase.rootdir"></a><code class="varname">hbase.rootdir</code></dt>
          <dd>
            <p>这个目录是region server的共享目录，用来持久化HBase。URL需要是'完全正确'的，还要包含文件系统的scheme。例如，要表示hdfs中的'/hbase'目录，namenode 运行在namenode.example.org的9090端口。则需要设置为hdfs://namenode.example.org:9000/hbase。默认情况下HBase是写到/tmp的。不改这个配置，数据会在重启的时候丢失。 </p>
            <p>默认: <code class="varname">file:///tmp/hbase-${user.name}/hbase</code></p>
          </dd>
          <dt><a name="hbase.master.port"></a><code class="varname">hbase.master.port</code></dt>
          <dd>
            <p>HBase的Master的端口.</p>
            <p>默认: <code class="varname">60000</code></p>
          </dd>
          <dt><a name="hbase.cluster.distributed"></a><code class="varname">hbase.cluster.distributed</code></dt>
          <dd>
            <p>HBase的运行模式。false是单机模式，true是分布式模式。若为false,HBase和Zookeeper会运行在同一个JVM里面。 </p>
            <p>默认: <code class="varname">false</code></p>
          </dd>
          <dt><a name="hbase.tmp.dir"></a><code class="varname">hbase.tmp.dir</code></dt>
          <dd>
            <p>本地文件系统的临时文件夹。可以修改到一个更为持久的目录上。(/tmp会在重启时清楚) </p>
            <p>默认:${java.io.tmpdir}/hbase-${user.name}</p>
          </dd>
          <dt>hbase.local.dir</dt>
          <dd>
            <p>作为本地存储，位于本地文件系统的路径。</p>
            <p>默认: ${hbase.tmp.dir}/local/</p>
          </dd>
          <dd>
            <p><code></code></p>
          </dd>
          <dt><a name="hbase.master.info.port"></a><code class="varname">hbase.master.info.port</code></dt>
          <dd>
            <p>HBase Master web 界面端口.
              设置为-1 意味着你不想让他运行。 </p>
            <p>默认: <code class="varname">60010</code></p>
          </dd>
          <dt><a name="hbase.master.info.bindAddress"></a><code class="varname">hbase.master.info.bindAddress</code></dt>
          <dd>
            <p> HBase Master web 界面绑定的端口 </p>
            <p>默认: <code class="varname">0.0.0.0</code></p>
          </dd>
          <dt><a name="hbase.client.write.buffer"></a><code class="varname">hbase.client.write.buffer</code></dt>
          <dd>
            <p>HTable客户端的写缓冲的默认大小。这个值越大，需要消耗的内存越大。因为缓冲在客户端和服务端都有实例，所以需要消耗客户端和服务端两个地方的内存。得到的好处是，可以减少RPC的次数。可以这样估算服务器端被占用的内存： hbase.client.write.buffer * hbase.regionserver.handler.count </p>
            <p>默认: <code class="varname">2097152</code></p>
          </dd>
          <dt><a name="hbase.regionserver.port"></a><code class="varname">hbase.regionserver.port</code></dt>
          <dd>
            <p>HBase RegionServer绑定的端口 </p>
            <p>默认: <code class="varname">60020</code></p>
          </dd>
          <dt><a name="hbase.regionserver.info.port"></a><code class="varname">hbase.regionserver.info.port</code></dt>
          <dd>
            <p> HBase RegionServer web 界面绑定的端口
              设置为 -1 意味这你不想与运行 RegionServer 界面. </p>
            <p>默认: <code class="varname">60030</code></p>
          </dd>
          <dt><a name="hbase.regionserver.info.port.auto"></a><code class="varname">hbase.regionserver.info.port.auto</code></dt>
          <dd>
            <p>Master或RegionServer是否要动态搜一个可以用的端口来绑定界面。当hbase.regionserver.info.port已经被占用的时候，可以搜一个空闲的端口绑定。这个功能在测试的时候很有用。默认关闭。 </p>
            <p>默认: <code class="varname">false</code></p>
          </dd>
          <dt><a name="hbase.regionserver.info.bindAddress"></a><code class="varname">hbase.regionserver.info.bindAddress</code></dt>
          <dd>
            <p>HBase RegionServer web 界面的IP地址 </p>
            <p>默认: <code class="varname">0.0.0.0</code></p>
          </dd>
          <dt><a name="hbase.regionserver.class"></a><code class="varname">hbase.regionserver.class</code></dt>
          <dd>
            <p> RegionServer 使用的接口。客户端打开代理来连接region server的时候会使用到。 </p>
            <p>默认: <code class="varname">org.apache.hadoop.hbase.ipc.HRegionInterface</code></p>
          </dd>
          <dt><a name="hbase.client.pause"></a><code class="varname">hbase.client.pause</code></dt>
          <dd>
            <p>通常的客户端暂停时间。最多的用法是客户端在重试前的等待时间。比如失败的get操作和region查询操作等都很可能用到。</p>
            <p>默认: <code class="varname">1000</code></p>
          </dd>
          <dt><a name="hbase.client.retries.number"></a><code class="varname">hbase.client.retries.number</code></dt>
          <dd>
            <p>最大重试次数。所有需重试操作的最大值。例如从root region服务器获取root region，Get单元值，行Update操作等等。这是最大重试错误的值。  Default: 10.</p>
            <p>默认: <code class="varname">10</code></p>
          </dd>
          <dt>hbase.bulkload.retries.number</dt>
          <dd>
            <p>最大重试次数。 原子批加载尝试的迭代最大次数。 0 永不放弃。默认: 0.</p>
            <p>默认: 0</p>
            <p>&nbsp;</p>
          </dd>
          <dt><a name="hbase.client.scanner.caching"></a><code class="varname">hbase.client.scanner.caching</code></dt>
          <dd>
            <p>当调用Scanner的next方法，而值又不在缓存里的时候，从服务端一次获取的行数。越大的值意味着Scanner会快一些，但是会占用更多的内存。当缓冲被占满的时候，next方法调用会越来越慢。慢到一定程度，可能会导致超时。例如超过了hbase.regionserver.lease.period。 </p>
            <p>默认: 100</p>
          </dd>
          <dt><a name="hbase.client.keyvalue.maxsize"></a><code class="varname">hbase.client.keyvalue.maxsize</code></dt>
          <dd>
            <p>一个KeyValue实例的最大size.这个是用来设置存储文件中的单个entry的大小上界。因为一个KeyValue是不能分割的，所以可以避免因为数据过大导致region不可分割。明智的做法是把它设为可以被最大region size整除的数。如果设置为0或者更小，就会禁用这个检查。默认10MB。 </p>
            <p>默认: <code class="varname">10485760</code></p>
          </dd>
          <dt><a name="hbase.regionserver.lease.period"></a><code class="varname">hbase.regionserver.lease.period</code></dt>
          <dd>
            <p>客户端租用HRegion server 期限，即超时阀值。单位是毫秒。默认情况下，客户端必须在这个时间内发一条信息，否则视为死掉。</p>
            <p>默认: <code class="varname">60000</code></p>
          </dd>
          <dt><a name="hbase.regionserver.handler.count"></a><code class="varname">hbase.regionserver.handler.count</code></dt>
          <dd>
            <p>RegionServers受理的RPC Server实例数量。对于Master来说，这个属性是Master受理的handler数量 </p>
            <p>默认: <code class="varname">10</code></p>
          </dd>
          <dt><a name="hbase.regionserver.msginterval"></a><code class="varname">hbase.regionserver.msginterval</code></dt>
          <dd>
            <p> RegionServer 发消息给 Master 时间间隔，单位是毫秒 </p>
            <p>默认: <code class="varname">3000</code></p>
          </dd>
          <dt><a name="hbase.regionserver.optionallogflushinterval"></a><code class="varname">hbase.regionserver.optionallogflushinterval</code></dt>
          <dd>
            <p>将Hlog同步到HDFS的间隔。如果Hlog没有积累到一定的数量，到了时间，也会触发同步。默认是1秒，单位毫秒。 </p>
            <p>默认: <code class="varname">1000</code></p>
          </dd>
          <dt><a name="hbase.regionserver.regionSplitLimit"></a><code class="varname">hbase.regionserver.regionSplitLimit</code></dt>
          <dd>
            <p>region的数量到了这个值后就不会在分裂了。这不是一个region数量的硬性限制。但是起到了一定指导性的作用，到了这个值就该停止分裂了。默认是MAX_INT.就是说不阻止分裂。</p>
            <p>默认: <code class="varname">2147483647</code></p>
          </dd>
          <dt><a name="hbase.regionserver.logroll.period"></a><code class="varname">hbase.regionserver.logroll.period</code></dt>
          <dd>
            <p>提交commit log的间隔，不管有没有写足够的值。</p>
            <p>默认: <code class="varname">3600000</code></p>
          </dd>
          <dt><a name="hbase.regionserver.hlog.reader.impl"></a><code class="varname">hbase.regionserver.hlog.reader.impl</code></dt>
          <dd>
            <p> HLog file reader 的实现.</p>
            <p>默认: <code class="varname">org.apache.hadoop.hbase.regionserver.wal.SequenceFileLogReader</code></p>
          </dd>
          <dt><a name="hbase.regionserver.hlog.writer.impl"></a><code class="varname">hbase.regionserver.hlog.writer.impl</code></dt>
          <dd>
            <p> HLog file writer 的实现.</p>
            <p>默认: <code class="varname">org.apache.hadoop.hbase.regionserver.wal.SequenceFileLogWriter</code></p>
          </dd>
          <dt>&nbsp;</dt>
          <dd>&nbsp;          </dd>
          <dt><a name="hbase.regionserver.nbreservationblocks"></a><code class="varname">hbase.regionserver.nbreservationblocks</code></dt>
          <dd>
            <p>储备的内存block的数量(译者注:就像石油储备一样)。当发生out of memory 异常的时候，我们可以用这些内存在RegionServer停止之前做清理操作。 </p>
            <p>默认: <code class="varname">4</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.dns.interface"></a><code class="varname">hbase.zookeeper.dns.interface</code></dt>
          <dd>
            <p>当使用DNS的时候，Zookeeper用来上报的IP地址的网络接口名字。 </p>
            <p>默认: <code class="varname">default</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.dns.nameserver"></a><code class="varname">hbase.zookeeper.dns.nameserver</code></dt>
          <dd>
            <p>当使用DNS的时候，Zookeepr使用的DNS的域名或者IP 地址，Zookeeper用它来确定和master用来进行通讯的域名. </p>
            <p>默认: <code class="varname">default</code></p>
          </dd>
          <dt><a name="hbase.regionserver.dns.interface"></a><code class="varname">hbase.regionserver.dns.interface</code></dt>
          <dd>
            <p>当使用DNS的时候，RegionServer用来上报的IP地址的网络接口名字。 </p>
            <p>默认: <code class="varname">default</code></p>
          </dd>
          <dt><a name="hbase.regionserver.dns.nameserver"></a><code class="varname">hbase.regionserver.dns.nameserver</code></dt>
          <dd>
            <p>当使用DNS的时候，RegionServer使用的DNS的域名或者IP 地址，RegionServer用它来确定和master用来进行通讯的域名. </p>
            <p>默认: <code class="varname">default</code></p>
          </dd>
          <dt><a name="hbase.master.dns.interface"></a><code class="varname">hbase.master.dns.interface</code></dt>
          <dd>
            <p>当使用DNS的时候，Master用来上报的IP地址的网络接口名字。 </p>
            <p>默认: <code class="varname">default</code></p>
          </dd>
          <dt><a name="hbase.master.dns.nameserver"></a><code class="varname">hbase.master.dns.nameserver</code></dt>
          <dd>
            <p>当使用DNS的时候，RegionServer使用的DNS的域名或者IP 地址，Master用它来确定用来进行通讯的域名. </p>
            <p>默认: <code class="varname">default</code></p>
          </dd>
          <dt><a name="hbase.balancer.period%0A    "></a><code class="varname">hbase.balancer.period </code></dt>
          <dd>
            <p>Master执行region balancer的间隔。 </p>
            <p>默认: <code class="varname">300000</code></p>
          </dd>
          <dt><a name="hbase.regions.slop"></a><code class="varname">hbase.regions.slop</code></dt>
          <dd>
            <p>当任一区域服务器有average + (average * slop)个分区，将会执行重新均衡。默认 20% slop .</p>
            <p>默认:0.2</p>
          </dd>
          <dt><a name="hbase.master.logcleaner.ttl"></a><code class="varname">hbase.master.logcleaner.ttl</code></dt>
          <dd>
            <p>Hlog存在于.oldlogdir 文件夹的最长时间,
              超过了就会被 Master 的线程清理掉. </p>
            <p>默认: <code class="varname">600000</code></p>
          </dd>
          <dt><a name="hbase.master.logcleaner.plugins"></a><code class="varname">hbase.master.logcleaner.plugins</code></dt>
          <dd>
            <p>LogsCleaner服务会执行的一组LogCleanerDelegat。值用逗号间隔的文本表示。这些WAL/HLog cleaners会按顺序调用。可以把先调用的放在前面。你可以实现自己的LogCleanerDelegat，加到Classpath下，然后在这里写下类的全称。一般都是加在默认值的前面。 </p>
            <p>默认: <code class="varname">org.apache.hadoop.hbase.master.TimeToLiveLogCleaner</code></p>
          </dd>
          <dt><a name="hbase.regionserver.global.memstore.upperLimit"></a><code class="varname">hbase.regionserver.global.memstore.upperLimit</code></dt>
          <dd>
            <p>单个region server的全部memtores的最大值。超过这个值，一个新的update操作会被挂起，强制执行flush操作。 </p>
            <p>默认: <code class="varname">0.4</code></p>
          </dd>
          <dt><a name="hbase.regionserver.global.memstore.lowerLimit"></a><code class="varname">hbase.regionserver.global.memstore.lowerLimit</code></dt>
          <dd>
            <p>当强制执行flush操作的时候，当低于这个值的时候，flush会停止。默认是堆大小的 35% .
              如果这个值和 hbase.regionserver.global.memstore.upperLimit 相同就意味着当update操作因为内存限制被挂起时，会尽量少的执行flush(译者注:一旦执行flush，值就会比下限要低，不再执行) </p>
            <p>默认: <code class="varname">0.35</code></p>
          </dd>
          <dt><a name="hbase.server.thread.wakefrequency"></a><code class="varname">hbase.server.thread.wakefrequency</code></dt>
          <dd>
            <p>service工作的sleep间隔，单位毫秒。
              可以作为service线程的sleep间隔，比如log roller. </p>
            <p>默认: <code class="varname">10000</code></p>
          </dd>
          <dt>hbase.server.versionfile.writeattempts</dt>
          <dd>
            <p>退出前尝试写版本文件的次数。每次尝试由 hbase.server.thread.wakefrequency 毫秒数间隔。</p>
            <p>默认: 3</p>
          </dd>
          <dd>&nbsp;</dd>
          <dt><a name="hbase.hregion.memstore.flush.size"></a><code class="varname">hbase.hregion.memstore.flush.size</code></dt>
          <dd>
            <p> 当memstore的大小超过这个值的时候，会flush到磁盘。这个值被一个线程每隔hbase.server.thread.wakefrequency检查一下。 </p>
            <p>默认:134217728</p>
          </dd>
          <dt><a name="hbase.hregion.preclose.flush.size"></a><code class="varname">hbase.hregion.preclose.flush.size</code></dt>
          <dd>
            <p> 当一个region中的memstore的大小大于这个值的时候，我们又触发了close.会先运行“pre-flush”操作，清理这个需要关闭的memstore，然后将这个region下线。当一个region下线了，我们无法再进行任何写操作。如果一个memstore很大的时候，flush操作会消耗很多时间。"pre-flush"操作意味着在region下线之前，会先把memstore清空。这样在最终执行close操作的时候，flush操作会很快。 </p>
            <p>默认: <code class="varname">5242880</code></p>
          </dd>
          <dt><a name="hbase.hregion.memstore.block.multiplier"></a><code class="varname">hbase.hregion.memstore.block.multiplier</code></dt>
          <dd>
            <p> 如果memstore有hbase.hregion.memstore.block.multiplier倍数的hbase.hregion.flush.size的大小，就会阻塞update操作。这是为了预防在update高峰期会导致的失控。如果不设上界，flush的时候会花很长的时间来合并或者分割，最坏的情况就是引发out of memory异常。(译者注:内存操作的速度和磁盘不匹配，需要等一等。原文似乎有误) </p>
            <p>默认: <code class="varname">2</code></p>
          </dd>
          <dt><a name="hbase.hregion.memstore.mslab.enabled"></a><code class="varname">hbase.hregion.memstore.mslab.enabled</code></dt>
          <dd>
            <p> 体验特性：启用memStore分配本地缓冲区。这个特性是为了防止在大量写负载的时候堆的碎片过多。这可以减少GC操作的频率。(GC有可能会Stop the world)(译者注：实现的原理相当于预分配内存，而不是每一个值都要从堆里分配) </p>
            <p>默认: <code class="varname">true</code></p>
          </dd>
          <dt><a name="hbase.hregion.max.filesize"></a><code class="varname">hbase.hregion.max.filesize</code></dt>
          <dd>
            <p> 最大HStoreFile大小。若某个列族的HStoreFile增长达到这个值，这个Hegion会被切割成两个。
              默认: 10G. </p>
            <p>默认:10737418240</p>
          </dd>
          <dt><a name="hbase.hstore.compactionThreshold"></a><code class="varname">hbase.hstore.compactionThreshold</code></dt>
          <dd>
            <p> 当一个HStore含有多于这个值的HStoreFiles(每一个memstore flush产生一个HStoreFile)的时候，会执行一个合并操作，把这HStoreFiles写成一个。这个值越大，需要合并的时间就越长。 </p>
            <p>默认: <code class="varname">3</code></p>
          </dd>
          <dt><a name="hbase.hstore.blockingStoreFiles"></a><code class="varname">hbase.hstore.blockingStoreFiles</code></dt>
          <dd>
            <p> 当一个HStore含有多于这个值的HStoreFiles(每一个memstore flush产生一个HStoreFile)的时候，会执行一个合并操作，update会阻塞直到合并完成，直到超过了hbase.hstore.blockingWaitTime的值 </p>
            <p>默认: <code class="varname">7</code></p>
          </dd>
          <dt><a name="hbase.hstore.blockingWaitTime"></a><code class="varname">hbase.hstore.blockingWaitTime</code></dt>
          <dd>
            <p> hbase.hstore.blockingStoreFiles所限制的StoreFile数量会导致update阻塞，这个时间是来限制阻塞时间的。当超过了这个时间，HRegion会停止阻塞update操作，不过合并还有没有完成。默认为90s. </p>
            <p>默认: <code class="varname">90000</code></p>
          </dd>
          <dt><a name="hbase.hstore.compaction.max"></a><code class="varname">hbase.hstore.compaction.max</code></dt>
          <dd>
            <p>每个“小”合并的HStoreFiles最大数量。 </p>
            <p>默认: <code class="varname">10</code></p>
          </dd>
          <dt><a name="hbase.hregion.majorcompaction"></a><code class="varname">hbase.hregion.majorcompaction</code></dt>
          <dd>
            <p>一个Region中的所有HStoreFile的major compactions的时间间隔。默认是1天。
              设置为0就是禁用这个功能。 </p>
            <p>默认: <code class="varname">86400000</code></p>
          </dd>
          <dt>hbase.storescanner.parallel.seek.enable</dt>
          <dd>
            <p>允许 StoreFileScanner 并行搜索 StoreScanner, 一个在特定条件下降低延迟的特性。</p>
            <p>默认: false</p>
          </dd>
          <dd>&nbsp;            </dd>
          <dt>hbase.storescanner.parallel.seek.threads</dt>
          <dd>
            <p>并行搜索特性打开后，默认线程池大小。</p>
            <p>默认: 10</p>
          </dd>
          <dd>
            <p>&nbsp;</p>
          </dd>
          <dt><a name="hbase.mapreduce.hfileoutputformat.blocksize"></a><code class="varname">hbase.mapreduce.hfileoutputformat.blocksize</code></dt>
          <dd>
            <p>MapReduce中HFileOutputFormat可以写 storefiles/hfiles.
              这个值是hfile的blocksize的最小值。通常在HBase写Hfile的时候，bloocksize是由table schema(HColumnDescriptor)决定的，但是在mapreduce写的时候，我们无法获取schema中blocksize。这个值越小，你的索引就越大，你随机访问需要获取的数据就越小。如果你的cell都很小，而且你需要更快的随机访问，可以把这个值调低。 </p>
            <p>默认: <code class="varname">65536</code></p>
          </dd>
          <dt><a name="hfile.block.cache.size"></a><code class="varname">hfile.block.cache.size</code></dt>
          <dd>
            <p> 分配给HFile/StoreFile的block cache占最大堆(-Xmx setting)的比例。默认0.25意思是分配25%，设置为0就是禁用，但不推荐。 </p>
            <p>默认:0.25</p>
          </dd>
          <dt><a name="hbase.hash.type"></a><code class="varname">hbase.hash.type</code></dt>
          <dd>
            <p>哈希函数使用的哈希算法。可以选择两个值:: murmur (MurmurHash) 和 jenkins (JenkinsHash).
              这个哈希是给 bloom filters用的. </p>
            <p>默认: <code class="varname">murmur</code></p>
          </dd>
          <dt>hfile.block.index.cacheonwrite</dt>
          <dd>
            <p>This allows to put non-root multi-level index blocks into the block cache at the time the index is being written.</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hfile.index.block.max.size"></a>hfile.index.block.max.size</dt>
          <dd>
            <p>When the size of a leaf-level, intermediate-level, or root-level index block in a multi-level block index grows to this size, the block is written out and a new block is started.</p>
            <p>Default: 131072</p>
          </dd>
          <dt><a name="hfile.format.version"></a>hfile.format.version</dt>
          <dd>
            <p>The HFile format version to use for new files. Set this to 1 to test backwards-compatibility. The default value of this option should be consistent with FixedFileTrailer.MAX_VERSION.</p>
            <p>Default: 2</p>
          </dd>
          <dt><a name="io.storefile.bloom.block.size"></a>io.storefile.bloom.block.size</dt>
          <dd>
            <p>The size in bytes of a single block ("chunk") of a compound Bloom filter. This size is approximate, because Bloom blocks can only be inserted at data block boundaries, and the number of keys per data block varies.</p>
            <p>Default: 131072</p>
          </dd>
          <dt><a name="hfile.block.bloom.cacheonwrite"></a>hfile.block.bloom.cacheonwrite</dt>
          <dd>
            <p>Enables cache-on-write for inline blocks of a compound Bloom filter.</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hbase.rs.cacheblocksonwrite"></a>hbase.rs.cacheblocksonwrite</dt>
          <dd>
            <p>Whether an HFile block should be added to the block cache when the block is finished.</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hbase.rpc.server.engine"></a>hbase.rpc.server.engine</dt>
          <dd>
            <p>Implementation of org.apache.hadoop.hbase.ipc.RpcServerEngine to be used for server RPC call marshalling.</p>
            <p>Default: org.apache.hadoop.hbase.ipc.ProtobufRpcServerEngine</p>
          </dd>
          <dt><a name="hbase.ipc.client.tcpnodelay"></a>hbase.ipc.client.tcpnodelay</dt>
          <dd>
            <p>Set no delay on rpc socket connections. See http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay()</p>
            <p>Default: true</p>
          </dd>
          <dd>&nbsp; </dd>
          <dt><a name="hbase.master.keytab.file"></a><code class="varname">hbase.master.keytab.file</code></dt>
          <dd>
            <p>HMaster server验证登录使用的kerberos keytab 文件路径。(译者注：HBase使用Kerberos实现安全) </p>
            <p>默认: <code class="varname"></code></p>
          </dd>
          <dt><a name="hbase.master.kerberos.principal"></a><code class="varname">hbase.master.kerberos.principal</code></dt>
          <dd>
            <p>例如. "hbase/_HOST@EXAMPLE.COM".  HMaster运行需要使用 kerberos principal name.  principal name 可以在: user/hostname@DOMAIN 中获取. 如果 "_HOST" 被用做hostname
              portion，需要使用实际运行的hostname来替代它。 </p>
            <p>默认: <code class="varname"></code></p>
          </dd>
          <dt><a name="hbase.regionserver.keytab.file"></a><code class="varname">hbase.regionserver.keytab.file</code></dt>
          <dd>
            <p>HRegionServer验证登录使用的kerberos keytab 文件路径。 </p>
            <p>默认: <code class="varname"></code></p>
          </dd>
          <dt><a name="hbase.regionserver.kerberos.principal"></a><code class="varname">hbase.regionserver.kerberos.principal</code></dt>
          <dd>
            <p> 例如. "hbase/_HOST@EXAMPLE.COM".  HRegionServer运行需要使用 kerberos principal name.  principal name 可以在: user/hostname@DOMAIN 中获取. 如果 "_HOST" 被用做hostname
              portion，需要使用实际运行的hostname来替代它。在这个文件中必须要有一个entry来描述 hbase.regionserver.keytab.file </p>
            <p>默认: <code class="varname"></code></p>
          </dd>
          <dt>hadoop.policy.file</dt>
          <dd>
            <p>The policy configuration file used by RPC servers to make authorization decisions on client requests. Only used when HBase security is enabled.</p>
            <p>Default: hbase-policy.xml</p>
          </dd>
          <dt><a name="hbase.superuser"></a>hbase.superuser</dt>
          <dd>
            <p>List of users or groups (comma-separated), who are allowed full privileges, regardless of stored ACLs, across the cluster. Only used when HBase security is enabled.</p>
            <p>Default:</p>
          </dd>
          <dt><a name="hbase.auth.key.update.interval"></a>hbase.auth.key.update.interval</dt>
          <dd>
            <p>The update interval for master key for authentication tokens in servers in milliseconds. Only used when HBase security is enabled.</p>
            <p>Default: 86400000</p>
          </dd>
          <dt><a name="hbase.auth.token.max.lifetime"></a>hbase.auth.token.max.lifetime</dt>
          <dd>
            <p>The maximum lifetime in milliseconds after which an authentication token expires. Only used when HBase security is enabled.</p>
            <p>Default: 604800000</p>
          </dd>
          <dd>&nbsp; </dd>
          <dt><a name="zookeeper.session.timeout"></a><code class="varname">zookeeper.session.timeout</code></dt>
          <dd>
            <p>ZooKeeper 会话超时.HBase把这个值传递改zk集群，向他推荐一个会话的最大超时时间。详见http://hadoop.apache.org/zookeeper/docs/current/zookeeperProgrammers.html#ch_zkSessions
              "The client sends a requested timeout, the server responds with the
              timeout that it can give the client. "。
              单位是毫秒 </p>
            <p>默认: <code class="varname">180000</code></p>
          </dd>
          <dt><a name="zookeeper.znode.parent"></a><code class="varname">zookeeper.znode.parent</code></dt>
          <dd>
            <p>ZooKeeper中的HBase的根ZNode。所有的HBase的ZooKeeper会用这个目录配置相对路径。默认情况下，所有的HBase的ZooKeeper文件路径是用相对路径，所以他们会都去这个目录下面。 </p>
            <p>默认: <code class="varname">/hbase</code></p>
          </dd>
          <dt><a name="zookeeper.znode.rootserver"></a><code class="varname">zookeeper.znode.rootserver</code></dt>
          <dd>
            <p>ZNode 保存的 根region的路径. 这个值是由Master来写，client和regionserver 来读的。如果设为一个相对地址，父目录就是 ${zookeeper.znode.parent}.默认情形下，意味着根region的路径存储在/hbase/root-region-server. </p>
            <p>默认: <code class="varname">root-region-server</code></p>
          </dd>
          <dt><br>
            zookeeper.znode.acl.parent</dt>
          <dd>
            <p>Root ZNode for access control lists.</p>
            <p>Default: acl</p>
          </dd>
          <dt><a name="hbase.coprocessor.region.classes"></a>hbase.coprocessor.region.classes</dt>
          <dd>
            <p>A comma-separated list of Coprocessors that are loaded by default on all tables. For any override coprocessor method, these classes will be called in order. After implementing your own Coprocessor, just put it in HBase's classpath and add the fully qualified class name here. A coprocessor can also be loaded on demand by setting HTableDescriptor.</p>
            <p>Default:</p>
          </dd>
          <dt><a name="hbase.coprocessor.master.classes"></a>hbase.coprocessor.master.classes</dt>
          <dd>
            <p>A comma-separated list of org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are loaded by default on the active HMaster process. For any implemented coprocessor methods, the listed classes will be called in order. After implementing your own MasterObserver, just put it in HBase's classpath and add the fully qualified class name here.</p>
            <p>Default:</p>
          </dd>
          <dd>&nbsp; </dd>
          <dt><a name="hbase.zookeeper.quorum"></a><code class="varname">hbase.zookeeper.quorum</code></dt>
          <dd>
            <p>Zookeeper集群的地址列表，用逗号分割。例如："host1.mydomain.com,host2.mydomain.com,host3.mydomain.com".默认是localhost,是给伪分布式用的。要修改才能在完全分布式的情况下使用。如果在hbase-env.sh设置了HBASE_MANAGES_ZK，这些ZooKeeper节点就会和HBase一起启动。 </p>
            <p>默认: <code class="varname">localhost</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.peerport"></a><code class="varname">hbase.zookeeper.peerport</code></dt>
          <dd>
            <p>ZooKeeper节点使用的端口。详细参见：http://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper </p>
            <p>默认: <code class="varname">2888</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.leaderport"></a><code class="varname">hbase.zookeeper.leaderport</code></dt>
          <dd>
            <p>ZooKeeper用来选择Leader的端口，详细参见：http://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper </p>
            <p>默认: <code class="varname">3888</code></p>
          </dd>
          <dt>hbase.zookeeper.useMulti</dt>
          <dd>
            <p>Instructs HBase to make use of ZooKeeper's multi-update functionality. This allows certain ZooKeeper operations to complete more quickly and prevents some issues with rare Replication failure scenarios (see the release note of HBASE-2611 for an example). IMPORTANT: only set this to true if all ZooKeeper servers in the cluster are on version 3.4+ and will not be downgraded. ZooKeeper versions before 3.4 do not support multi-update and will not fail gracefully if multi-update is invoked (see ZOOKEEPER-1495).</p>
            <p>Default: false</p>
          </dd>
          <dd>&nbsp;</dd>
          <dt><a name="hbase.zookeeper.property.initLimit"></a><code class="varname">hbase.zookeeper.property.initLimit</code></dt>
          <dd>
            <p>ZooKeeper的zoo.conf中的配置。
              初始化synchronization阶段的ticks数量限制 </p>
            <p>默认: <code class="varname">10</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.property.syncLimit"></a><code class="varname">hbase.zookeeper.property.syncLimit</code></dt>
          <dd>
            <p>ZooKeeper的zoo.conf中的配置。
              发送一个请求到获得承认之间的ticks的数量限制 </p>
            <p>默认: <code class="varname">5</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.property.dataDir"></a><code class="varname">hbase.zookeeper.property.dataDir</code></dt>
          <dd>
            <p>ZooKeeper的zoo.conf中的配置。
              快照的存储位置 </p>
            <p>默认: <code class="varname">${hbase.tmp.dir}/zookeeper</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.property.clientPort"></a><code class="varname">hbase.zookeeper.property.clientPort</code></dt>
          <dd>
            <p>ZooKeeper的zoo.conf中的配置。
              客户端连接的端口 </p>
            <p>默认: <code class="varname">2181</code></p>
          </dd>
          <dt><a name="hbase.zookeeper.property.maxClientCnxns"></a><code class="varname">hbase.zookeeper.property.maxClientCnxns</code></dt>
          <dd>
            <p>ZooKeeper的zoo.conf中的配置。
              ZooKeeper集群中的单个节点接受的单个Client(以IP区分)的请求的并发数。这个值可以调高一点，防止在单机和伪分布式模式中出问题。 </p>
            <p>默认: <code class="varname">300</code></p>
          </dd>
          <dt><a name="hbase.rest.port"></a><code class="varname">hbase.rest.port</code></dt>
          <dd>
            <p>HBase REST server的端口</p>
            <p>默认: <code class="varname">8080</code></p>
          </dd>
          <dt><a name="hbase.rest.readonly"></a><code class="varname">hbase.rest.readonly</code></dt>
          <dd>
            <p> 定义REST server的运行模式。可以设置成如下的值：
              
              false: 所有的HTTP请求都是被允许的 - GET/PUT/POST/DELETE.
              true:只有GET请求是被允许的 </p>
            <p>默认: <code class="varname">false</code></p>
          </dd>
          <dt>hbase.defaults.for.version.skip</dt>
          <dd>
            <p>Set to true to skip the 'hbase.defaults.for.version' check. Setting this to true can be useful in contexts other than the other side of a maven generation; i.e. running in an ide. You'll want to set this boolean to true to avoid seeing the RuntimException complaint: "hbase-default.xml file seems to be for and old version of HBase (\${hbase.version}), this version is X.X.X-SNAPSHOT"</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hbase.coprocessor.abortonerror"></a>hbase.coprocessor.abortonerror</dt>
          <dd>
            <p>Set to true to cause the hosting server (master or regionserver) to abort if a coprocessor throws a Throwable object that is not IOException or a subclass of IOException. Setting it to true might be useful in development environments where one wants to terminate the server as soon as possible to simplify coprocessor failure analysis.</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hbase.online.schema.update.enable"></a>hbase.online.schema.update.enable</dt>
          <dd>
            <p>Set true to enable online schema changes. This is an experimental feature. There are known issues modifying table schemas at the same time a region split is happening so your table needs to be quiescent or else you have to be running with splits disabled.</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hbase.table.lock.enable"></a>hbase.table.lock.enable</dt>
          <dd>
            <p>Set to true to enable locking the table in zookeeper for schema change operations. Table locking from master prevents concurrent schema modifications to corrupt table state.</p>
            <p>Default: true</p>
          </dd>
          <dt><a name="dfs.support.append"></a>dfs.support.append</dt>
          <dd>
            <p>Does HDFS allow appends to files? This is an hdfs config. set in here so the hdfs client will do append support. You must ensure that this config. is true serverside too when running hbase (You will have to restart your cluster after setting it).</p>
            <p>Default: true</p>
          </dd>
          <dt><a name="hbase.thrift.minWorkerThreads"></a>hbase.thrift.minWorkerThreads</dt>
          <dd>
            <p>The "core size" of the thread pool. New threads are created on every connection until this many threads are created.</p>
            <p>Default: 16</p>
          </dd>
          <dt><a name="hbase.thrift.maxWorkerThreads"></a>hbase.thrift.maxWorkerThreads</dt>
          <dd>
            <p>The maximum size of the thread pool. When the pending request queue overflows, new threads are created until their number reaches this number. After that, the server starts dropping connections.</p>
            <p>Default: 1000</p>
          </dd>
          <dt><a name="hbase.thrift.maxQueuedRequests"></a>hbase.thrift.maxQueuedRequests</dt>
          <dd>
            <p>The maximum number of pending Thrift connections waiting in the queue. If there are no idle threads in the pool, the server queues requests. Only when the queue overflows, new threads are added, up to hbase.thrift.maxQueuedRequests threads.</p>
            <p>Default: 1000</p>
          </dd>
          <dt><a name="hbase.offheapcache.percentage"></a>hbase.offheapcache.percentage</dt>
          <dd>
            <p>The amount of off heap space to be allocated towards the experimental off heap cache. If you desire the cache to be disabled, simply set this value to 0.</p>
            <p>Default: 0</p>
          </dd>
          <dt><a name="hbase.data.umask.enable"></a>hbase.data.umask.enable</dt>
          <dd>
            <p>Enable, if true, that file permissions should be assigned to the files written by the regionserver</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hbase.data.umask"></a>hbase.data.umask</dt>
          <dd>
            <p>File permissions that should be used to write data files when hbase.data.umask.enable is true</p>
            <p>Default: 000</p>
          </dd>
          <dt><a name="hbase.metrics.showTableName"></a>hbase.metrics.showTableName</dt>
          <dd>
            <p>Whether to include the prefix "tbl.tablename" in per-column family metrics. If true, for each metric M, per-cf metrics will be reported for tbl.T.cf.CF.M, if false, per-cf metrics will be aggregated by column-family across tables, and reported for cf.CF.M. In both cases, the aggregated metric M across tables and cfs will be reported.</p>
            <p>Default: true</p>
          </dd>
          <dt><a name="hbase.metrics.exposeOperationTimes"></a>hbase.metrics.exposeOperationTimes</dt>
          <dd>
            <p>Whether to report metrics about time taken performing an operation on the region server. Get, Put, Delete, Increment, and Append can all have their times exposed through Hadoop metrics per CF and per region.</p>
            <p>Default: true</p>
          </dd>
          <dt><a name="hbase.master.hfilecleaner.plugins"></a>hbase.master.hfilecleaner.plugins</dt>
          <dd>
            <p>A comma-separated list of HFileCleanerDelegate invoked by the HFileCleaner service. These HFiles cleaners are called in order, so put the cleaner that prunes the most files in front. To implement your own HFileCleanerDelegate, just put it in HBase's classpath and add the fully qualified class name here. Always add the above default log cleaners in the list as they will be overwritten in hbase-site.xml.</p>
            <p>Default: org.apache.hadoop.hbase.master.cleaner.TimeToLiveHFileCleaner</p>
          </dd>
          <dt><a name="hbase.regionserver.catalog.timeout"></a>hbase.regionserver.catalog.timeout</dt>
          <dd>
            <p>Timeout value for the Catalog Janitor from the regionserver to META.</p>
            <p>Default: 600000</p>
          </dd>
          <dt><a name="hbase.master.catalog.timeout"></a>hbase.master.catalog.timeout</dt>
          <dd>
            <p>Timeout value for the Catalog Janitor from the master to META.</p>
            <p>Default: 600000</p>
          </dd>
          <dt><a name="hbase.config.read.zookeeper.config"></a>hbase.config.read.zookeeper.config</dt>
          <dd>
            <p>Set to true to allow HBaseConfiguration to read the zoo.cfg file for ZooKeeper properties. Switching this to true is not recommended, since the functionality of reading ZK properties from a zoo.cfg file has been deprecated.</p>
            <p>Default: false</p>
          </dd>
          <dt><a name="hbase.snapshot.enabled"></a>hbase.snapshot.enabled</dt>
          <dd>
            <p>Set to true to allow snapshots to be taken / restored / cloned.</p>
            <p>Default: true</p>
          </dd>
          <dt><a name="hbase.rest.threads.max"></a>hbase.rest.threads.max</dt>
          <dd>
            <p>The maximum number of threads of the REST server thread pool. Threads in the pool are reused to process REST requests. This controls the maximum number of requests processed concurrently. It may help to control the memory used by the REST server to avoid OOM issues. If the thread pool is full, incoming requests will be queued up and wait for some free threads. The default is 100.</p>
            <p>Default: 100</p>
          </dd>
          <dt><a name="hbase.rest.threads.min"></a>hbase.rest.threads.min</dt>
          <dd>
            <p>The minimum number of threads of the REST server thread pool. The thread pool always has at least these number of threads so the REST server is ready to serve incoming requests. The default is 2.</p>
            <p>Default: 2</p>
          </dd>
          <dt>&nbsp;</dt>
        </dl>
      </div>
    </div>
  </div>
  <div class="section" title="3.2.  hbase-env.sh">
    <div class="titlepage">
      <div>
        <div>
          <h2 class="title" style="clear: both"><a name="hbase.env.sh"></a>2.3.2.&nbsp;<code class="filename">hbase-env.sh</code></h2>
        </div>
      </div>
    </div>
    <p>在这个文件里面设置HBase环境变量。比如可以配置JVM启动的堆大小或者GC的参数。你还可在这里配置HBase的参数，如Log位置，niceness(译者注:优先级)，ssh参数还有pid文件的位置等等。打开文件<code class="filename">conf/hbase-env.sh</code>细读其中的内容。每个选项都是有详尽的注释的。你可以在此添加自己的环境变量。 </p>
    <p> 这个文件的改动系统HBase重启才能生效。 </p>
  </div>
  <div class="section" title="3.3. log4j.properties">
    <div class="titlepage">
      <div>
        <div>
          <h2 class="title" style="clear: both"><a name="log4j"></a>2.3.3.&nbsp;<code class="filename">log4j.properties</code></h2>
        </div>
      </div>
    </div>
    <p>编辑这个文件可以改变HBase的日志的级别，轮滚策略等等。 </p>
    <p> 这个文件的改动系统HBase重启才能生效。
      日志级别的更改会影响到HBase UI </p>
  </div>
  <div class="section" title="3.4. 重要的配置">
    <div class="titlepage">
      <div>
        <div>
          <div class="section" title="3.7. 连接HBase集群的客户端配置和依赖">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title" style="clear: both"><a name="client_dependencies"></a>2.3.4.&nbsp;连接HBase集群的客户端配置和依赖</h3>
                </div>
              </div>
            </div>
            <p> 因为HBase的Master有可能转移，所有客户端需要访问ZooKeeper来获得现在的位置。ZooKeeper会保存这些值。因此客户端必须知道Zookeeper集群的地址，否则做不了任何事情。通常这个地址存在 <code class="filename">hbase-site.xml</code> 里面，客户端可以从<code class="varname">CLASSPATH</code>取出这个文件.</p>
            <p>如果你是使用一个IDE来运行HBase客户端，你需要将<code class="filename">conf/</code>放入你的 classpath,这样 <code class="filename">hbase-site.xml</code>就可以找到了，(或者把hbase-site.xml放到 <code class="filename">src/test/resources</code>，这样测试的时候可以使用). </p>
            <p> HBase客户端最小化的依赖是 hbase, hadoop, log4j, commons-logging, commons-lang,
              和 ZooKeeper ，这些jars 需要能在 <code class="varname">CLASSPATH</code> 中找到。 </p>
            <p> 下面是一个基本的客户端 <code class="filename">hbase-site.xml</code> 例子： </p>
            <pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by region servers.
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
          </pre>
            <p></p>
            <div class="section" title="3.7.1. Java客户端配置">
              <div class="titlepage">
                <div>
                  <div>
                    <h4 class="title"><a name="d613e2045"></a>2.3.4.1.&nbsp;Java客户端配置</h4>
                  </div>
                  <div>
                    <h5 class="subtitle">Java是如何读到<code class="filename">hbase-site.xml</code> 的内容的</h5>
                  </div>
                </div>
              </div>
              <p>Java客户端使用的配置信息是被映射在一个<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration" target="_top">HBaseConfiguration</a> 实例中.
                
                HBaseConfiguration有一个工厂方法, <code class="code">HBaseConfiguration.create();</code>,运行这个方法的时候，他会去<code class="varname">CLASSPATH</code>,下找<code class="filename">hbase-site.xml</code>，读他发现的第一个配置文件的内容。
                
                (这个方法还会去找<code class="filename">hbase-default.xml</code> ; <code class="filename">hbase.X.X.X.jar</code>里面也会有一个an hbase-default.xml). 不使用任何<code class="filename">hbase-site.xml</code>文件直接通过Java代码注入配置信息也是可以的。例如，你可以用编程的方式设置ZooKeeper信息，只要这样做: </p>
              <pre class="programlisting">Configuration config = HBaseConfiguration.create();
config.set("hbase.zookeeper.quorum", "localhost");  // Here we are running zookeeper locally</pre>
              <p> 如果有多ZooKeeper实例，你可以使用逗号列表。(就像在<code class="filename">hbase-site.xml</code> 文件中做得一样).
                这个 <code class="classname">Configuration</code> 实例会被传递到 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>,
                之类的实例里面去. </p>
            </div>
          </div>
          <div class="footnotes"><br>
            <hr width="100" align="left">
            <div class="footnote"></div>
            <div class="footnote"> </div>
          </div>
          <div class="section" title="2.1. 需要的软件">
            <div class="section" title="2.3. 配置例子">
              <div class="section" title="2.3.1. 简单的分布式HBase安装">
                <div class="titlepage">
                  <div>
                    <div>
                      <h2 class="title"><a name="example_config"></a>2.4. 配置示例</h2>
                      <h3 class="title"><a name="d613e896"></a>2.4.1.&nbsp;简单的分布式HBase安装</h3>
                    </div>
                  </div>
                </div>
                <p>这里是一个10节点的HBase的简单示例，这里的配置都是基本的，节点名为 <code class="varname">example0</code>, <code class="varname">example1</code>... 一直到 <code class="varname">example9</code> .  HBase Master 和
                  HDFS namenode 运作在同一个节点 <code class="varname">example0</code>上.
                  RegionServers 运行在节点 <code class="varname">example1</code>-<code class="varname">example9</code>. 一个 3-节点
                  ZooKeeper 集群运行在<code class="varname">example1</code>, <code class="varname">example2</code>, 和 <code class="varname">example3</code>，端口保持默认. ZooKeeper 的数据保存在目录 <code class="filename">/export/zookeeper</code>. 下面我们展示主要的配置文件-- <code class="filename">hbase-site.xml</code>, <code class="filename">regionservers</code>, 和 <code class="filename">hbase-env.sh</code> -- 这些文件可以在 <code class="filename">conf</code>目录找到.</p>
                <div class="section" title="2.3.1.1. hbase-site.xml">
                  <div class="titlepage">
                    <div>
                      <div>
                        <h4 class="title"><a name="hbase_site"></a>2.4.1.1.&nbsp;<code class="filename">hbase-site.xml</code></h4>
                      </div>
                    </div>
                  </div>
                  <pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
    &lt;value&gt;/export/zookeeper&lt;/value&gt;
    &lt;description&gt;Property from ZooKeeper's config zoo.cfg.
    The directory where the snapshot is stored.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://example0:9000/hbase&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;The mode the cluster will be in. Possible values are
      false: standalone and pseudo-distributed setups with managed Zookeeper
      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;

          </pre>
                </div>
                <div class="section" title="2.3.1.2. regionservers">
                  <div class="titlepage">
                    <div>
                      <div>
                        <h4 class="title"><a name="regionservers"></a>2.4.1.2.&nbsp;<code class="filename">regionservers</code></h4>
                      </div>
                    </div>
                  </div>
                  <p>这个文件把RegionServer的节点列了下来。在这个例子里面我们让所有的节点都运行RegionServer,除了第一个节点 <code class="varname">example1</code>，它要运行 HBase Master 和
                    HDFS namenode</p>
                  <pre class="programlisting">    example1
    example3
    example4
    example5
    example6
    example7
    example8
    example9
          </pre>
                </div>
                <div class="section" title="2.3.1.3. hbase-env.sh">
                  <div class="titlepage">
                    <div>
                      <div>
                        <h4 class="title"><a name="hbase_env"></a>2.4.1.3.&nbsp;<code class="filename">hbase-env.sh</code></h4>
                      </div>
                    </div>
                  </div>
                  <p>下面我们用<span class="command"><strong>diff</strong></span> 命令来展示 <code class="filename">hbase-env.sh</code> 文件相比默认变化的部分. 我们把HBase的堆内存设置为4G而不是默认的1G.</p>
                  <pre class="programlisting">    
$ git diff hbase-env.sh
diff --git a/conf/hbase-env.sh b/conf/hbase-env.sh
index e70ebc6..96f8c27 100644
--- a/conf/hbase-env.sh
+++ b/conf/hbase-env.sh
@@ -31,7 +31,7 @@ export JAVA_HOME=/usr/lib//jvm/java-6-sun/
 # export HBASE_CLASSPATH=
 
 # The maximum amount of heap to use, in MB. Default is 1000.
-# export HBASE_HEAPSIZE=1000
+export HBASE_HEAPSIZE=4096
 
 # Extra Java runtime options.
 # Below are what we set by default.  May only work with SUN JVM.

          </pre>
                  <p>你可以使用 <span class="command"><strong>rsync</strong></span> 来同步 <code class="filename">conf</code> 文件夹到你的整个集群.</p>
                </div>
              </div>
            </div>
          </div>
          <div class="footnotes"><br>
            <hr width="100" align="left">
            <div class="footnote"></div>
</div>
          <h2 class="title" style="clear: both"><a name="important_configurations"></a>2.5.&nbsp;重要的配置</h2>
        </div>
      </div>
    </div>
    <p>下面我们会列举<span class="emphasis"><em>重要</em></span> 的配置. 这个章节讲述必须的配置和那些值得一看的配置。(译者注:淘宝的博客也有本章节的内容，<a class="link" href="http://rdc.taobao.com/team/jm/archives/975" target="_top">HBase性能调优</a>，很详尽)。 </p>
  </div>
  <div class="section" title="3.5. 必须的配置">
    <div class="titlepage">
      <div>
        <div>
          <div title="2.8.1. Required Configurations">
            <div>
              <div>
                <div>
                  <h3>2.5.1. 必须的配置</h3>
                </div>
              </div>
            </div>
            <p>参考 <a href="#os" title="2.2. Operating System">Section 2.2, “操作系统”</a> 和 <a href="#hadoop" title="2.3. Hadoop">Section 2.3, “Hadoop”</a> 节.</p>
          </div>
          <div title="2.8.2. Recommended Configurations">
            <div>
              <div>
                <div>
                  <h3><a name="recommended_configurations"></a>2.5.2. 推荐配置</h3>
                </div>
              </div>
            </div>
            <div title="2.8.2.1. zookeeper.session.timeout">
              <div>
                <div>
                  <div>
                    <h4><a name="zookeeper.session.timeout"></a>2.5.2.1. zookeeper.session.timeout</h4>
                  </div>
                </div>
              </div>
              <p>这个默认值是3分钟。这意味着一旦一个server宕掉了，Master至少需要3分钟才能察觉到宕机，开始恢复。你可能希望将这个超时调短，这样Master就能更快的察觉到了。在你调这个值之前，你需要确认你的JVM的GC参数，否则一个长时间的GC操作就可能导致超时。（当一个RegionServer在运行一个长时间的GC的时候，你可能想要重启并恢复它）.</p>
              <p>要想改变这个配置，可以编辑 <code class="filename">hbase-site.xml</code>,
                将配置部署到全部集群，然后重启。</p>
              <p>我们之所以把这个值调的很高，是因为我们不想一天到晚在论坛里回答新手的问题。“为什么我在执行一个大规模数据导入的时候Region Server死掉啦”，通常这样的问题是因为长时间的GC操作引起的，他们的JVM没有调优。我们是这样想的，如果一个人对HBase不很熟悉，不能期望他知道所有，打击他的自信心。等到他逐渐熟悉了，他就可以自己调这个参数了。</p>
            </div>
            <div title="2.8.2.2. Number of ZooKeeper Instances">
              <div>
                <div>
                  <div>
                    <h4><a name="zookeeper.instances"></a>2.5.2.2.  ZooKeeper 实例个数</h4>
                  </div>
                </div>
              </div>
              <p>参考 <a href="#zookeeper" title="2.5. ZooKeeper">Section 2.5, “ZooKeeper”</a>.</p>
            </div>
            <div title="2.8.2.3. hbase.regionserver.handler.count">
              <div>
                <div>
                  <div>
                    <h4><a name="hbase.regionserver.handler.count"></a>2.5.2.3. hbase.regionserver.handler.count</h4>
                  </div>
                </div>
              </div>
              <p>这个设置决定了处理用户请求的线程数量。默认是10，这个值设的比较小，主要是为了预防用户用一个比较大的写缓冲，然后还有很多客户端并发，这样region servers会垮掉。有经验的做法是，当请求内容很大(上MB，如大puts, 使用缓存的scans)的时候，把这个值放低。请求内容较小的时候(gets, 小puts, ICVs, deletes)，把这个值放大。 </p>
              <p> 当客户端的请求内容很小的时候，把这个值设置的和最大客户端数量一样是很安全的。一个典型的例子就是一个给网站服务的集群，put操作一般不会缓冲,绝大多数的操作是get操作。 </p>
              <p> 把这个值放大的危险之处在于，把所有的Put操作缓冲意味着对内存有很大的压力，甚至会导致OutOfMemory.一个运行在内存不足的机器的RegionServer会频繁的触发GC操作，渐渐就能感受到停顿。(因为所有请求内容所占用的内存不管GC执行几遍也是不能回收的)。一段时间后，集群也会受到影响，因为所有的指向这个region的请求都会变慢。这样就会拖累集群，加剧了这个问题。 </p>
<p>你可能会对handler太多或太少有感觉，可以通过 <a href="#rpc.logging" title="12.2.2.1. Enabling RPC-level logging">Section 12.2.2.1, “启用 RPC级 日志”</a> ，在单个RegionServer启动log并查看log末尾 (请求队列消耗内存)。</p>
            </div>
            <div title="2.8.2.4. Configuration for large memory machines">
              <div>
                <div>
                  <div>
                    <h4><a name="big_memory"></a>2.5.2.4. <span class="title">大内存机器的配置</span></h4>
                  </div>
                </div>
              </div>
              <p>HBase有一个合理的保守的配置，这样可以运作在所有的机器上。如果你有台大内存的集群-HBase有8G或者更大的heap,接下来的配置可能会帮助你. TODO.</p>
            </div>
            <div title="2.8.2.5. Compression">
              <div>
                <div>
                  <div>
                    <h4><a name="config.compression"></a>2.5.2.5. 压缩</h4>
                  </div>
                </div>
              </div>
              <p>应该考虑启用ColumnFamily 压缩。有好几个选项，通过降低存储文件大小以降低IO，降低消耗且大多情况下提高性能。</p>
<p>参考 <a href="#compression" title="Appendix C. Compression In HBase">Appendix C, <em> HBase压缩 </em></a> 获取更多信息.</p>
            </div>
            <div title="2.8.2.6. Bigger Regions">
              <div>
                <div>
                  <div>
                    <h4><a name="bigger.regions"></a>2.5.2.6. 较大 Regions</h4>
                  </div>
                </div>
              </div>
              <p>更大的Region可以使你集群上的Region的总数量较少。
        一般来言，更少的Region可以使你的集群运行更加流畅。(你可以自己随时手工将大Region切割，这样单个热点Region就会被分布在集群的更多节点上)。</p>
              <p>较少的Region较好。一般每个RegionServer在20到小几百之间。 调整Region大小以适合该数字。</p>
              <p>&nbsp;</p>
              <p> 0.90.x 版本, 默认情况下单个Region是256MB。Region 大小的上界是 4Gb.  0.92.x 版本, 由于 HFile v2 已经将Region大小支持得大很多， (如, 20Gb).</p>
              <p>可能需要实验，基于硬件和应用需要进行配置。</p>
              <p>可以调整<code class="filename">hbase-site.xml</code>中的 <code class="code">hbase.hregion.max.filesize</code>属性. RegionSize 也可以基于每个表设置：  <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HTableDescriptor.html" target="_top">HTableDescriptor</a>.</p>
            </div>
            <div title="2.8.2.7. Managed Splitting">
              <div>
                <div>
                  <div>
                    <h4><a name="disable.splitting"></a>2.5.2.7. <span class="title">管理</span> Splitting</h4>
                  </div>
                </div>
              </div>
              <p>除了让HBase自动切割你的Region,你也可以手动切割。 <sup>[<a name="d613e1974" href="#ftn.d613e1974" class="footnote">12</a>]</sup> 随着数据量的增大，splite会被持续执行。如果你需要知道你现在有几个region,比如长时间的debug或者做调优，你需要手动切割。通过跟踪日志来了解region级的问题是很难的，因为他在不停的切割和重命名。data offlineing bug和未知量的region会让你没有办法。如果一个 <code class="classname">HLog</code> 或者 <code class="classname">StoreFile</code>由于一个奇怪的bug，HBase没有执行它。等到一天之后，你才发现这个问题，你可以确保现在的regions和那个时候的一样，这样你就可以restore或者replay这些数据。你还可以调优你的合并算法。如果数据是均匀的，随着数据增长，很容易导致split / compaction疯狂的运行。因为所有的region都是差不多大的。用手的切割，你就可以交错执行定时的合并和切割操作，降低IO负载。 </p>
              <p> 为什么我关闭自动split呢？因为自动的splite是配置文件中的 <code class="code">hbase.hregion.max.filesize</code>决定的. 你把它设置成<code class="varname">Long.MAX_VALUE</code>是不推荐的做法，要是你忘记了手工切割怎么办.推荐的做法是设置成100GB，一旦到达这样的值，至少需要一个小时执行 major compactions。 </p>
              <p>那什么是最佳的在pre-splite regions的数量呢。这个决定于你的应用程序了。你可以先从低的开始，比如每个server10个pre-splite regions.然后花时间观察数据增长。有太少的region至少比出错好，你可以之后再rolling split.一个更复杂的答案是这个值是取决于你的region中的最大的storefile。随着数据的增大，这个也会跟着增大。 你可以当这个文件足够大的时候，用一个定时的操作使用<code class="classname">Store</code>的合并选择算法(compact selection algorithm)来仅合并这一个HStore。如果你不这样做，这个算法会启动一个 major compactions，很多region会受到影响，你的集群会疯狂的运行。需要注意的是，这样的疯狂合并操作是数据增长造成的，而不是手动分割操作决定的。 </p>
              <p> 如果你 pre-split 导致 regions 很小,你可以通过配置<code class="varname">HConstants.MAJOR_COMPACTION_PERIOD</code>把你的major compaction参数调大 </p>
              <p>如果你的数据变得太大，可以使用<code class="classname">org.apache.hadoop.hbase.util.RegionSplitter</code> 脚本来执行针对全部集群的一个网络IO安全的rolling split操作。 </p>
<p>&nbsp;</p>
            </div>
            <div title="2.8.2.8. Managed Compactions">
              <div>
                <div>
                  <div>
                    <h4><a name="managed.compactions"></a>2.5.2.8. <span class="title">管理</span> Compactions</h4>
                  </div>
                </div>
              </div>
              <p>通常管理技术是手动管理主紧缩(major compactions)， 而不是让HBase 来做。 缺省HConstants.MAJOR_COMPACTION_PERIOD 是一天。主紧缩可能强行进行，在你并不太希望发生的时候——特别是在一个繁忙系统。关闭自动主紧缩，设置该值为0.</p>
              <p>重点强调，主紧缩对存储文件(StoreFile)清理是绝对必要的。唯一变量是发生的时间。可以通过HBase shell进行管理，或通过 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact%28java.lang.String%29" target="_top">HBaseAdmin</a>.</p>
              <p>更多信息关于紧缩和紧缩文件选择过程，参考 <a href="#compaction" title="9.7.5.5. Compaction">Section 9.7.5.5, “紧缩”</a></p>
            </div>
            <div title="2.8.2.9. Speculative Execution">
              <div>
                <div>
                  <div>
                    <h4><a name="spec.ex"></a>2.5.2.9.   预测执行  (Speculative Execution)</h4>
                  </div>
                </div>
              </div>
              <p> MapReduce任务的预测执行缺省是打开的，HBase集群一般建议在系统级关闭预测执行，除非在某种特殊情况下需要打开，此时可以每任务配置。设置mapred.map.tasks.speculative.execution 和 mapred.reduce.tasks.speculative.execution 为 false.</p>
            </div>
          </div>
          <div title="2.8.3. Other Configurations">
            <div>
              <div>
                <div>
                  <h3><a name="other_configuration"></a>2.5.3. 其他配置</h3>
                </div>
              </div>
            </div>
            <div title="2.8.3.1. Balancer">
              <div>
                <div>
                  <div>
                    <h4><a name="balancer_config"></a>2.5.3.1. 负载均衡</h4>
                  </div>
                </div>
              </div>
              <p>负载均衡器(LoadBalancer)是在主服务器上运行的定期操作，以重新分布集群区域。通过hbase.balancer.period 设置，缺省值300000 (5 分钟).</p>
              <p>参考 <a href="#master.processes.loadbalancer" title="9.5.4.1. LoadBalancer">Section 9.5.4.1, “负载均衡”</a> 获取关于负载均衡器( LoadBalancer )的更多信息。</p>
            </div>
            <div title="2.8.3.2. Disabling Blockcache">
              <div>
                <div>
                  <div>
                    <h4><a name="disabling.blockcache"></a>2.5.3.2. 禁止块缓存(Blockcache)</h4>
                  </div>
                </div>
              </div>
              <p>不要关闭块缓存 (通过hbase.block.cache.size 为 0 来设置)。当前如果关闭块缓存会很不好，因为区域服务器会花很多时间不停加载hfile指数。如果工作集如此配置块缓存没有好处，最少应保证hfile指数保存在块缓存内的大小(可以通过查询区域服务器的UI，得到大致的数值。可以看到网页的上方有块指数值统计).</p>
            </div>
          </div>
          <div>
            <div title="2.5. The Important Configurations">
              <div title="2.5.3. Other Configurations">
                <div title="2.5.3.3. Nagle's or the small package problem">
                  <div>
                    <div>
                      <div>
                        <h4>2.5.3.3. <a href="http://en.wikipedia.org/wiki/Nagle's_algorithm" target="_top">Nagle算法</a> 或小包问题</h4>
                      </div>
                    </div>
                  </div>
                  <p>如果操作HBase时看到大量40ms左右的偶然延时，尝试Nagles配置。如，参考用户邮件列表线索, <a href="http://search-hadoop.com/m/pduLg2fydtE/Inconsistent+scan+performance+with+caching+set+&subj=Re+Inconsistent+scan+performance+with+caching+set+to+1" target="_top">Inconsistent scan performance with caching set to 1</a> ，该议题在其中启用tcpNoDelay (译者注，本英文原文notcpdelay有误)提高了扫描速度。你也可以查看该文档的尾部图表<a href="https://issues.apache.org/jira/browse/HBASE-7008" target="_top">：HBASE-7008 Set scanner caching to a better default</a>  (xie liang)，我们的Lars Hofhansl 尝试了各种不同的数据大小，Nagle打开或关闭的测量结果。</p>
                </div>
              </div>
            </div>
            <br>
            <br>
            <hr width="100" align="left">
            <div>
              <p>&nbsp;</p>
            </div>
          </div>
          <div>
            <div>
              <div></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="section" title="3.6. 推荐的配置">
    <div class="titlepage">
      <div>
        <div>
<div class="footnote"></div>
          <div>
            <p>[<a id="ftn.d1952e270" href="#d1952e270">1</a>] Be careful editing XML. Make sure you close all elements. Run your file through <strong>xmllint</strong> or similar to ensure well-formedness of your document after an edit session.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e311" href="#d1952e311">2</a>] The <a href="https://github.com/sujee/hadoop-dns-checker" target="_top">hadoop-dns-checker</a> tool can be used to verify DNS is working correctly on the cluster. The project README file provides detailed instructions on usage.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e382" href="#d1952e382">3</a>] 参考 Jack Levin's <a href="" target="_top">major hdfs issues</a> note up on the user list.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e389" href="#d1952e389">4</a>] The requirement that a database requires upping of system limits is not peculiar to HBase. 参考 for example the section <em>Setting Shell Limits for the Oracle User</em> in<a href="http://www.akadia.com/services/ora_linux_install_10g.html" target="_top">Short Guide to install Oracle 10 on Linux</a>.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e401" href="#d1952e401">5</a>] A useful read setting config on you hadoop cluster is Aaron Kimballs' Configuration Parameters: What can you just ignore?</p>
          </div>
          <div>[<a name="ftn.d1952e474" href="#d1952e474">6</a>] &lt;title&gt;On Hadoop Versions&lt;/title&gt;
            <p>[<a id="ftn.d1952e474" href="#d1952e474">6</a>] The Cloudera blog post <a href="http://www.cloudera.com/blog/2012/01/an-update-on-apache-hadoop-1-0/" target="_top">An update on Apache Hadoop 1.0</a> by Charles Zedlweski has a nice exposition on how all the Hadoop versions relate. Its worth checking out if you are having trouble making sense of the Hadoop version morass.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e504" href="#d1952e504">7</a>] Until recently only the <a href="http://svn.apache.org/viewvc/hadoop/common/branches/branch-0.20-append/" target="_top">branch-0.20-append</a> branch had a working sync but no official release was ever made from this branch. You had to build it yourself. Michael Noll wrote a detailed blog, <a href="http://www.michael-noll.com/blog/2011/04/14/building-an-hadoop-0-20-x-version-for-hbase-0-90-2/" target="_top">Building an Hadoop 0.20.x version for HBase 0.90.2</a>, on how to build an Hadoop from branch-0.20-append. Recommended.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e514" href="#d1952e514">8</a>] Praveen Kumar has written a complimentary article, <a href="http://praveen.kumar.in/2011/06/20/building-hadoop-and-hbase-for-hbase-maven-application-development/" target="_top">Building Hadoop and HBase for HBase Maven application development</a>.</p>
          </div>
          <div>[<a name="ftn.d1952e520" href="#d1952e520">9</a>] dfs.support.append</div>
          <div>
            <p>[<a id="ftn.d1952e591" href="#d1952e591">10</a>] 参考 <a href="http://ccgtech.blogspot.com/2010/02/hadoop-hdfs-deceived-by-xciever.html" target="_top">Hadoop HDFS: Deceived by Xciever</a> for an informative rant on xceivering.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e649" href="#d1952e649">11</a>] The pseudo-distributed vs fully-distributed nomenclature comes from Hadoop.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e703" href="#d1952e703">12</a>] 参考 <a href="#pseudo.extras" title="2.4.2.1.2. Pseudo-distributed Extras">Section 2.4.2.1.2, “Pseudo-distributed Extras”</a> for notes on how to start extra Masters and RegionServers when running pseudo-distributed.</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e968" href="#d1952e968">13</a>] 对 ZooKeeper 全部配置，参考ZooKeeper 的<code class="filename">zoo.cfg</code>. HBase 没有包含 <code class="filename">zoo.cfg</code> ，所以需要浏览合适的独立ZooKeeper下载版本的 <code class="filename">conf</code> 目录找到。</p>
          </div>
          <div>
            <p>[<a id="ftn.d1952e2739" href="#d1952e2739">14</a>] What follows is taken from the javadoc at the head of the org.apache.hadoop.hbase.util.RegionSplitter tool added to HBase post-0.90.0 release.</p>
          </div>
<p>&nbsp;</p>
        </div>
      </div>
    </div>
    <div class="section" title="3.6.6. 管理 Splitting"> </div>
  </div>
  <div class="section" title="3.7. 连接HBase集群的客户端配置和依赖">
    <div class="titlepage">
      <div>
        <div></div>
      </div>
    </div>
  </div>
  <div class="footnotes"> </div></div></div></div></div></div></div><div class="footnotes"></div></div><div class="chapter" title="Chapter 2. 升级"><div class="titlepage"><div><div>
  <h2 class="title"><a name="upgrading"></a>Chapter&nbsp;3.&nbsp;升级</h2></div></div></div><div class="toc"></div>
  <p>
    不能跳过主要版本升级。如果想从0.20.x 升级到 0.92.x，必须从0.20.x 升级到 0.90.x ，再从0.90.x 升级到 0.92.x.</p>
  <p>参见 <a class="xref" href="#requirements" title="2.1. 需要的软件">Section&nbsp;2, “配置”</a>, 需要特别注意有关Hadoop 版本的信息.
    </p>
  <div title="3.1. Upgrading from 0.94.x to 0.96.x">
    <div>
      <div>
        <div>
          <h2>3.1. 从 0.94.x 升级到 0.96.x</h2>
        </div>
        <div>
          <h3>The Singularity</h3>
        </div>
      </div>
    </div>
    <p>You will have to stop your old 0.94 cluster completely to upgrade. If you are replicating between clusters, both clusters will have to go down to upgrade. Make sure it is a clean shutdown so there are no WAL files laying around (TODO: Can 0.96 read 0.94 WAL files?). Make sure zookeeper is cleared of state. All clients must be upgraded to 0.96 too.</p>
    <p>The API has changed in a few areas; in particular how you use coprocessors (TODO: MapReduce too?)</p>
  </div>
  <div title="3.2. Upgrading from 0.92.x to 0.94.x">
    <div>
      <div>
        <div>
          <h2><a name="upgrade0.94"></a>3.2. 从 0.92.x 升级到 0.94.x</h2>
        </div>
      </div>
    </div>
    <p>0.92 和 0.94 接口兼容，可平滑升级。</p>
  </div>
  <div title="3.3. Upgrading from 0.90.x to 0.92.x">
    <div>
      <div>
        <div></div>
      </div>
    </div>
</div>
  <div class="chapter" title="Chapter 2. 升级">
    <div class="footnotes">
      <div class="footnote">
        <p>&nbsp;</p>
      </div>
    </div>
  </div>
  <div class="chapter" title="Chapter 3. 配置">
    <div class="titlepage">
      <div>
        <div>
          <div title="3.2. Upgrading from 0.90.x to 0.92.x">
            <div>
              <div>
                <div>
                  <h2>3.3. 从 0.90.x 到 0.92.x 升级</h2>
                </div>
                <div>
                  <h3>升级指引</h3>
                </div>
              </div>
            </div>
            <p>You will find that 0.92.0 runs a little differently to 0.90.x releases. Here are a few things to watch out for upgrading from 0.90.x to 0.92.0.</p>
            <div title="tl;dr">
              <h3>&nbsp;</h3>
              <p>If you've not patience, here are the important things to know upgrading.</p>
              <div>
                <ol type="1">
                  <li>Once you upgrade, you can’t go back.</li>
                  <li>MSLAB is on by default. Watch that heap usage if you have a lot of regions.</li>
                  <li>Distributed splitting is on by defaul. It should make region server failover faster.</li>
                  <li>There’s a separate tarball for security.</li>
                  <li>If -XX:MaxDirectMemorySize is set in your hbase-env.sh, it’s going to enable the experimental off-heap cache (You may not want this).</li>
                </ol>
              </div>
            </div>
            <div title="3.2.1. You can’t go back!">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e2951"></a>3.3.1. 不可回退!</h3>
                  </div>
                </div>
              </div>
              <p>To move to 0.92.0, all you need to do is shutdown your cluster, replace your hbase 0.90.x with hbase 0.92.0 binaries (be sure you clear out all 0.90.x instances) and restart (You cannot do a rolling restart from 0.90.x to 0.92.x -- you must restart). On startup, the .META. table content is rewritten removing the table schema from the info:regioninfo column. Also, any flushes done post first startup will write out data in the new 0.92.0 file format, <a href="#hfilev2" target="_top">HFile V2</a>. This means you cannot go back to 0.90.x once you’ve started HBase 0.92.0 over your HBase data directory.</p>
            </div>
            <div title="3.2.2. MSLAB is ON by default">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e2965"></a>3.3.2. MSLAB 缺省启用</h3>
                  </div>
                </div>
              </div>
              <p>In 0.92.0, the <a href="#hbase.hregion.memstore.mslab.enabled" target="_top">hbase.hregion.memstore.mslab.enabled</a> flag is set to true (参考 <a href="#mslab">Section 11.3.1.1, “Long GC pauses”</a>). In 0.90.x it was false. When it is enabled, memstores will step allocate memory in MSLAB 2MB chunks even if the memstore has zero or just a few small elements. This is fine usually but if you had lots of regions per regionserver in a 0.90.x cluster (and MSLAB was off), you may find yourself OOME'ing on upgrade because the thousands of regions * number of column families * 2MB MSLAB (at a minimum) puts your heap over the top. Set hbase.hregion.memstore.mslab.enabled to false or set the MSLAB size down from 2MB by setting hbase.hregion.memstore.mslab.chunksize to something less.</p>
            </div>
            <div title="3.2.3. Distributed splitting is on by default">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e2990"></a>3.3.3. 分布式分割缺省启用</h3>
                  </div>
                </div>
              </div>
              <p>Previous, WAL logs on crash were split by the Master alone. In 0.92.0, log splitting is done by the cluster (参考 “HBASE-1364 [performance] Distributed splitting of regionserver commit logs”). This should cut down significantly on the amount of time it takes splitting logs and getting regions back online again.</p>
            </div>
            <div title="3.2.4. Memory accounting is different now">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e2995"></a>3.3.4. 内存计算改变</h3>
                  </div>
                </div>
              </div>
              <p>In 0.92.0, <a href="#hfilev2" title="Appendix E. HFile format version 2">Appendix E, <em>HFile format version 2</em></a> indices and bloom filters take up residence in the same LRU used caching blocks that come from the filesystem. In 0.90.x, the HFile v1 indices lived outside of the LRU so they took up space even if the index was on a ‘cold’ file, one that wasn’t being actively used. With the indices now in the LRU, you may find you have less space for block caching. Adjust your block cache accordingly. 参考 the <a href="#block.cache" title="9.6.4. Block Cache">Section 9.6.4, “Block Cache”</a> for more detail. The block size default size has been changed in 0.92.0 from 0.2 (20 percent of heap) to 0.25.</p>
            </div>
            <div title="3.2.5. On the Hadoop version to use">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3004"></a>3.3.5.  可用 Hadoop 版本</h3>
                  </div>
                </div>
              </div>
              <p>Run 0.92.0 on Hadoop 1.0.x (or CDH3u3 when it ships). The performance benefits are worth making the move. Otherwise, our Hadoop prescription is as it has been; you need an Hadoop that supports a working sync. 参考 <a href="#hadoop" title="2.3. Hadoop">Section 2.3, “Hadoop”</a>.</p>
              <p>If running on Hadoop 1.0.x (or CDH3u3), enable local read. 参考 <a href="http://files.meetup.com/1350427/hug_ebay_jdcryans.pdf" target="_top">Practical Caching</a> presentation for ruminations on the performance benefits ‘going local’ (and for how to enable local reads).</p>
            </div>
            <div title="3.2.6. HBase 0.92.0 ships with ZooKeeper 3.4.2">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3016"></a>3.3.6. HBase 0.92.0 带 ZooKeeper 3.4.2</h3>
                  </div>
                </div>
              </div>
              <p>If you can, upgrade your zookeeper. If you can’t, 3.4.2 clients should work against 3.3.X ensembles (HBase makes use of 3.4.2 API).</p>
            </div>
            <div title="3.2.7. Online alter is off by default">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3021"></a>3.3.7. 在线切换缺省关闭</h3>
                  </div>
                </div>
              </div>
              <p>In 0.92.0, we’ve added an experimental online schema alter facility (参考 <a href="#hbase.online.schema.update.enable" title="hbase.online.schema.update.enable">hbase.online.schema.update.enable</a>). Its off by default. Enable it at your own risk. Online alter and splitting tables do not play well together so be sure your cluster quiescent using this feature (for now).</p>
            </div>
            <div title="3.2.8. WebUI">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3028"></a>3.3.8. WebUI</h3>
                  </div>
                </div>
              </div>
              <p>The webui has had a few additions made in 0.92.0. It now shows a list of the regions currently transitioning, recent compactions/flushes, and a process list of running processes (usually empty if all is well and requests are being handled promptly). Other additions including requests by region, a debugging servlet dump, etc.</p>
            </div>
            <div title="3.2.9. Security tarball">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3033"></a>3.3.9. 安全 tarball</h3>
                  </div>
                </div>
              </div>
              <p>我们发布两个tarball： 安全和非安全 HBase. 如何设置安全HBase的文档正在制定中。</p>
            </div>
            <div title="3.2.10. Experimental off-heap cache">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3038"></a>3.3.10. 试验离堆(off-heap)缓存</h3>
                  </div>
                </div>
              </div>
              <p>(译者注：on-heap和off-heap是Terracotta 公司提出的概念。on-heap指java对象在GC内存储管理，效率较高，但GC只能管理2G内存，有时成为性能瓶颈。off-heap又叫<a href="http://www.terracotta.org/bigmemory?src=ehcache_off_heap_store">BigMemory</a> ，是JVM的GC机制的替代，在GC外存储，100倍速于DiskStore，cache量目前(2012年底)达到350GB)</p>
              <p>A new cache was contributed to 0.92.0 to act as a solution between using the “on-heap” cache which is the current LRU cache the region servers have and the operating system cache which is out of our control. To enable, set “-XX:MaxDirectMemorySize” in hbase-env.sh to the value for maximum direct memory size and specify hbase.offheapcache.percentage in hbase-site.xml with the percentage that you want to dedicate to off-heap cache. This should only be set for servers and not for clients. Use at your own risk. See this blog post for additional information on this new experimental feature: http://www.cloudera.com/blog/2012/01/caching-in-hbase-slabcache/</p>
            </div>
            <div title="3.2.11. Changes in HBase replication">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3043"></a>3.3.11. HBase 复制的变动</h3>
                  </div>
                </div>
              </div>
              <p>0.92.0 adds two new features: multi-slave and multi-master replication. The way to enable this is the same as adding a new peer, so in order to have multi-master you would just run add_peer for each cluster that acts as a master to the other slave clusters. Collisions are handled at the timestamp level which may or may not be what you want, this needs to be evaluated on a per use case basis. Replication is still experimental in 0.92 and is disabled by default, run it at your own risk.</p>
            </div>
            <div title="3.2.12. RegionServer now aborts if OOME">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3048"></a>3.3.12. 对OOME ，RegionServer 现在退出 </h3>
                  </div>
                </div>
              </div>
              <p>If an OOME, we now have the JVM kill -9 the regionserver process so it goes down fast. Previous, a RegionServer might stick around after incurring an OOME limping along in some wounded state. To disable this facility, and recommend you leave it in place, you’d need to edit the bin/hbase file. Look for the addition of the -XX:OnOutOfMemoryError="kill -9 %p" arguments (参考 [HBASE-4769] - ‘Abort RegionServer Immediately on OOME’)</p>
            </div>
            <div title="3.2.13. HFile V2 and the “Bigger, Fewer” Tendency">
              <div>
                <div>
                  <div>
                    <h3><a name="d1934e3053"></a>3.3.13. HFile V2 和 “更大, 更少” 趋势</h3>
                  </div>
                </div>
              </div>
              <p>0.92.0 stores data in a new format, <a href="#hfilev2" title="Appendix E. HFile format version 2">Appendix E, <em>HFile format version 2</em></a>. As HBase runs, it will move all your data from HFile v1 to HFile v2 format. This auto-migration will run in the background as flushes and compactions run. HFile V2 allows HBase run with larger regions/files. In fact, we encourage that all HBasers going forward tend toward Facebook axiom #1, run with larger, fewer regions. If you have lots of regions now -- more than 100s per host -- you should look into setting your region size up after you move to 0.92.0 (In 0.92.0, default size is not 1G, up from 256M), and then running online merge tool (参考 “HBASE-1621 merge tool should work on online cluster, but disabled table”).</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <p>&nbsp;</p>
  <div class="section" title="2.1. 从HBase 0.20.x or 0.89.x 升级到 HBase 0.90.x"><div class="titlepage"><div><div>
      <h2 class="title" style="clear: both"><a name="upgrade0.90"></a>3.4.&nbsp;从HBase 0.20.x or 0.89.x 升级到 HBase 0.90.x </h2></div></div></div><p>0.90.x 版本的HBase可以在
              HBase 0.20.x 或者 HBase 0.89.x的数据上启动. 不需要转换数据文件， 
              HBase 0.89.x 和 0.90.x 的region目录名是不一样的 -- 老版本用md5 hash 而不是jenkins hash 来命名region-- 这就意味着，一旦启动，再也不能回退到 HBase 0.20.x.
          </p>
    <p>
             在升级的时候，一定要将<code class="filename">hbase-default.xml</code> 从你的
              <code class="filename">conf</code>目录删掉。
             0.20.x 版本的配置对于 0.90.x HBase不是最佳的. 
             <code class="filename">hbase-default.xml</code> 现在已经被打包在
             HBase jar 里面了.  如果你想看看这个文件内容，你可以在src目录下
             <code class="filename">src/main/resources/hbase-default.xml</code> 或者在
              <a class="xref" href="#hbase_default_configurations" title="3.1.1. HBase 默认配置">Section&nbsp;2.31.1, “HBase 默认配置”</a>看到.
          </p>
    <p>
            最后，如果从0.20.x升级，需要在shell里检查
            <code class="varname">.META.</code> schema .  过去，我们推荐用户使用16KB的
            <code class="varname">MEMSTORE_FLUSHSIZE</code>.
            在shell中运行 <code class="code">hbase&gt; scan '-ROOT-'</code>. 会显示当前的<code class="varname">.META.</code> schema.  检查
            <code class="varname">MEMSTORE_FLUSHSIZE</code> 的大小. 看看是不是 16KB (16384)? 如果是的话，你需要修改它(默认的值是 64MB (67108864)) 
            运行脚本 <code class="filename">bin/set_meta_memstore_size.rb</code>.
            这个脚本会修改 <code class="varname">.META.</code> schema.
            如果不运行的话，集群会比较慢<sup>[<a name="d613e1033" href="#ftn.d613e1033" class="footnote">15</a>]</sup>
            .

          </p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
            <p>&nbsp;</p></div></div></div><div class="chapter" title="Chapter 3. 配置"><div class="titlepage"><div><div>
              <div title="3.2. Upgrading from 0.90.x to 0.92.x">
                <div title="3.2.13. HFile V2 and the “Bigger, Fewer” Tendency"> </div>
              </div>
              [<a id="ftn.d1952e2919" href="#d1952e2919">15</a>] 参考 <a href="https://issues.apache.org/jira/browse/HBASE-3499" target="_top">HBASE-3499 Users upgrading to 0.90.0 need to have their .META. table updated with the right MEMSTORE_SIZE</a><br>
            </div></div></div><div class="footnotes"></div></div><div class="chapter" title="Chapter 4. The HBase Shell"><div class="titlepage"><div><div><h2 class="title"><a name="shell"></a>Chapter&nbsp;4.&nbsp; HBase Shell</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#scripting">4.1. 使用脚本</a></span></dt><dt><span class="section"><a href="#shell_tricks">4.2. Shell 技巧</a></span></dt><dd><dl><dt><span class="section"><a href="#d613e2127">4.2.1. <code class="filename">irbrc</code></a></span></dt><dt><span class="section"><a href="#d613e2145">4.2.2. LOG 时间转换</a></span></dt>
            <dt><span class="section"><a href="#d613e2163">4.2.3. 调试</a></span></dt></dl></dd></dl></div><p>
        HBase Shell is 在<a class="link" href="http://jruby.org/" target="_top">(J)Ruby</a>的IRB的基础上加上了HBase的命令。任何你可以在IRB里做的事情都可在在HBase Shell中做。
      </p><p>你可以这样来运行HBase Shell:
        </p><pre class="programlisting">$ ./bin/hbase shell</pre><p>
        </p><p>输入 <span class="command"><strong>help</strong></span> 就会返回Shell的命令列表和选项。可以看看在Help文档尾部的关于如何输入变量和选项。尤其要注意的是表名，行，列名必须要加引号。</p><p>参见 <a class="xref" href="#shell_exercises" title="1.2.3. Shell 练习">Section&nbsp;1.2.3, “Shell 练习”</a>可以看到Shell的基本使用例子。
            </p><div class="section" title="4.1. 使用脚本"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scripting"></a>4.1.&nbsp;使用脚本</h2></div></div></div><p>如果要使用脚本，可以看HBase的<code class="filename">bin</code> 目录.在里面找到后缀为 <code class="filename">*.rb</code>的脚本.要想运行这个脚本，要这样
            </p><pre class="programlisting">$ ./bin/hbase org.jruby.Main PATH_TO_SCRIPT</pre><p>就可以了
        </p></div><div class="section" title="4.2. Shell 技巧"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shell_tricks"></a>4.2.&nbsp;Shell 技巧</h2></div></div></div><div class="section" title="4.2.1. irbrc"><div class="titlepage"><div><div><h3 class="title"><a name="d613e2127"></a>4.2.1.&nbsp;<code class="filename">irbrc</code></h3></div></div></div><p>可以在你自己的Home目录下创建一个<code class="filename">.irbrc</code>文件. 在这个文件里加入自定义的命令。有一个有用的命令就是记录命令历史，这样你就可以把你的命令保存起来。
                    </p><pre class="programlisting">                        $ more .irbrc
                        require 'irb/ext/save-history'
                        IRB.conf[:SAVE_HISTORY] = 100
                        IRB.conf[:HISTORY_FILE] = "#{ENV['HOME']}/.irb-save-history"</pre><p>
                可以参见 <span class="application">ruby</span> 关于
                <code class="filename">.irbrc</code> 的文档来学习更多的关于IRB的配置方法。
                </p></div><div class="section" title="4.2.2. LOG 时间转换"><div class="titlepage"><div><div><h3 class="title"><a name="d613e2145"></a>4.2.2.&nbsp;LOG 时间转换</h3></div></div></div><p>
                可以将日期'08/08/16 20:56:29'从hbase log 转换成一个 timestamp, 操作如下:
                </p><pre class="programlisting">                    hbase(main):021:0&gt; import java.text.SimpleDateFormat
                    hbase(main):022:0&gt; import java.text.ParsePosition
                    hbase(main):023:0&gt; SimpleDateFormat.new("yy/MM/dd HH:mm:ss").parse("08/08/16 20:56:29", ParsePosition.new(0)).getTime() =&gt; 1218920189000</pre><p>
            </p><p>
                也可以逆过来操作。
                </p><pre class="programlisting">                    hbase(main):021:0&gt; import java.util.Date
                    hbase(main):022:0&gt; Date.new(1218920189000).toString() =&gt; "Sat Aug 16 20:56:29 UTC 2008"</pre><p>
            </p><p>
			    要想把日期格式和HBase log格式完全相同，可以参见文档
                <a class="link" href="http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html" target="_top">SimpleDateFormat</a>.
            </p></div><div class="section" title="4.2.3. Debug"><div class="titlepage"><div><div>
              <h3 class="title"><a name="d613e2163"></a>4.2.3.&nbsp;调试</h3></div></div></div><div class="section" title="4.2.3.1. Shell 切换成debug 模式"><div class="titlepage"><div><div><h4 class="title"><a name="d613e2166"></a>4.2.3.1.&nbsp;Shell 切换成debug 模式</h4></div></div></div><p>你可以将shell切换成debug模式。这样可以看到更多的信息。
                    -- 例如可以看到命令异常的stack trace:
                    </p><pre class="programlisting">hbase&gt; debug &lt;RETURN&gt;</pre><p>
                 </p></div><div class="section" title="4.2.3.2. DEBUG log level"><div class="titlepage"><div><div><h4 class="title"><a name="d613e2174"></a>4.2.3.2.&nbsp;DEBUG log level</h4></div></div></div><p>想要在shell中看到 DEBUG 级别的 logging ，可以在启动的时候加上  <span class="command"><strong>-d</strong></span> 参数.
                    </p><pre class="programlisting">$ ./bin/hbase shell -d</pre>
                    <div class="titlepage">
                      <div>
                        <div>
                          <h2 class="title"><a name="datamodel"></a>Chapter&nbsp;5.&nbsp;数据模型</h2>
                        </div>
                      </div>
                    </div>
                    <div class="toc">
                      <p><b>Table of Contents</b></p>
                      <dl>
                        <dt><a href="#conceptual.view">5.1. 概念视图</a></dt>
                        <dt><a href="#physical.view">5.2. 物理视图</a></dt>
                        <dt><a href="#table">5.3. 表</a></dt>
                        <dt><a href="#row">5.4. 行</a></dt>
                        <dt><a href="#columnfamily">5.5. 列族</a>
                        </dt><dt><a href="#cells">5.6. Cells</a></dt>
                        <dt><a href="#versions">5.7. 版本</a></dt>
                        <dd>
                          <dl>
                            <dt><a href="#versions.ops">5.7.1. HBase的操作(包含版本操作)</a></dt>
                            <dt><a href="#d613e2965">5.7.2. 现有的限制</a></dt>
                          </dl>
                        </dd>
                      </dl>
                    </div>
                    <p>简单来说，应用程序是以表的方式在HBase存储数据的。表是由行和列构成的，所有的列是从属于某一个列族的。行和列的交叉点称之为cell,cell是版本化的。cell的内容是不可分割的字节数组。 </p>
                    <p>表的行键也是一段字节数组，所以任何东西都可以保存进去，不论是字符串或者数字。HBase的表是按key排序的，排序方式之针对字节的。所有的表都必须要有主键-key. </p>
                    <div class="section" title="11.1. 概念视图">
                      <div class="titlepage">
                        <div>
                          <div>
                            <h2 class="title" style="clear: both"><a name="conceptual.view"></a>5.1.&nbsp;概念视图</h2>
                          </div>
                        </div>
                      </div>
                      <p> 下面是根据<a class="link" href="http://labs.google.com/papers/bigtable.html" target="_top">BigTable</a> 论文稍加修改的例子。
                        有一个名为<code class="varname">webtable</code>的表，包含两个列族<code class="varname">：contents</code>和<code class="varname">anchor</code>.在这个例子里面，<code class="varname">anchor</code>有两个列 (<code class="varname">anchor:cssnsi.com</code>, <code class="varname">anchor:my.look.ca</code>)，<code class="varname">contents</code>仅有一列(<code class="varname">contents:html</code>) </p>
                      <div class="note" title="列名" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <h3 class="title">列名</h3>
                        <p> 一个列名是由它的列族前缀和<span class="emphasis"><em>修饰符(qualifier)</em></span>连接而成。例如列<span class="emphasis"><em>contents:html</em></span>是列族 <code class="varname">contents</code>加冒号(<code class="literal">:</code>)加 <span class="emphasis"><em>修饰符</em></span> <code class="varname">html</code>组成的。 </p>
                      </div>
                      <p></p>
                      <div class="table"><a name="d1934e3221" id="d1934e3221"></a>
                        <p class="title"><b>Table&nbsp;5.1.&nbsp;表 <code class="varname">webtable</code></b></p>
                        <div class="table-contents">
                          <table summary="表 webtable" border="1">
                            <colgroup>
                              <col align="left">
                              <col align="left">
                              <col align="left">
                              <col align="left">
                            </colgroup>
                            <thead>
                              <tr>
                                <th align="left">Row Key</th>
                                <th align="left">Time Stamp</th>
                                <th align="left">ColumnFamily <code class="varname">contents</code></th>
                                <th align="left">ColumnFamily <code class="varname">anchor</code></th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t9</td>
                                <td align="left">&nbsp;</td>
                                <td align="left"><code class="varname">anchor:cnnsi.com</code> = "CNN"</td>
                              </tr>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t8</td>
                                <td align="left">&nbsp;</td>
                                <td align="left"><code class="varname">anchor:my.look.ca</code> = "CNN.com"</td>
                              </tr>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t6</td>
                                <td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td>
                                <td align="left">&nbsp;</td>
                              </tr>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t5</td>
                                <td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td>
                                <td align="left">&nbsp;</td>
                              </tr>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t3</td>
                                <td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td>
                                <td align="left">&nbsp;</td>
                              </tr>
                            </tbody>
                          </table>
                        </div>
                      </div>
                      <p><br class="table-break">
                      </p>
                    </div>
                   <div class="section" title="11.2. 物理视图">
                      <div class="titlepage">
                        <div>
                          <div>
                            <h2 class="title" style="clear: both"><a name="physical.view"></a>5.2.&nbsp;物理视图</h2>
                          </div>
                        </div>
                      </div>
                      <p> 尽管在概念视图里，表可以被看成是一个稀疏的行的集合。但在物理上，它的是区分列族 存储的。新的columns可以不经过声明直接加入一个列族. </p>
                      <div class="table"><a name="d1934e3305" id="d1934e3305"></a>
                        <p class="title"><b>Table&nbsp;5.2.&nbsp;ColumnFamily <code class="varname">anchor</code></b></p>
                        <div class="table-contents">
                          <table summary="ColumnFamily anchor" border="1">
                            <colgroup>
                              <col align="left">
                              <col align="left">
                              <col align="left">
                            </colgroup>
                            <thead>
                              <tr>
                                <th align="left">Row Key</th>
                                <th align="left">Time Stamp</th>
                                <th align="left">Column Family <code class="varname">anchor</code></th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t9</td>
                                <td align="left"><code class="varname">anchor:cnnsi.com</code> = "CNN"</td>
                              </tr>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t8</td>
                                <td align="left"><code class="varname">anchor:my.look.ca</code> = "CNN.com"</td>
                              </tr>
                            </tbody>
                          </table>
                        </div>
                      </div>
                      <p><br class="table-break">
                      </p>
                     <div class="table"><a name="d1934e3344" id="d1934e3344"></a>
                       <p class="title"><b>Table&nbsp;5.3.&nbsp;ColumnFamily <code class="varname">contents</code></b></p>
                        <div class="table-contents">
                          <table summary="ColumnFamily contents" border="1">
                            <colgroup>
                              <col align="left">
                              <col align="left">
                              <col align="left">
                            </colgroup>
                            <thead>
                              <tr>
                                <th align="left">Row Key</th>
                                <th align="left">Time Stamp</th>
                                <th align="left">ColumnFamily "contents:"</th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t6</td>
                                <td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td>
                              </tr>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t5</td>
                                <td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td>
                              </tr>
                              <tr>
                                <td align="left">"com.cnn.www"</td>
                                <td align="left">t3</td>
                                <td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td>
                              </tr>
                            </tbody>
                          </table>
                        </div>
                     </div>
                     <p><br class="table-break">
                       值得注意的是在上面的概念视图中空白cell在物理上是不存储的，因为根本没有必要存储。因此若一个请求为要获取<code class="literal">t8</code>时间的<code class="varname">contents:html</code>，他的结果就是空。相似的，若请求为获取<code class="literal">t9</code>时间的<code class="varname">anchor:my.look.ca</code>，结果也是空。但是，如果不指明时间，将会返回最新时间的行，每个最新的都会返回。例如，如果请求为获取行键为"com.cnn.www"，没有指明时间戳的话，活动的结果是<code class="literal">t6</code>下的contents:html，<code class="literal">t9</code>下的<code class="varname">anchor:cnnsi.com</code>和<code class="literal">t8</code>下<code class="varname">anchor:my.look.ca</code>。 </p>
                      <p> For more information about the internals of how HBase stores data, see <a href="#regions.arch" title="9.7. Regions">Section 9.7, “Regions”</a>. </p>
                    </div>
                    <div class="section" title="11.3. 表">
                      <div class="titlepage">
                        <div>
                          <div>
                            <h2 class="title" style="clear: both"><a name="table"></a>5.3.&nbsp;表</h2>
                          </div>
                        </div>
                      </div>
                      <p> 表是在schema声明的时候定义的。 </p>
                    </div>
                    <div class="section" title="11.4. 行">
                      <div class="titlepage">
                        <div>
                          <div>
                            <h2 class="title" style="clear: both"><a name="row"></a>5.4.&nbsp;行</h2>
                          </div>
                        </div>
                      </div>
                      <p>行键是不可分割的字节数组。行是按字典排序由低到高存储在表中的。一个空的数组是用来标识表空间的起始或者结尾。</p>
                    </div>
                    <div class="section" title="11.5. Column Family">
                      <div class="titlepage">
                        <div>
                          <div>
                            <h2 class="title" style="clear: both"><a name="columnfamily"></a>5.5.&nbsp;列族
                          </h2></div>
                        </div>
                      </div>
                      <p> 在HBase是<span class="emphasis"><em>列族</em></span>一些列的集合。一个列族所有列成员是有着相同的前缀。比如，列<span class="emphasis"><em>courses:history</em></span> 和 <span class="emphasis"><em>courses:math</em></span>都是 列族 <span class="emphasis"><em>courses</em></span>的成员.冒号(:)是列族的分隔符，用来区分前缀和列名。column 前缀必须是可打印的字符，剩下的部分(称为qualify),可以又任意字节数组组成。列族必须在表建立的时候声明。column就不需要了，随时可以新建。 </p>
                      <p>在物理上，一个的列族成员在文件系统上都是存储在一起。因为存储优化都是针对列族级别的，这就意味着，一个colimn family的所有成员的是用相同的方式访问的。</p>
                      <p></p>
                    </div>
                    <div class="section" title="11.6. Cells">
                      <div class="titlepage">
                        <div>
                          <div>
                            <h2 class="title" style="clear: both"><a name="cells"></a>5.6.&nbsp;Cells<a class="indexterm" name="d613e2790"></a></h2>
                          </div>
                        </div>
                      </div>
                      <p>A <span class="emphasis"><em>{row, column, version} </em></span>元组就是一个HBase中的一个 <code class="literal">cell</code>。Cell的内容是不可分割的字节数组。</p>
                    </div>
                    <div class="section" title="11.7. 版本">
                      <div class="titlepage">
                        <div>
                          <div></div>
                        </div>
                      </div>
                      <div class="section" title="5.7.&nbsp;Data Model Operations"><div class="titlepage"><div><div>
                        <h2 class="title" style="clear: both"><a name="data_model_operations"></a>5.7.&nbsp;数据模型操作</h2></div></div></div>
                      <p>四个主要的数据模型操作是 Get, Put, Scan, 和 Delete.  通过 
                        <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a> 实例进行操作.
                        </p><div class="section" title="5.7.1.&nbsp;Get"><div class="titlepage"><div><div><h3 class="title"><a name="get"></a>5.7.1.&nbsp;Get</h3></div></div></div>
                        <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a> 返回特定行的属性。  Gets 通过 
                          <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#get%28org.apache.hadoop.hbase.client.Get%29" target="_top">
                          HTable.get</a> 执行。</p></div><div class="section" title="5.7.2.&nbsp;Put"><div class="titlepage"><div><div><h3 class="title"><a name="put"></a>5.7.2.&nbsp;Put</h3></div></div></div>
                          <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Put.html" target="_top">Put</a> 要么向表增加新行 (如果key是新的) 或更新行 (如果key已经存在)。  Puts 通过
                            <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#put%28org.apache.hadoop.hbase.client.Put%29" target="_top">
                              HTable.put</a> (writeBuffer) 或 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29" target="_top">
                                HTable.batch</a> (non-writeBuffer)执行。</p></div><div class="section" title="5.7.3.&nbsp;Scans"><div class="titlepage"><div><div><h3 class="title"><a name="scan"></a>5.7.3.&nbsp;Scans</h3></div></div></div>
                                <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a> 允许多行特定属性迭代。</p>
                                <p>下面是一个在 HTable 表实例上的示例。  假设表有几行键值为 "row1", "row2", "row3", 
                                还有一些行有键值 "abc1", "abc2", 和 "abc3".  下面的示例展示startRow 和 stopRow 
                                可以应用到一个Scan 实例，以返回"row"打头的行。        
  </p><pre class="programlisting">HTable htable = ...      // instantiate HTable
    
Scan scan = new Scan();
scan.addColumn(Bytes.toBytes("cf"),Bytes.toBytes("attr"));
scan.setStartRow( Bytes.toBytes("row"));                   // start key is inclusive
scan.setStopRow( Bytes.toBytes("row" +  (char)0));  // stop key is exclusive
ResultScanner rs = htable.getScanner(scan);
try {
  for (Result r = rs.next(); r != null; r = rs.next()) {
  // process result...
} finally {
  rs.close();  // always close the ResultScanner!
}
</pre><p>
  </p></div><div class="section" title="5.7.4.&nbsp;Delete"><div class="titlepage"><div><div><h3 class="title"><a name="delete"></a>5.7.4.&nbsp;Delete</h3></div></div></div>
  <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Delete.html" target="_top">Delete</a> 从表中删除一行.  删除通过<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29" target="_top">HTable.delete</a> 执行。
    </p>
  <p>HBase 没有修改数据的合适方法。所以通过创建名为墓碑(<span class="emphasis"><em>tombstones</em></span>)的新标志进行处理。这些墓碑和死去的值，在主紧缩时清除。       </p>
  <p>参考 <a class="xref" href="#version.delete" title="5.8.1.5.&nbsp;Delete">Section&nbsp;5.8.1.5, “Delete”</a> 获取删除列版本的更多信息。参考<a class="xref" href="#compaction" title="9.7.5.5.&nbsp;Compaction">Section&nbsp;9.7.5.5, “Compaction”</a> 获取更多有关紧缩的信息。         
      </p></div></div>
        
                      <div class="section" title="11.7.1. HBase的操作(包含版本操作)">
                        <div class="titlepage">
                          <div>
                            <div>
                              <div class="titlepage">
                                <div>
                                  <div>
                                    <h2 class="title" style="clear: both"><a name="versions"></a>5.8.&nbsp;版本<a class="indexterm" name="d613e2804"></a></h2>
                                  </div>
                                </div>
                              </div>
                              <p>一个 <span class="emphasis"><em>{row, column, version} </em></span>元组是HBase中的一个单元(<code class="literal">cell</code>).但是有可能会有很多的单元的行和列是相同的，可以使用版本来区分不同的单元.</p>
                              <p>rows和column key是用字节数组表示的，version则是用一个长整型表示。这个long的值使用 <code class="code">java.util.Date.getTime()</code> 或者 <code class="code">System.currentTimeMillis()</code>产生的。这就意味着他的含义是<span class="quote">“当前时间和1970-01-01 UTC的时间差，单位毫秒。”</span></p>
                              <p>在HBase中，版本是按倒序排列的，因此当读取这个文件的时候，最先找到的是最近的版本。</p>
                              <p>有些人不是很理解HBase单元(<code class="literal">cell</code>)的意思。一个常见的问题是:</p>
                              <div class="itemizedlist">
                                <ul class="itemizedlist" type="disc">
                                  <li class="listitem">
                                    <p>如果有多个包含版本写操作同时发起，HBase会保存全部还是会保持最新的一个？<sup>[<a name="d613e2836" href="#ftn.d613e2836" class="footnote">16</a>]</sup></p>
                                  </li>
                                  <li class="listitem">
                                    <p>可以发起包含版本的写操作，但是他们的版本顺序和操作顺序相反吗?<sup>[<a name="d613e2842" href="#ftn.d613e2842" class="footnote">17</a>]</sup></p>
                                  </li>
                                </ul>
                              </div>
                              <p>下面我们介绍下在HBase中版本是如何工作的。<sup>[<a name="d613e2847" href="#ftn.d613e2847" class="footnote">18</a>]</sup>.</p>
                              <h3 class="title"><a name="versions.ops"></a>5.8.1.&nbsp;HBase的操作(包含版本操作)</h3>
                            </div>
                          </div>
                        </div>
                        <p>在这一章我们来仔细看看在HBase的各个主要操作中版本起到了什么作用。</p>
                        <div class="section" title="11.7.1.1. Get/Scan">
                          <div class="titlepage">
                            <div>
                              <div>
                                <h4 class="title"><a name="d613e2865"></a>5.8.1.1.&nbsp;Get/Scan</h4>
                              </div>
                            </div>
                          </div>
                          <p>Gets实在Scan的基础上实现的。可以详细参见下面的讨论 <a class="link" href="http://hbase.apache.org/docs/current/api/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a> 同样可以用 <a class="link" href="http://hbase.apache.org/docs/current/api/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a>来描述.</p>
                          <p>默认情况下，如果你没有指定版本，当你使用<code class="literal">Get</code>操作的时候，会返回最近版本的Cell(该Cell可能是最新写入的，但不能保证)。默认的操作可以这样修改:</p>
                          <div class="itemizedlist">
                            <ul class="itemizedlist" type="disc">
                              <li class="listitem">
                                <p>如果想要返回返回两个以上的把版本,参见<a class="link" href="http://hbase.apache.org/docs/current/api/org/apache/hadoop/hbase/client/Get.html#setMaxVersions()" target="_top">Get.setMaxVersions()</a></p>
                              </li>
                              <li class="listitem">
                                <p>如果想要返回的版本不只是最近的，参见 <a class="link" href="???" target="_top">Get.setTimeRange()</a></p>
                                <p>要向查询的最新版本要小于或等于给定的这个值，这就意味着给定的'最近'的值可以是某一个时间点。可以使用0到你想要的时间来设置，还要把max versions设置为1.</p>
                              </li>
                            </ul>
                          </div>
                        </div>
                        <div class="section" title="11.7.1.2. 默认 Get 例子">
                          <div class="titlepage">
                            <div>
                              <div>
                                <h4 class="title"><a name="default_get_example"></a>5.8.1.2.&nbsp;默认 Get 例子</h4>
                              </div>
                            </div>
                          </div>
                          <p>下面的Get操作会只获得最新的一个版本。 </p>
                          <pre class="programlisting">        Get get = new Get(Bytes.toBytes("row1"));
        Result r = htable.get(get);
        byte[] b = r.getValue(Bytes.toBytes("cf"), Bytes.toBytes("attr"));  // returns current version of value          </pre>
                          <p></p>
                        </div>
                        <div class="section" title="11.7.1.3. 含有的版本的Get例子">
                          <div class="titlepage">
                            <div>
                              <div>
                                <h4 class="title"><a name="versioned_get_example"></a>5.8.1.3.&nbsp;含有的版本的Get例子</h4>
                              </div>
                            </div>
                          </div>
                          <p>下面的Get操作会获得最近的3个版本。 </p>
                          <pre class="programlisting">        Get get = new Get(Bytes.toBytes("row1"));
        get.setMaxVersions(3);  // will return last 3 versions of row
        Result r = htable.get(get);
        byte[] b = r.getValue(Bytes.toBytes("cf"), Bytes.toBytes("attr"));  // returns current version of value
        List&lt;KeyValue&gt; kv = r.getColumn(Bytes.toBytes("cf"), Bytes.toBytes("attr"));  // returns all versions of this column       
                    </pre>
                          <p></p>
                        </div>
                        <div class="section" title="11.7.1.4. Put">
                          <div class="titlepage">
                            <div>
                              <div>
                                <h4 class="title"><a name="put_operation"></a>5.8.1.4.&nbsp;Put</h4>
                              </div>
                            </div>
                          </div>
                          <p>一个Put操作会给一个<code class="literal">cell</code>,创建一个版本，默认使用当前时间戳，当然你也可以自己设置时间戳。这就意味着你可以把时间设置在过去或者未来，或者随意使用一个Long值。 </p>
                          <p>要想覆盖一个现有的值，就意味着你的row,column和版本必须完全相等。</p>
                          <div class="section" title="11.7.1.4.1. 不指明版本的例子">
                            <div class="titlepage">
                              <div>
                                <div>
                                  <h5 class="title"><a name="implicit_version_example"></a>5.8.1.4.1.&nbsp;不指明版本的例子</h5>
                                </div>
                              </div>
                            </div>
                            <p>下面的Put操作不指明版本，所以HBase会用当前时间作为版本。 </p>
                            <pre class="programlisting">          Put put = new Put(Bytes.toBytes(row));
          put.add(Bytes.toBytes("cf"), Bytes.toBytes("attr1"), Bytes.toBytes( data));
          htable.put(put);
                    </pre>
                            <p></p>
                          </div>
                          <div class="section" title="11.7.1.4.2. 指明版本的例子">
                            <div class="titlepage">
                              <div>
                                <div>
                                  <h5 class="title"><a name="explicit_version_example"></a>5.8.1.4.2.&nbsp;指明版本的例子</h5>
                                </div>
                              </div>
                            </div>
                            <p>下面的Put操作，指明了版本。 </p>
                            <pre class="programlisting">          Put put = new Put( Bytes.toBytes(row ));
          long explicitTimeInMs = 555;  // just an example
          put.add(Bytes.toBytes("cf"), Bytes.toBytes("attr1"), explicitTimeInMs, Bytes.toBytes(data));
          htable.put(put);
                    </pre>
                            <p></p>
                          </div>
                        </div>
                        <div class="section" title="11.7.1.5. Delete">
                          <div class="titlepage">
                            <div>
                              <div>
                                <h4 class="title"><a name="d613e2936"></a>5.8.1.5.&nbsp;Delete</h4>
                              </div>
                            </div>
                          </div>
                          <p>有三种不同类型的内部删除标记   [<a name="d1952e3698" href="#ftn.d1952e3698">19</a>]: </p>
                          <div class="itemizedlist">
                            <ul class="itemizedlist" type="disc">
                              <li>
                                <p>Delete: 删除列的指定版本.</p>
                              </li>
                              <li>
                                <p>Delete column: 删除列的所有版本.</p>
                              </li>
                              <li>
                                <p>Delete family: 删除特定列族所有列</p>
                              </li>
                            </ul>
</div>
                          <p>当删除一行，HBase将内部对每个列族创建墓碑(非每个单独列)。</p>
                          <p>删除操作的实现是创建一个<span class="emphasis"><em>墓碑标记</em></span>。例如，我们想要删除一个版本，或者默认是<code class="literal">currentTimeMillis</code>。就意味着<span class="quote">“删除比这个版本更早的所有版本”</span>.HBase不会去改那些数据，数据不会立即从文件中删除。他使用删除标记来屏蔽掉这些值。<sup>[<a name="d613e2961" href="#ftn.d613e2961" class="footnote">20</a>]</sup>若你知道的版本比数据中的版本晚，就意味着这一行中的所有数据都会被删除。</p>
                          <p> 参考 <a href="#keyvalue" title="9.7.5.4. KeyValue">Section 9.7.5.4, “KeyValue”</a> 获取内部 KeyValue 格式更多信息。 </p>
                        </div>
                      </div>
                      <div class="section" title="11.7.2. 现有的限制">
                        <div class="titlepage">
                          <div>
                            <div>
                              <h3 class="title"><a name="d613e2965"></a>5.8.2.&nbsp;现有的限制</h3>
                            </div>
                          </div>
                        </div>
                        <p>关于版本还有一些bug(或者称之为未实现的功能)，计划在下个版本实现。</p>
                        <div class="section" title="11.7.2.1. 删除标记误删Puts">
                          <div class="titlepage">
                            <div>
                              <div>
                                <h4 class="title"><a name="d613e2970"></a>5.8.2.1.&nbsp;删除标记误标新Put 的数据</h4>
                              </div>
                            </div>
                          </div>
                          <p>删除标记操作可能会标记其后put的数据。<sup>[<a name="d613e2975" href="#ftn.d613e2975" class="footnote">21</a>]</sup>记住，当写下一个墓碑标记后，只有下一个主紧缩操作发起之后，墓碑才会清除。假设你删除所有&lt;= 时间T的数据。但之后，你又执行了一个Put操作，时间戳&lt;= T。就算这个Put发生在删除操作之后，他的数据也打上了墓碑标记。这个Put并不会失败，但你做Get操作时，会注意到Put没有产生影响。只有一个主紧缩执行后，一切才会恢复正常。如果你的Put操作一直使用升序的版本，这个问题不会有影响。但是即使你不关心时间，也可能出现该情况。只需删除和插入迅速相互跟随，就有机会在同一毫秒中遇到。</p>
                        </div>
                        <div class="section" title="11.7.2.2. Major compactions 改变查询的结果">
                          <div class="titlepage">
                            <div>
                              <div>
                                <h4 class="title"><a name="d613e2980"></a>5.8.2.2.&nbsp;主紧缩改变查询的结果</h4>
                              </div>
                            </div>
                          </div>
                          <p><span class="quote">“设想一下，你一个cell有三个版本t1,t2和t3。你的maximun-version设置是2.当你请求获取全部版本的时候，只会返回两个，t2和t3。如果你将t2和t3删除，就会返回t1。但是如果在删除之前，发生了major compaction操作，那么什么值都不好返回了。<sup>[<a name="d613e2986" href="#ftn.d613e2986" class="footnote">22</a>]</sup>”</span></p>
                        </div>
                      </div>
                    </div>
                    <div class="footnotes"><br>
                      <div class="footnote"></div>
</div>
                    <div>
                      <div>
                        <div>
                          <h2><a name="dm.sort" id="dm.sort"></a>5.9. 排序</h2>
                        </div>
                      </div>
                    </div>
                   <p>所有数据模型操作 HBase 返回排序的数据。先是行，再是列族，然后是列修饰(column qualifier), 最后是时间戳(反向排序,所以最新的在前).</p>
                   <div>
                     <div>
                       <div>
                         <h2><a name="dm.column.metadata" id="dm.column.metadata"></a>5.10. 列的元数据</h2>
                       </div>
                     </div>
                   </div>
                   <p>对列族，没有内部的KeyValue之外的元数据保存。这样，HBase不仅在一行中支持很多列，而且支持行之间不同的列。 由你自己负责跟踪列名。</p>
                   <p>唯一获取列族的完整列名的方法是处理所有行。HBase内部保存数据更多信息，请参考 <a href="#keyvalue" title="9.7.5.4. KeyValue">Section 9.7.5.4, “KeyValue”</a>.</p>
                   <div title="5.11. Joins">
                     <div>
                       <div>
                         <div>
                           <h2><a name="joins"></a>5.11. 联合查询(Join)</h2>
                         </div>
                       </div>
                     </div>
                     <p> HBase是否支持联合是一个网上常问问题。简单来说 : 不支持。至少不想传统RDBMS那样支持(如 SQL中带 equi-joins 或 outer-joins). 正如本章描述的，读数据模型是 Get 和 Scan.</p>
                     <p>但并不表示等价联合不能在应用程序中支持，只是必须自己做。 两种方法，要么指示要写到HBase的数据，要么查询表并在应用或MapReduce代码中做联合(如 RDBMS所展示,有几种步骤来实现，依赖于表的大小。如 nested loops vs. hash-joins). 哪个更好？依赖于你准备做什么，所以没有一个单一的回答适合所有方面。</p>
                     <div>
                       <div>
                         <div>
                           <h2>5.12. ACID</h2>
                         </div>
                       </div>
                     </div>
                     参考 <a href="http://hbase.apache.org/acid-semantics.html" target="_top">ACID Semantics</a>. Lars Hofhansl 也在 <a href="http://hadoop-hbase.blogspot.com/2012/03/acid-in-hbase.html" target="_top">ACID in HBase</a>上写了说明.
                     <p>&nbsp;</p>
                   </div>
                   <br>
                   <div class="footnote">
                     <p><sup>[<a name="ftn.d613e2836" href="#d613e2836" class="para">16</a>] </sup>目前，只有最新的那个是可以获取到的。.</p>
                   </div>
                   <div class="footnote">
                     <p><sup>[<a name="ftn.d613e2842" href="#d613e2842" class="para">17</a>] </sup>可以</p>
                   </div>
                   <div class="footnote">
                     <p><sup>[<a name="ftn.d613e2847" href="#d613e2847" class="para">18</a>] </sup>参考 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2406" target="_top">HBASE-2406</a> for discussion of HBase versions. <a class="link" href="http://outerthought.org/blog/417-ot.html" target="_top">Bending time
                       in HBase</a> makes for a good read on the version, or time,
                       dimension in HBase. It has more detail on versioning than is
                       provided here. As of this writing, the limiitation <span class="emphasis"><em>Overwriting values at existing timestamps</em></span> mentioned in the article no longer holds in HBase. This section is
                       basically a synopsis of this article by Bruno Dumon.</p>
                   </div>
                   <div class="footnote">
                     <p><sup> [<a id="ftn.d1952e3698" href="#d1952e3698">19</a>] 参考 Lars Hofhansl's blog for discussion of his attempt adding another, <a href="http://hadoop-hbase.blogspot.com/2012/01/scanning-in-hbase.html" target="_top">Scanning in HBase: Prefix Delete Marker</a> </sup></p>
                     <p><sup>[<a name="ftn.d613e2961" href="#d613e2961" class="para">20</a>] </sup>当HBase执行一次major compaction,标记删除的数据会被实际的删除，删除标记也会被删除。</p>
                   </div>
                   <div class="footnote">
                     <p><sup>[<a name="ftn.d613e2975" href="#d613e2975" class="para">21</a>] </sup><a class="link" href="https://issues.apache.org/jira/browse/HBASE-2256" target="_top">HBASE-2256</a></p>
                   </div>
                   <div class="footnote">
                     <p><sup>[<a name="ftn.d613e2986" href="#d613e2986" class="para">22</a>] </sup>参考垃圾收集： <a class="link" href="http://outerthought.org/blog/417-ot.html" target="_top">Bending
                       time in HBase</a></p>
                   </div>
                   <p>&nbsp;</p>
                   <p>
            </p></div></div></div></div><div class="chapter" title="Chapter 5. 构建 HBase"><div class="titlepage"><div><div></div></div></div></div><div class="chapter" title="Chapter 6. Developers"><div class="titlepage"><div><div>
          <div class="section" title="8.1.  Schema 创建">
            <div class="titlepage">
              <div>
                <div>
                  <div class="titlepage">
                    <div>
                      <div>
                        <h2 class="title"><a name="schema"></a>Chapter&nbsp;6.&nbsp;HBase 的 Schema 设计</h2>
                      </div>
                    </div>
                  </div>
                  <div class="toc">
                    <p><b>Table of Contents</b></p>
                    <dl>
                      <dt><a href="#schema.creation">6.1. </a><a href="#schema.creation">Schema 创建<br>
                      </a><a href="#schema.creation"></a><a href="#number.of.cfs">6.2. </a><a href="#number.of.cfs">列族的数量</a></dt>
                      <dt><a href="#rowkey.design">6.3. Rowkey 设计</a></dt>
                      <dt><a href="#schema.versions">6.4. 版本数量</a></dt>
                      <dt><a href="#supported.datatypes">6.5. 支持的数据类型</a></dt>
                      <dt><a href="#schema.joins">6.6. 联合</a></dt>
                      <dt><a href="#ttl">6.7. 存活时间 (TTL)</a></dt>
                      <dt><a href="#cf.keep.deleted">6.8. 保存删除的单元</a></dt>
                      <dt><a href="#secondary.indexes">6.9. 第二索引和改变查询路径</a></dt>
                      <dt><a href="#schema.smackdown">6.10. 模式设计对决</a></dt>
                      <dt><a href="#schema.ops">6.11. 业务和性能配置选项</a></dt>
                      <dt><a href="#constraints">6.12. 常量</a></dt>
                    </dl>
</div>
                  <p>一份关于各种NSQL数据库的优点和缺点的通用介绍，就是 Ian Varley的博士论文， <a class="link" href="http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf" target="_top">No Relation: The Mixed Blessings of Non-Relational Databases</a>。
                    推荐。也可阅读 <a href="#keyvalue" title="9.7.5.4. KeyValue">Section 9.7.5.4, &ldquo;KeyValue&rdquo;</a> ，了解HBase如何内部保存数据。</p>
                  <h2 class="title" style="clear: both"><a name="schema.creation"></a>6.1.&nbsp;
                    模式(Schema) 创建 </h2>
                </div>
              </div>
            </div>
            <p>可以使用<a class="xref" href="#shell" title="Chapter 4. The HBase Shell">Chapter&nbsp;4, <i> HBase Shell</i></a> 或Java API的<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html" target="_top">HBaseAdmin</a>来创建和编辑HBase的模式。 </p>
            <p>表必须禁用以修改列族，如：</p>
            <pre class="programlisting">Configuration config = HBaseConfiguration.create();  
HBaseAdmin admin = new HBaseAdmin(conf);    
String table = "myTable";

admin.disableTable(table);           

HColumnDescriptor cf1 = ...;
admin.addColumn(table, cf1);      // adding new ColumnFamily
HColumnDescriptor cf2 = ...;
admin.modifyColumn(table, cf2);    // modifying existing ColumnFamily

admin.enableTable(table);                
      </pre>
            
            参考 <a href="#client_dependencies" title="2.6.4. Client configuration and dependencies connecting to an HBase cluster">Section 2.3.4, “Client configuration and dependencies connecting to an HBase cluster”</a> ，获取更多配置客户端连接的信息。
            <p>注意:  0.92.x 支持在线修改模式, 但 0.90.x 需要禁用表。</p>
            <div title="6.1.1. Schema Updates">
            <div>
              <div>
                <div>
                  <h3>6.1.1. 模式更新</h3>
                </div>
              </div>
            </div>
            <p>当表或列族改变时(如 region size, block size), 当下次存在主紧缩及存储文件重写时起作用。</p>
            <p>参考 <a href="#store" title="9.7.5. Store">Section 9.7.5, “Store”</a> 获取存储文件的更多信息。</p>
<div>
            <div>
            <div>
            <br>
          </div>
          <div class="section" title="8.2.  column families的数量">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title" style="clear: both"><a name="number.of.cfs"></a>6.2.&nbsp;
                    列族的数量 </h2>
                </div>
              </div>
            </div>
            <p> 现在HBase并不能很好的处理两个或者三个以上的列族，所以尽量让你的列族数量少一些。目前，flush和compaction操作是针对一个Region。所以当一个列族操作大量数据的时候会引发一个flush。那些不相关的列族也有进行flush操作，尽管他们没有操作多少数据。Compaction操作现在是根据一个列族下的全部文件的数量触发的，而不是根据文件大小触发的。当很多的列族在flush和compaction时,会造成很多没用的I/O负载(要想解决这个问题，需要将flush和compaction操作只针对一个列族) 。  更多紧缩信息, 参考<a href="#compaction" title="9.7.5.5. Compaction">Section 9.7.5.5, “Compaction”</a>. </p>
            <p>尽量在你的应用中使用一个列族。只有你的所有查询操作只访问一个列族的时候，可以引入第二个和第三个列族.例如，你有两个列族,但你查询的时候总是访问其中的一个，从来不会两个一起访问。</p>
            <div title="6.2.  On the number of column families">
              <div title="6.2.1. Cardinality of ColumnFamilies">
                <div>
                  <div>
                    <div>
                      <h3>6.2.1. 列族的基数</h3>
                    </div>
                  </div>
                </div>
                <p>一个表存在多列族，注意基数(如, 行数). 如果列族A有100万行，列族B有10亿行，列族A可能被分散到很多很多区(及区服务器)。这导致扫描列族A低效。</p>
              </div>
            </div>
            <p>&nbsp; </p>
          </div>
          <div class="section" title="8.3.  单调递增Row Keys/时序数据(log)">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title" style="clear: both"><a name="rowkey.design" id="rowkey.design"></a>6.3.&nbsp;                    行键(RowKey)设计</h2>
                  <h3 class="title" style="clear: both">6.3.1. 单调递增行键/时序数据</h3>
                </div>
              </div>
            </div>
            <p> 在Tom White的Hadoop: The Definitive Guide一书中，有一个章节描述了一个值得注意的问题：在一个集群中，一个导入数据的进程一动不动，所有的client都在等待一个region(就是一个节点)，过了一会后，变成了下一个region...如果使用了单调递增或者时序的key就会造成这样的问题。详情可以参见IKai画的漫画<a class="link" href="http://ikaisays.com/2011/01/25/app-engine-datastore-tip-monotonically-increasing-values-are-bad/" target="_top">monotonically increasing values are bad</a>。使用了顺序的key会将本没有顺序的数据变得有顺序，把负载压在一台机器上。所以要尽量避免时间戳或者(e.g. 1, 2, 3)这样的key。 </p>
            <p>如果你需要导入时间顺序的文件(如log)到HBase中，可以学习<a class="link" href="http://opentsdb.net/" target="_top">OpenTSDB</a>的做法。他有一个页面来描述他的<a class="link" href="http://opentsdb.net/schema.html" target="_top">schema</a>.OpenTSDB的Key的格式是[metric_type][event_timestamp]，乍一看，似乎违背了不将timestamp做key的建议，但是他并没有将timestamp作为key的一个关键位置，有成百上千的metric_type就足够将压力分散到各个region了。 </p>
          </div>
          <div class="section" title="8.4. 尽量最小化row和column的大小">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title" style="clear: both"><a name="keysize"></a>6.3.2.&nbsp;尽量最小化行和列的大小(为何我的存储文件指示很大？)</h3>
                </div>
              </div>
            </div>
            <p>在HBase中，值是作为一个单元(Cell)保存在系统的中的，要定位一个单元，需要行，列名和时间戳。通常情况下，如果你的行和列的名字要是太大(甚至比value的大小还要大)的话，你可能会遇到一些有趣的情况。例如Marc Limotte 在 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3551?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel&focusedCommentId=13005272#comment-13005272" target="_top">HBASE-3551</a>(推荐!)尾部提到的现象。在HBase的存储文件<a class="xref" href="#hfile" title="9.7.5.2. StoreFile (HFile)">Section&nbsp;9.7.5.2, “StoreFile (HFile)”</a>中，有一个索引用来方便值的随机访问，但是访问一个单元的坐标要是太大的话，会占用很大的内存，这个索引会被用尽。所以要想解决，可以设置一个更大的块大小，当然也可以使用更小的列名
              。压缩也能得到更大指数。参考话题 <a href="http://search-hadoop.com/m/hemBv1LiN4Q1/a+question+storefileIndexSize&subj=a+question+storefileIndexSize" target="_top">a question storefileIndexSize</a> 用户邮件列表.</p>
            <div title="6.3.2. Try to minimize row and column sizes">
              <p>大部分时候，小的低效不会影响很大。不幸的是，这里会是个问题。无论是列族，属性和行键都会在数据中重复上亿次。参考 <a href="#keyvalue" title="9.7.5.4. KeyValue">Section 9.7.5.4, “KeyValue”</a> 获取更多信息，关于HBase 内部保存数据，了解为什么这很重要。</p>
              <div title="6.3.2.1. Column Families">
                <div>
                  <div>
                    <div>
                      <h4><a name="keysize.cf"></a>6.3.2.1. 列族</h4>
                    </div>
                  </div>
                </div>
                <p>尽量使列族名小，最好一个字符。(如 "d" 表示 data/default).</p>
                <p>参考 <a href="#keyvalue" title="9.7.5.4. KeyValue">Section 9.7.5.4, “KeyValue”</a> 获取更多信息，关于HBase 内部保存数据，了解为什么这很重要。</p>
              </div>
              <div title="6.3.2.2. Attributes">
                <div>
                  <div>
                    <div>
                      <h4><a name="keysize.atttributes"></a>6.3.2.2. 属性</h4>
                    </div>
                  </div>
                </div>
                <p>详细属性名 (如, "myVeryImportantAttribute") 易读，最好还是用短属性名 (e.g., "via") 保存到HBase.</p>
                <p>参考 <a href="#keyvalue" title="9.7.5.4. KeyValue">Section 9.7.5.4, “KeyValue”</a> 获取更多信息，关于HBase 内部保存数据，了解为什么这很重要。</p>
              </div>
              <div title="6.3.2.3. Rowkey Length">
                <div>
                  <div>
                    <div>
                      <h4><a name="keysize.row"></a>6.3.2.3. 行键长度</h4>
                    </div>
                  </div>
                </div>
                <p>让行键短到可读即可，这样对获取数据有用(e.g., Get vs. Scan)。 短键对访问数据无用，并不比长键对get/scan更好。设计行键需要权衡。</p>
              </div>
              <div title="6.3.2.4. Byte Patterns">
                <div>
                  <div>
                    <div>
                      <h4><a name="keysize.patterns"></a>6.3.2.4. 字节模式</h4>
                    </div>
                  </div>
                </div>
                <p>long 类型有 8 字节. 8字节内可以保存无符号数字到18,446,744,073,709,551,615. 如果用字符串保存--假设一个字节一个字符--，需要将近3倍的字节数。</p>
                <p>不信? 下面是示例代码，可以自己运行一下。</p>
                <pre class="programlisting">// long
//
long l = 1234567890L;
byte[] lb = Bytes.toBytes(l);
System.out.println("long bytes length: " + lb.length);   // returns 8
		
String s = "" + l;
byte[] sb = Bytes.toBytes(s);
System.out.println("long as string length: " + sb.length);    // returns 10
			
// hash 
//
MessageDigest md = MessageDigest.getInstance("MD5");
byte[] digest = md.digest(Bytes.toBytes(s));
System.out.println("md5 digest bytes length: " + digest.length);    // returns 16
		
String sDigest = new String(digest);
byte[] sbDigest = Bytes.toBytes(sDigest);
System.out.println("md5 digest as string length: " + sbDigest.length);    // returns 26(译者注：实测值为22)		
</pre>
              </div>
            </div>
            <div title="6.3.3. Reverse Timestamps">
              <div>
                <div>
                  <div>
                    <h3><a name="reverse.timestamp"></a>6.3.3. 倒序时间戳</h3>
                  </div>
                </div>
              </div>
              <p>一个数据库处理的通常问题是找到最近版本的值。采用倒序时间戳作为键的一部分可以对此特定情况有很大帮助。也在Tom White的Hadoop书籍的HBase 章节能找到: The Definitive Guide (O'Reilly), 该技术包含追加(Long.MAX_VALUE - timestamp) 到key的后面，如 [key][reverse_timestamp].</p>
              <p> 表内[key]的最近的值可以用[key]进行 Scan 找到并获取第一个记录。由于 HBase 行键是排序的，该键排在任何比它老的行键的前面，所以必然是第一个。</p>
              <p>该技术可以用于代替<a href="#schema.versions" title="6.4.  Number of Versions">Section 6.4, “ 版本的数量 ”</a> ，其目的是保存所有版本到“永远”(或一段很长时间) 。同时，采用同样的Scan技术，可以很快获取其他版本。</p>
            </div>
            <div title="6.3.4. Rowkeys and ColumnFamilies">
              <div>
                <div>
                  <div>
                    <h3><a name="rowkey.scope"></a>6.3.4. 行键和列族</h3>
                  </div>
                </div>
              </div>
              <p>行键在列族范围内。所以同样的行键可以在同一个表的每个列族中存在而不会冲突。</p>
            </div>
            <div title="6.3.5. Immutability of Rowkeys">
              <div>
                <div>
                  <div>
                    <h3><a name="changing.rowkeys"></a>6.3.5. 行键永远不变</h3>
                  </div>
                </div>
              </div>
              <p>行键不能改变。唯一可以“改变”的方式是删除然后再插入。这是一个网上常问问题，所以要注意开始就要让行键正确(且/或在插入很多数据之前)。</p>
              <div>
                <div>
                  <div>
                    <h2><a name="schema.versions" id="schema.versions"></a>6.4.  版本数量</h2>
</div>
                </div>
              </div>
              <div title="6.4.1. Maximum Number of Versions">
                <div>
                  <div>
                    <div>
                      <h3><a name="schema.versions.max"></a>6.4.1. 最大版本数</h3>
                    </div>
                  </div>
                </div>
                <p> 行的版本的数量是<a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>设置的，每个列族可以单独设置，默认是3。这个设置是很重要的，在<a href="#datamodel" title="Chapter 11. 数据模型">Chapter 5, <em>数据模型</em></a>有描述，因为HBase是<em>不会</em>去覆盖一个值的，他只会在后面在追加写，用时间戳来区分、过早的版本会在执行主紧缩的时候删除。这个版本的值可以根据具体的应用增加减少。 </p>
                <p>不推荐将版本最大值设到一个很高的水平 (如, 成百或更多)，除非老数据对你很重要。因为这会导致存储文件变得极大。</p>
              </div>
              <div title="6.4.2.  Minimum Number of Versions">
                <div>
                  <div>
                    <div>
                      <h3><a name="schema.minversions"></a>6.4.2.  最小版本数</h3>
                    </div>
                  </div>
                </div>
                <p>和行的最大版本数一样，最小版本数也是通过<a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a> 在每个列族中设置的。最小版本数缺省值是0，表示该特性禁用。 最小版本数参数和存活时间一起使用，允许配置如“保存最后T秒有价值数据，最多N个版本，但最少约M个版本”(M是最小版本数，M&lt;N)。 该参数仅在存活时间对列族启用，且必须小于行版本数。</p>
              </div>
              <div>
                <div>
                  <div>
                    <h2><a name="supported.datatypes" id="supported.datatypes"></a>6.5.  支持数据类型</h2>
                  </div>
                </div>
              </div>
              <p>HBase 通过 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Put.html" target="_top">Put</a> 和 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Result.html" target="_top">Result</a>支持 "bytes-in/bytes-out" 接口，所以任何可被转为字节数组的东西可以作为值存入。输入可以是字符串，数字，复杂对象，甚至图像，只要他们能转为字节。</p>
              <p>存在值的实际长度限制 (如 保存 10-50MB 对象到 HBase 可能对查询来说太长); 搜索邮件列表获取本话题的对话。 HBase的所有行都遵循 <a href="#datamodel" title="Chapter 5. Data Model">Chapter 5, <em>数据模型</em></a>, 包括版本化。 设计时需考虑到这些，以及列族的块大小。</p>
              <div title="6.5.1. Counters">
                <div>
                  <div>
                    <div>
                      <h3><a name="counters"></a>6.5.1. 计数器</h3>
                    </div>
                  </div>
                </div>
                <p>一种支持的数据类型，值得一提的是“计数器”(如, 具有原子递增能力的数值)。参考 HTable的 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#increment%28org.apache.hadoop.hbase.client.Increment%29" target="_top">Increment</a> .</p>
                <p>同步计数器在区域服务器中完成，不是客户端。</p>
              </div>
              <div>
                <div>
                  <div>
                    <h2><a name="schema.joins" id="schema.joins"></a>6.6. 联合</h2>
                  </div>
                </div>
              </div>
              <p>如果有多个表，不要在模式设计中忘了 <a href="#joins" title="5.11. Joins">Section 5.11, “Joins”</a> 的潜在因素。</p>
              <div>
                <div>
                  <div>
                    <h2><a name="ttl"></a>6.7. 存活时间 (TTL)</h2>
                  </div>
                </div>
              </div>
              <p>列族可以设置TTL秒数，HBase 在超时后将自动删除数据。影响 <em>全部</em> 行的全部版本 - 甚至当前版本。HBase里面TTL 时间时区是 UTC.</p>
              <p>参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor" target="_top">HColumnDescriptor</a> 获取更多信息。</p>
              <div>
                <div>
                  <div>
                    <h2><a name="cf.keep.deleted" id="cf.keep.deleted"></a>6.8.  保留删除的单元</h2>
                  </div>
                </div>
              </div>
              <p>列族允许是否保留单元。这就是说  <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a> 或 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a> 操作仍可以获取删除的单元。由于这些操作指定时间范围，结束在删除单元发生效果之前。这甚至允许在删除进行时进行即时查询。</p>
              <p>删除的单元仍然受TTL控制，并永远不会超过“最大版本数”被删除的单元。新 "raw" scan 选项返回所有已删除的行和删除标志。</p>
              <p>参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a> 获取更多信息</p>
              <div>
                <div>
                  <div>
                    <h2><a name="secondary.indexes" id="secondary.indexes"></a>6.9.  第二索引和改变路径查询</h2>
                  </div>
                </div>
              </div>
              <p>本节标题也可以为"如果表的行键像<em>这样</em> ，但我又想像<em>那样</em>查询该表." A common example on the dist-list is where a row-key is of the format "user-timestamp" but there are are reporting requirements on activity across users for certain time ranges. Thus, selecting by user is easy because it is in the lead position of the key, but time is not.</p>
              <p>There is no single answer on the best way to handle this because it depends on...</p>
              <div>
                <ul type="disc">
                  <li>Number of users</li>
                  <li>Data size and data arrival rate</li>
                  <li>Flexibility of reporting requirements (e.g., completely ad-hoc date selection vs. pre-configured ranges)</li>
                  <li>Desired execution speed of query (e.g., 90 seconds may be reasonable to some for an ad-hoc report, whereas it may be too long for others)</li>
                </ul>
              </div>
              <p>... and solutions are also influenced by the size of the cluster and how much processing power you have to throw at the solution. Common techniques are in sub-sections below. This is a comprehensive, but not exhaustive, list of approaches.</p>
              <p>It should not be a surprise that secondary indexes require additional cluster space and processing. This is precisely what happens in an RDBMS because the act of creating an alternate index requires both space and processing cycles to update. RBDMS products are more advanced in this regard to handle alternative index management out of the box. However, HBase scales better at larger data volumes, so this is a feature trade-off.</p>
              <p>Pay attention to <a href="#performance" title="Chapter 11. Performance Tuning">Chapter 11, <em>Performance Tuning</em></a> when implementing any of these approaches.</p>
              <p>Additionally, see the David Butler response in this dist-list thread <a href="http://search-hadoop.com/m/nvbiBp2TDP/Stargate%252Bhbase&subj=Stargate+hbase" target="_top">HBase, mail # user - Stargate+hbase</a></p>
              <div title="6.9.1.  Filter Query">
                <div>
                  <div>
                    <div>
                      <h3><a name="secondary.indexes.filter"></a>6.9.1.  过滤查询</h3>
                    </div>
                  </div>
                </div>
                <p>根据具体应用，可能和 <a href="#client.filter" title="9.4. Client Request Filters">Section 9.4, “Client Request Filters”</a> 用法相当。在这种情况下，没有第二索引被创建。然而，不要像这样从应用 (如单线程客户端)中对大表尝试全表扫描。</p>
              </div>
              <div title="6.9.2.  Periodic-Update Secondary Index">
                <div>
                  <div>
                    <div>
                      <h3><a name="secondary.indexes.periodic"></a>6.9.2.  定期更新第二索引</h3>
                    </div>
                  </div>
                </div>
                <p>第二索引可以在另一个表中创建，并通过MapReduce任务定期更新。任务可以在当天执行，但依赖于加载策略，可能会同主表失去同步。</p>
                <p>参考 <a href="#mapreduce.example.readwrite" title="7.2.2. HBase MapReduce Read/Write Example">Section 7.2.2, “HBase MapReduce Read/Write Example”</a> 获取更多信息.</p>
              </div>
              <div title="6.9.3.  Dual-Write Secondary Index">
                <div>
                  <div>
                    <div>
                      <h3><a name="secondary.indexes.dualwrite"></a>6.9.3.  双写第二索引</h3>
                    </div>
                  </div>
                </div>
                <p>另一个策略是在将数据写到集群的同时创建第二索引(如：写到数据表，同时写到索引表)。如果该方法在数据表存在之后采用，则需要利用MapReduce任务来生成已有数据的第二索引。 (参考 <a href="#secondary.indexes.periodic" title="6.9.2.  Periodic-Update Secondary Index">Section 6.9.2, “ Periodic-Update Secondary Index ”</a>).</p>
              </div>
              <div title="6.9.4.  Summary Tables">
                <div>
                  <div>
                    <div>
                      <h3><a name="secondary.indexes.summary"></a>6.9.4.  汇总表(Summary Tables)</h3>
                    </div>
                  </div>
                </div>
                <p>对时间跨度长 (e.g., 年报) 和数据量巨大，汇总表是通用路径。可通过MapReduce任务生成到另一个表。</p>
                <p>参考 <a href="#mapreduce.example.summary" title="7.2.4. HBase MapReduce Summary to HBase Example">Section 7.2.4, “HBase MapReduce Summary to HBase Example”</a> 获取更多信息。</p>
              </div>
              <div title="6.9.5.  Coprocessor Secondary Index">
                <div>
                  <div>
                    <div>
                      <h3><a name="secondary.indexes.coproc"></a>6.9.5.  协处理第二索引</h3>
                    </div>
                  </div>
                </div>
                <p>协处理动作像 RDBMS 触发器。 这在 0.92中添加. 更多参考 <a href="#coprocessors" title="9.6.3. Coprocessors">Section 9.6.3, “Coprocessors”</a></p>
              </div>
              <div>
                <div>
                  <div>
                    <div>
                      <div>
                        <div>
                          <h2><a name="constraints" id="constraints"></a>6.10. 限制</h2>
                        </div>
                      </div>
                    </div>
                    <p>HBase currently supports 'constraints' in traditional (SQL) database parlance. The advised usage for Constraints is in enforcing business rules for attributes in the table (eg. make sure values are in the range 1-10). Constraints could also be used to enforce referential integrity, but this is strongly discouraged as it will dramatically decrease the write throughput of the tables where integrity checking is enabled. Extensive documentation on using Constraints can be found at: <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/constraint" target="_top">Constraint</a> since version 0.94.</p>
                    <p>&nbsp;</p>
                    <h2><a name="schema.smackdown" id="schema.smackdown"></a>6.11. 模式(schema)设计用例</h2>
                  </div>
                </div>
              </div>
              <div title="6.11.2. Case Study - Log Data and Timeseries Data on Steroids">
                <p>This effectively is the OpenTSDB approach. What OpenTSDB does is re-write data and pack rows into columns for certain time-periods. For a detailed explanation, see:<a href="http://opentsdb.net/schema.html" target="_top">http://opentsdb.net/schema.html</a>, and <a href="http://www.cloudera.com/content/cloudera/en/resources/library/hbasecon/video-hbasecon-2012-lessons-learned-from-opentsdb.html" target="_top">Lessons Learned from OpenTSDB</a> from HBaseCon2012.</p>
                <p>But this is how the general concept works: data is ingested, for example, in this manner…</p>
                <pre>[hostname][log-event][timestamp1]  [hostname][log-event][timestamp2]  [hostname][log-event][timestamp3]  </pre>
                <p>… with separate rowkeys for each detailed event, but is re-written like this…</p>
                <p>[hostname][log-event][timerange]</p>
                <p>… and each of the above events are converted into columns stored with a time-offset relative to the beginning timerange (e.g., every 5 minutes). This is obviously a very advanced processing technique, but HBase makes this possible.</p>
              </div>
              <div title="6.11.3. Case Study - Customer/Order">
                <div>
                  <div>
                    <div>
                      <h3><a name="schema.casestudies.custorder"></a>6.11.3. Case Study - Customer/Order</h3>
                    </div>
                  </div>
                </div>
                <p>Assume that HBase is used to store customer and order information. There are two core record-types being ingested: a Customer record type, and Order record type.</p>
                <p>The Customer record type would include all the things that you&rsquo;d typically expect:</p>
                <div>
                  <ul type="disc">
                    <li>Customer number</li>
                    <li>Customer name</li>
                    <li>Address (e.g., city, state, zip)</li>
                    <li>Phone numbers, etc.</li>
                  </ul>
                </div>
                <p>The Order record type would include things like:</p>
                <div>
                  <ul type="disc">
                    <li>Customer number</li>
                    <li>Order number</li>
                    <li>Sales date</li>
                    <li>A series of nested objects for shipping locations and line-items (see <a href="#schema.casestudies.custorder.obj" title="6.11.3.2. Order Object Design">Section 6.11.3.2, &ldquo;Order Object Design&rdquo;</a> for details)</li>
                  </ul>
                </div>
                <p>Assuming that the combination of customer number and sales order uniquely identify an order, these two attributes will compose the rowkey, and specifically a composite key such as:</p>
                <p>[customer number][order number]</p>
                <p>… for a ORDER table. However, there are more design decisions to make: are the <em>raw</em> values the best choices for rowkeys?</p>
                <p>The same design questions in the Log Data use-case confront us here. What is the keyspace of the customer number, and what is the format (e.g., numeric? alphanumeric?) As it is advantageous to use fixed-length keys in HBase, as well as keys that can support a reasonable spread in the keyspace, similar options appear:</p>
                <p>Composite Rowkey With Hashes:</p>
                <div>
                  <ul type="disc">
                    <li>[MD5 of customer number] = 16 bytes</li>
                    <li>[MD5 of order number] = 16 bytes</li>
                  </ul>
                </div>
                <p>Composite Numeric/Hash Combo Rowkey:</p>
                <div>
                  <ul type="disc">
                    <li>[substituted long for customer number] = 8 bytes</li>
                    <li>[MD5 of order number] = 16 bytes</li>
                  </ul>
                </div>
                <div title="6.11.3.1. Single Table? Multiple Tables?">
                  <div>
                    <div>
                      <div>
                        <h4><a name="schema.casestudies.custorder.tables"></a>6.11.3.1. Single Table? Multiple Tables?</h4>
                      </div>
                    </div>
                  </div>
                  <p>A traditional design approach would have separate tables for CUSTOMER and SALES. Another option is to pack multiple record types into a single table (e.g., CUSTOMER++).</p>
                  <p>Customer Record Type Rowkey:</p>
                  <div>
                    <ul type="disc">
                      <li>[customer-id]</li>
                      <li>[type] = type indicating &lsquo;1&rsquo; for customer record type</li>
                    </ul>
                  </div>
                  <p>Order Record Type Rowkey:</p>
                  <div>
                    <ul type="disc">
                      <li>[customer-id]</li>
                      <li>[type] = type indicating &lsquo;2&rsquo; for order record type</li>
                      <li>[order]</li>
                    </ul>
                  </div>
                  <p>The advantage of this particular CUSTOMER++ approach is that organizes many different record-types by customer-id (e.g., a single scan could get you everything about that customer). The disadvantage is that it&rsquo;s not as easy to scan for a particular record-type.</p>
                </div>
                <div title="6.11.3.2. Order Object Design">
                  <div>
                    <div>
                      <div>
                        <h4><a name="schema.casestudies.custorder.obj"></a>6.11.3.2. Order Object Design</h4>
                      </div>
                    </div>
                  </div>
                  <p>Now we need to address how to model the Order object. Assume that the class structure is as follows:</p>
                  <pre>Order       ShippingLocation     (an Order can have multiple ShippingLocations)            LineItem               (a ShippingLocation can have multiple LineItems)  </pre>
                  <p>... there are multiple options on storing this data.</p>
                  <div title="6.11.3.2.1. Completely Normalized">
                    <div>
                      <div>
                        <div>
                          <h5><a name="schema.casestudies.custorder.obj.norm"></a>6.11.3.2.1. Completely Normalized</h5>
                        </div>
                      </div>
                    </div>
                    <p>With this approach, there would be separate tables for ORDER, SHIPPING_LOCATION, and LINE_ITEM.</p>
                    <p>The ORDER table's rowkey was described above: <a href="#schema.casestudies.custorder" title="6.11.3. Case Study - Customer/Order">Section 6.11.3, &ldquo;Case Study - Customer/Order&rdquo;</a></p>
                    <p>The SHIPPING_LOCATION's composite rowkey would be something like this:</p>
                    <div>
                      <ul type="disc">
                        <li>[order-rowkey]</li>
                        <li>[shipping location number] (e.g., 1st location, 2nd, etc.)</li>
                      </ul>
                    </div>
                    <p>The LINE_ITEM table's composite rowkey would be something like this:</p>
                    <div>
                      <ul type="disc">
                        <li>[order-rowkey]</li>
                        <li>[shipping location number] (e.g., 1st location, 2nd, etc.)</li>
                        <li>[line item number] (e.g., 1st lineitem, 2nd, etc.)</li>
                      </ul>
                    </div>
                    <p>Such a normalized model is likely to be the approach with an RDBMS, but that's not your only option with HBase. The cons of such an approach is that to retrieve information about any Order, you will need:</p>
                    <div>
                      <ul type="disc">
                        <li>Get on the ORDER table for the Order</li>
                        <li>Scan on the SHIPPING_LOCATION table for that order to get the ShippingLocation instances</li>
                        <li>Scan on the LINE_ITEM for each ShippingLocation</li>
                      </ul>
                    </div>
                    <p>... granted, this is what an RDBMS would do under the covers anyway, but since there are no joins in HBase you're just more aware of this fact.</p>
                  </div>
                  <div title="6.11.3.2.2. Single Table With Record Types">
                    <div>
                      <div>
                        <div>
                          <h5><a name="schema.casestudies.custorder.obj.rectype"></a>6.11.3.2.2. Single Table With Record Types</h5>
                        </div>
                      </div>
                    </div>
                    <p>With this approach, there would exist a single table ORDER that would contain</p>
                    <p>The Order rowkey was described above: <a href="#schema.casestudies.custorder" title="6.11.3. Case Study - Customer/Order">Section 6.11.3, &ldquo;Case Study - Customer/Order&rdquo;</a></p>
                    <div>
                      <ul type="disc">
                        <li>[order-rowkey]</li>
                        <li>[ORDER record type]</li>
                      </ul>
                    </div>
                    <p>The ShippingLocation composite rowkey would be something like this:</p>
                    <div>
                      <ul type="disc">
                        <li>[order-rowkey]</li>
                        <li>[SHIPPING record type]</li>
                        <li>[shipping location number] (e.g., 1st location, 2nd, etc.)</li>
                      </ul>
                    </div>
                    <p>The LineItem composite rowkey would be something like this:</p>
                    <div>
                      <ul type="disc">
                        <li>[order-rowkey]</li>
                        <li>[LINE record type]</li>
                        <li>[shipping location number] (e.g., 1st location, 2nd, etc.)</li>
                        <li>[line item number] (e.g., 1st lineitem, 2nd, etc.)</li>
                      </ul>
                    </div>
                  </div>
                  <div title="6.11.3.2.3. Denormalized">
                    <div>
                      <div>
                        <div>
                          <h5><a name="schema.casestudies.custorder.obj.denorm"></a>6.11.3.2.3. Denormalized</h5>
                        </div>
                      </div>
                    </div>
                    <p>A variant of the Single Table With Record Types approach is to denormalize and flatten some of the object hierarchy, such as collapsing the ShippingLocation attributes onto each LineItem instance.</p>
                    <p>The LineItem composite rowkey would be something like this:</p>
                    <div>
                      <ul type="disc">
                        <li>[order-rowkey]</li>
                        <li>[LINE record type]</li>
                        <li>[line item number] (e.g., 1st lineitem, 2nd, etc. - care must be taken that there are unique across the entire order)</li>
                      </ul>
                    </div>
                    <p>... and the LineItem columns would be something like this:</p>
                    <div>
                      <ul type="disc">
                        <li>itemNumber</li>
                        <li>quantity</li>
                        <li>price</li>
                        <li>shipToLine1 (denormalized from ShippingLocation)</li>
                        <li>shipToLine2 (denormalized from ShippingLocation)</li>
                        <li>shipToCity (denormalized from ShippingLocation)</li>
                        <li>shipToState (denormalized from ShippingLocation)</li>
                        <li>shipToZip (denormalized from ShippingLocation)</li>
                      </ul>
                    </div>
                    <p>The pros of this approach include a less complex object heirarchy, but one of the cons is that updating gets more complicated in case any of this information changes.</p>
                  </div>
                  <div title="6.11.3.2.4. Object BLOB">
                    <div>
                      <div>
                        <div>
                          <h5><a name="schema.casestudies.custorder.obj.singleobj"></a>6.11.3.2.4. Object BLOB</h5>
                        </div>
                      </div>
                    </div>
                    <p>With this approach, the entire Order object graph is treated, in one way or another, as a BLOB. For example, the ORDER table's rowkey was described above: <a href="#schema.casestudies.custorder" title="6.11.3. Case Study - Customer/Order">Section 6.11.3, &ldquo;Case Study - Customer/Order&rdquo;</a>, and a single column called "order" would contain an object that could be deserialized that contained a container Order, ShippingLocations, and LineItems.</p>
                    <p>There are many options here: JSON, XML, Java Serialization, Avro, Hadoop Writables, etc. All of them are variants of the same approach: encode the object graph to a byte-array. Care should be taken with this approach to ensure backward compatibilty in case the object model changes such that older persisted structures can still be read back out of HBase.</p>
                    <p>Pros are being able to manage complex object graphs with minimal I/O (e.g., a single HBase Get per Order in this example), but the cons include the aforementioned warning about backward compatiblity of serialization, language dependencies of serialization (e.g., Java Serialization only works with Java clients), the fact that you have to deserialize the entire object to get any piece of information inside the BLOB, and the difficulty in getting frameworks like Hive to work with custom objects like this.</p>
                  </div>
                </div>
              </div>
              <div title="6.11.4. Case Study - 'Tall/Wide/Middle' Schema Design Smackdown">
                <div>
                  <div>
                    <div>
                      <h3><a name="schema.smackdown"></a>6.11.4. Case Study - "Tall/Wide/Middle" Schema Design Smackdown</h3>
                    </div>
                  </div>
                </div>
                <p>This section will describe additional schema design questions that appear on the dist-list, specifically about tall and wide tables. These are general guidelines and not laws - each application must consider its own needs.</p>
                <div title="6.11.4.1. Rows vs. Versions">
                  <div>
                    <div>
                      <div>
                        <h4><a name="schema.smackdown.rowsversions"></a>6.11.4.1. Rows vs. Versions</h4>
                      </div>
                    </div>
                  </div>
                  <p>A common question is whether one should prefer rows or HBase's built-in-versioning. The context is typically where there are "a lot" of versions of a row to be retained (e.g., where it is significantly above the HBase default of 3 max versions). The rows-approach would require storing a timstamp in some portion of the rowkey so that they would not overwite with each successive update.</p>
                  <p>Preference: Rows (generally speaking).</p>
                </div>
                <div title="6.11.4.2. Rows vs. Columns">
                  <div>
                    <div>
                      <div>
                        <h4><a name="schema.smackdown.rowscols"></a>6.11.4.2. Rows vs. Columns</h4>
                      </div>
                    </div>
                  </div>
                  <p>Another common question is whether one should prefer rows or columns. The context is typically in extreme cases of wide tables, such as having 1 row with 1 million attributes, or 1 million rows with 1 columns apiece.</p>
                  <p>Preference: Rows (generally speaking). To be clear, this guideline is in the context is in extremely wide cases, not in the standard use-case where one needs to store a few dozen or hundred columns. But there is also a middle path between these two options, and that is "Rows as Columns."</p>
                </div>
                <div title="6.11.4.3. Rows as Columns">
                  <div>
                    <div>
                      <div>
                        <h4><a name="schema.smackdown.rowsascols"></a>6.11.4.3. Rows as Columns</h4>
                      </div>
                    </div>
                  </div>
                  <p>The middle path between Rows vs. Columns is packing data that would be a separate row into columns, for certain rows. OpenTSDB is the best example of this case where a single row represents a defined time-range, and then discrete events are treated as columns. This approach is often more complex, and may require the additional complexity of re-writing your data, but has the advantage of being I/O efficient. For an overview of this approach, see <a href="#">???</a>.</p>
                </div>
              </div>
              <div title="6.11.5. Case Study - List Data">
                <div>
                  <div>
                    <div>
                      <h3><a name="casestudies.schema.listdata"></a>6.11.5. Case Study - List Data</h3>
                    </div>
                  </div>
                </div>
                <p>The following is an exchange from the user dist-list regarding a fairly common question: how to handle per-user list data in Apache HBase.</p>
                <p>*** QUESTION ***</p>
                <p>We're looking at how to store a large amount of (per-user) list data in HBase, and we were trying to figure out what kind of access pattern made the most sense. One option is store the majority of the data in a key, so we could have something like:</p>
                <pre>&lt;FixedWidthUserName&gt;&lt;FixedWidthValueId1&gt;:"" (no value)  &lt;FixedWidthUserName&gt;&lt;FixedWidthValueId2&gt;:"" (no value)  &lt;FixedWidthUserName&gt;&lt;FixedWidthValueId3&gt;:"" (no value)  			</pre>
                The other option we had was to do this entirely using:
                <pre>&lt;FixedWidthUserName&gt;&lt;FixedWidthPageNum0&gt;:&lt;FixedWidthLength&gt;&lt;FixedIdNextPageNum&gt;&lt;ValueId1&gt;&lt;ValueId2&gt;&lt;ValueId3&gt;...  &lt;FixedWidthUserName&gt;&lt;FixedWidthPageNum1&gt;:&lt;FixedWidthLength&gt;&lt;FixedIdNextPageNum&gt;&lt;ValueId1&gt;&lt;ValueId2&gt;&lt;ValueId3&gt;...      		</pre>
                <p>where each row would contain multiple values. So in one case reading the first thirty values would be:</p>
                <pre>scan { STARTROW =&gt; 'FixedWidthUsername' LIMIT =&gt; 30}      		</pre>
                And in the second case it would be
                <pre>get 'FixedWidthUserName\x00\x00\x00\x00'      		</pre>
                <p>The general usage pattern would be to read only the first 30 values of these lists, with infrequent access reading deeper into the lists. Some users would have &lt;= 30 total values in these lists, and some users would have millions (i.e. power-law distribution)</p>
                <p>The single-value format seems like it would take up more space on HBase, but would offer some improved retrieval / pagination flexibility. Would there be any significant performance advantages to be able to paginate via gets vs paginating with scans?</p>
                <p>My initial understanding was that doing a scan should be faster if our paging size is unknown (and caching is set appropriately), but that gets should be faster if we'll always need the same page size. I've ended up hearing different people tell me opposite things about performance. I assume the page sizes would be relatively consistent, so for most use cases we could guarantee that we only wanted one page of data in the fixed-page-length case. I would also assume that we would have infrequent updates, but may have inserts into the middle of these lists (meaning we'd need to update all subsequent rows).</p>
                <p>Thanks for help / suggestions / follow-up questions.</p>
                <p>*** ANSWER ***</p>
                <p>If I understand you correctly, you're ultimately trying to store triples in the form "user, valueid, value", right? E.g., something like:</p>
                <pre>"user123, firstname, Paul",  "user234, lastname, Smith"  			</pre>
                <p>(But the usernames are fixed width, and the valueids are fixed width).</p>
                <p>And, your access pattern is along the lines of: "for user X, list the next 30 values, starting with valueid Y". Is that right? And these values should be returned sorted by valueid?</p>
                <p>The tl;dr version is that you should probably go with one row per user+value, and not build a complicated intra-row pagination scheme on your own unless you're really sure it is needed.</p>
                <p>Your two options mirror a common question people have when designing HBase schemas: should I go "tall" or "wide"? Your first schema is "tall": each row represents one value for one user, and so there are many rows in the table for each user; the row key is user + valueid, and there would be (presumably) a single column qualifier that means "the value". This is great if you want to scan over rows in sorted order by row key (thus my question above, about whether these ids are sorted correctly). You can start a scan at any user+valueid, read the next 30, and be done. What you're giving up is the ability to have transactional guarantees around all the rows for one user, but it doesn't sound like you need that. Doing it this way is generally recommended (see here <a href="#schema.smackdown" target="_top">#schema.smackdown</a>).</p>
                <p>Your second option is "wide": you store a bunch of values in one row, using different qualifiers (where the qualifier is the valueid). The simple way to do that would be to just store ALL values for one user in a single row. I'm guessing you jumped to the "paginated" version because you're assuming that storing millions of columns in a single row would be bad for performance, which may or may not be true; as long as you're not trying to do too much in a single request, or do things like scanning over and returning all of the cells in the row, it shouldn't be fundamentally worse. The client has methods that allow you to get specific slices of columns.</p>
                <p>Note that neither case fundamentally uses more disk space than the other; you're just "shifting" part of the identifying information for a value either to the left (into the row key, in option one) or to the right (into the column qualifiers in option 2). Under the covers, every key/value still stores the whole row key, and column family name. (If this is a bit confusing, take an hour and watch Lars George's excellent video about understanding HBase schema design: <a href="http://www.youtube.com/watch?v=_HLoH_PgrLk)" target="_top">http://www.youtube.com/watch?v=_HLoH_PgrLk)</a>.</p>
                <p>A manually paginated version has lots more complexities, as you note, like having to keep track of how many things are in each page, re-shuffling if new values are inserted, etc. That seems significantly more complex. It might have some slight speed advantages (or disadvantages!) at extremely high throughput, and the only way to really know that would be to try it out. If you don't have time to build it both ways and compare, my advice would be to start with the simplest option (one row per user+value). Start simple and iterate! :)</p>
              </div>
              <p>&nbsp;</p><div title="6.10.2. Rows vs. Columns">
              </div>
              <div>
                <div>
                  <div>
                    <h2><a name="schema.ops" id="schema.ops"></a>6.12. 业务和性能配置选项</h2>
                  </div>
                </div>
              </div>
              <p>参考 the Performance section <a href="#perf.schema" title="11.6. Schema Design">Section 11.6, “Schema Design”</a> for more information operational and performance schema design options, such as Bloom Filters, Table-configured regionsizes, compression, and blocksizes.</p>
              <div>
                <div>
                  <div></div>
                </div>
              </div>
              <p>&nbsp;</p>
            </div>
          </div>
          <h2 class="title">&nbsp;</h2></div></div></div></div><div class="chapter" title="Chapter 7. HBase 和 MapReduce"><div class="titlepage"><div><div><h2 class="title"><a name="mapreduce"></a>Chapter&nbsp;7.&nbsp;HBase 和 MapReduce</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#splitter">7.1. 默认 HBase MapReduce 分割器(Splitter)</a></span></dt><dt><span class="section"><a href="#mapreduce.example">7.2. HBase Input MapReduce 例子</a></span></dt><dt><span class="section"><a href="#mapreduce.htable.access">7.3. 在一个MapReduce Job中访问其他的HBase Tables</a></span></dt><dt><span class="section"><a href="#mapreduce.specex">7.4. 预测执行</a></span></dt></dl></div>
          <p>关于 <a class="link" href="http://hbase.org/apidocs/org/apache/hadoop/hbase/mapreduce/package-summary.html#package_description" target="_top">HBase 和 MapReduce</a>详见 javadocs.
  下面是一些附加的帮助文档.   MapReduce的更多信息 (如，通用框架), 参考 <a href="http://hadoop.apache.org/common/docs/current/mapred_tutorial.html" target="_top">Hadoop MapReduce Tutorial</a>. </p>
           <div class="section" title="7.1. 默认 HBase MapReduce 分割器(Splitter)"><div class="titlepage"><div>
             <div><h2 class="title" style="clear: both"><a name="splitter"></a>7.1.&nbsp;Map-Task 分割</h2>
<h3 class="title" style="clear: both">7.1.1 默认 HBase MapReduce 分割器(Splitter)</h3>
             </div></div></div>
           <p>当 MapReduce 任务的HBase 表使用<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html" target="_top">TableInputFormat</a>为数据源格式的时候,他的splitter会给这个table的每个region一个map。因此，如果一个table有100个region，就有100个map-tasks，不论需需要scan多少个列族 。
 </p>
             <div>
               <div>
                 <div>
                   <h3>7.1.2. 自定义分割器</h3>
                 </div>
               </div>
             </div>iv>
             <p>For those interested in implementing custom splitters, see the method getSplits in <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.html" target="_top">TableInputFormatBase</a>. That is where the logic for map-task assignment resides.</p>
<p>&nbsp;</p>
           </div><div class="section" title="7.2. HBase Input MapReduce 例子"><div class="titlepage"><div>
             <div>
               <h2 class="title" style="clear: both"><a name="mapreduce.example"></a>7.2.&nbsp;HBase MapReduce 例子</h2>
<h2 class="title" style="clear: both">7.2.1 HBase  MapReduce 读取例子</h2>
             </div></div></div>
           <p>下面是使用HBase 作为源的MapReduce读取示例。特别是仅有Mapper实例，没有Reducer。Mapper什么也不产生。</p>
             <p>  如下所示...
	         </p>
             <pre class="programlisting">Configuration config = HBaseConfiguration.create();<br>Job job = new Job(config, &quot;ExampleRead&quot;);<br>job.setJarByClass(MyReadJob.class);     // class that contains mapper<br>	<br>Scan scan = new Scan();<br>scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs<br>scan.setCacheBlocks(false);  // don't set to true for MR jobs<br>// set other scan attrs<br>...<br>  <br>TableMapReduceUtil.initTableMapperJob(<br>  tableName,        // input HBase table name<br>  scan,             // Scan instance to control CF and attribute selection<br>  MyMapper.class,   // mapper<br>  null,             // mapper output key <br>  null,             // mapper output value<br>  job);<br>job.setOutputFormatClass(NullOutputFormat.class);   // because we aren't emitting anything from mapper<br>	    <br>boolean b = job.waitForCompletion(true);<br>if (!b) {<br>  throw new IOException(&quot;error with job!&quot;);<br>}</pre>
             <p>
  ...mapper需要继承于<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html" target="_top">TableMapper</a>...
	</p><pre class="programlisting">public class MyMapper extends TableMapper&lt;Text, LongWritable&gt; {
public void map(ImmutableBytesWritable row, Result value, Context context) 
throws InterruptedException, IOException {
// process data for the row from the Result instance.</pre><p>
  	</p></div>
  	<div class="section" title="7.2.&nbsp;HBase MapReduce Examples"><div class="titlepage"><div><div></div></div></div><div class="section" title="7.2.2.&nbsp;HBase MapReduce Read/Write Example"><div class="titlepage"><div><div>
  	  <h3 class="title"><a name="mapreduce.example.readwrite"></a>7.2.2.&nbsp;HBase MapReduce 读/写 示例</h3></div></div></div>
  	<p>下面是使用HBase 作为源和目标的MapReduce示例. 
    本示例简单从一个表复制到另一个表。</p><pre class="programlisting">Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleReadWrite");
job.setJarByClass(MyReadWriteJob.class);    // class that contains mapper
	        	        
Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs
	        
TableMapReduceUtil.initTableMapperJob(
	sourceTable,      // input table
	scan,	          // Scan instance to control CF and attribute selection
	MyMapper.class,   // mapper class
	null,	          // mapper output key
	null,	          // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,      // output table
	null,             // reducer class
	job);
job.setNumReduceTasks(0);
	        
boolean b = job.waitForCompletion(true);
if (!b) {
    throw new IOException("error with job!");
}
    </pre>
    <p><code class="classname">TableMapReduceUtil做了什么需要解释</code>, 特别是对 reducer. <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html" target="_top">TableOutputFormat</a> 作为 outputFormat 类, 几个参数在config中设置(e.g., TableOutputFormat.OUTPUT_TABLE), 同时设置reducer output key 到 <code class="classname">ImmutableBytesWritable</code> 和 reducer value到 <code class="classname">Writable</code>.
	这可以编程时设置到job和conf，但<code class="classname">TableMapReduceUtil</code> 使其变简单.    
	</p>
    <p>下面是 mapper示例, 创建一个 <code class="classname">Put</code>，匹配输入的 <code class="classname">Result</code>
	并提交.  Note:  这是 CopyTable 工具做的.
	</p><p>
    </p><pre class="programlisting">public static class MyMapper extends TableMapper&lt;ImmutableBytesWritable, Put&gt;  {

	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
		// this example is just copying the data from the source table...
   		context.write(row, resultToPut(row,value));
   	}
        
  	private static Put resultToPut(ImmutableBytesWritable key, Result result) throws IOException {
  		Put put = new Put(key.get());
 		for (KeyValue kv : result.raw()) {
			put.add(kv);
		}
		return put;
   	}
}
    </pre><p>这不是真正的 reducer 步骤, 所以 <code class="classname">TableOutputFormat</code> 处理发送 <code class="classname">Put</code>
    到目标表.    </p>
<p>这仅是示例, 开发者可以选择不使用<code class="classname">TableOutputFormat</code>并自己连接到目标表。</p>
    <p>
    </p></div><div class="section" title="7.2.3.&nbsp;HBase MapReduce Read/Write Example With Multi-Table Output"><div class="titlepage"><div><div>
      <h3 class="title"><a name="mapreduce.example.readwrite.multi"></a>7.2.3.&nbsp;HBase MapReduce Read/Write  多表输出示例</h3></div></div></div>
    <p>TODO:   <code class="classname">MultiTableOutputFormat</code> 示例.
    </p></div><div class="section" title="7.2.4.&nbsp;HBase MapReduce Summary to HBase Example"><div class="titlepage"><div><div>
      <h3 class="title"><a name="mapreduce.example.summary"></a>7.2.4.&nbsp;HBase MapReduce 汇总到 HBase 示例</h3></div></div></div>
    <p>下面是使用HBase 作为源和目标的MapReduce示例，具有汇总步骤。本示例计算一个表中值的个数，并将汇总的计数输出到另一个表。</p><pre class="programlisting">Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummary");
job.setJarByClass(MySummaryJob.class);     // class that contains mapper and reducer
	        
Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs
	        
TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,        // output table
	MyTableReducer.class,    // reducer class
	job);
job.setNumReduceTasks(1);   // at least one, adjust as required
	    
boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}    
    </pre>
    <p>
    本示例mapper，将一个列的一个字符串值作为汇总值。该值作为key在mapper中生成。 <code class="classname">IntWritable</code> 代表一个实例计数。
    </p><pre class="programlisting">public static class MyMapper extends TableMapper&lt;Text, IntWritable&gt;  {

	private final IntWritable ONE = new IntWritable(1);
   	private Text text = new Text();
    	
   	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
        	String val = new String(value.getValue(Bytes.toBytes("cf"), Bytes.toBytes("attr1")));
          	text.set(val);     // we can only emit Writables...

        	context.write(text, ONE);
   	}
}
    </pre>
    <p>
    在 reducer,  "ones" 被统计 (和其他 MR 示例一样), 产生一个 <code class="classname">Put</code>.
    </p><pre class="programlisting">public static class MyTableReducer extends TableReducer&lt;Text, IntWritable, ImmutableBytesWritable&gt;  {
        
 	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
    		int i = 0;
    		for (IntWritable val : values) {
    			i += val.get();
    		}
    		Put put = new Put(Bytes.toBytes(key.toString()));
    		put.add(Bytes.toBytes("cf"), Bytes.toBytes("count"), Bytes.toBytes(i));

    		context.write(null, put);
   	}
}
    </pre><p>
    </p></div><div class="section" title="7.2.5.&nbsp;HBase MapReduce Summary to File Example"><div class="titlepage"><div><div>
      <h3 class="title"><a name="mapreduce.example.summary.file"></a>7.2.5.&nbsp;HBase MapReduce 汇总到文件示例</h3></div></div></div><p>This very similar to the summary example above, with exception that this is using HBase as a MapReduce source
       but HDFS as the sink.  The differences are in the job setup and in the reducer.  The mapper remains the same.
       </p><pre class="programlisting">Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummaryToFile");
job.setJarByClass(MySummaryFileJob.class);     // class that contains mapper and reducer
	        
Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs
	        
TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
job.setReducerClass(MyReducer.class);    // reducer class
job.setNumReduceTasks(1);    // at least one, adjust as required
FileOutputFormat.setOutputPath(job, new Path("/tmp/mr/mySummaryFile"));  // adjust directories as required
	    
boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}    
    </pre>
    As stated above, the previous Mapper can run unchanged with this example.  
    As for the Reducer, it is a "generic" Reducer instead of extending TableMapper and emitting Puts.
    <pre class="programlisting"> public static class MyReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {
        
	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		int i = 0;
		for (IntWritable val : values) {
			i += val.get();
		}	
		context.write(key, new IntWritable(i));
	}
}
    </pre></div><div class="section" title="7.2.6.&nbsp;HBase MapReduce Summary to HBase Without Reducer"><div class="titlepage"><div><div>
      <h3 class="title"><a name="mapreduce.example.summary.noreducer"></a>7.2.6.&nbsp;HBase MapReduce 没有Reducer时汇总到 HBase  </h3></div></div></div><p>It is also possible to perform summaries without a reducer - if you use HBase as the reducer.
       </p><p>An HBase target table would need to exist for the job summary.  The HTable method <code class="code">incrementColumnValue</code>
       would be used to atomically increment values.  From a performance perspective, it might make sense to keep a Map 
       of values with their values to be incremeneted for each map-task, and make one update per key at during the <code class="code">
       cleanup</code> method of the mapper.  However, your milage may vary depending on the number of rows to be processed and 
       unique keys.
       </p><p>In the end, the summary results are in HBase.
       </p></div><div class="section" title="7.2.7.&nbsp;HBase MapReduce Summary to RDBMS"><div class="titlepage"><div><div>
         <h3 class="title"><a name="mapreduce.example.summary.rdbms"></a>7.2.7.&nbsp;HBase MapReduce 汇总到 RDBMS</h3></div></div></div>
       <p>有时更合适产生汇总到 RDBMS.这种情况下,可以将汇总直接通过一个自定义的reducer输出到
       RDBMS 。 <code class="code">setup</code> 方法可以连接到 RDBMS (连接信息可以通过context的自定义参数传递)，
       cleanup 可以关闭连接.
       </p>
       <p>关键需要理解job的多个reducer会影响汇总实现，必须在reducer中进行设计。无论是一个recucer还是多个reducer。不管对错, 依赖于你的用例。认识到多个reducer分配到job，需要创建多个并发的RDBMS连接-可以扩充，但仅在一个点。</p><pre class="programlisting"> public static class MyRdbmsReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {

	private Connection c = null;
	
	public void setup(Context context) {
  		// create DB connection...
  	}
        
	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		// do summarization
		// in this example the keys are Text, but this is just an example
	}
	
	public void cleanup(Context context) {
  		// close db connection
  	}
	
}
    </pre>
       <p>最后，汇总的结果被写入到 RDBMS 表.
       </p></div></div>
  	<div class="section" title="7.3. 在一个MapReduce Job中访问其他的HBase Tables"><div class="titlepage"><div>
  	  <div>
  	    <div>
  	      <div>
  	        <div></div>
  	      </div>
  	    </div>
  	    <h2 class="title" style="clear: both"><a name="mapreduce.htable.access"></a>7.3.&nbsp;在一个MapReduce Job中访问其他的HBase Tables</h2>
  	  </div></div></div><p>尽管现有的框架允许一个HBase table作为一个MapReduce job的输入，其他的HBase table可以同时作为普通的表被访问。例如在一个MapReduce的job中，可以在Mapper的setup方法中创建HTable实例。
	</p><pre class="programlisting">public class MyMapper extends TableMapper&lt;Text, LongWritable&gt; {
  private HTable myOtherTable;

  @Override
  public void setup(Context context) {
    myOtherTable = new HTable("myOtherTable");
  }</pre><p>
   </p></div><div class="section" title="7.4. 预测执行"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapreduce.specex"></a>7.4.&nbsp;预测执行</h2></div></div></div><p>通常建议关掉针对HBase的MapReduce job的预测执行(speculative execution)功能。这个功能也可以用每个Job的配置来完成。对于整个集群，使用预测执行意味着双倍的运算量。这可不是你所希望的。</p>
     <p> 参考 <a href="#spec.ex" title="2.8.2.9. Speculative Execution">Section 2.8.2.9, “Speculative Execution”</a> 获取更多信息。 </p>
   </div></div>
   
   <div class="chapter" title="Chapter&nbsp;8.&nbsp;Secure HBase"><div class="titlepage"><div><div>
     <h2 class="title"><a name="security"></a>Chapter&nbsp;8.&nbsp; HBase安全</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#hbase.secure.configuration">8.1. 安全客户端访问HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#d1934e4347">8.1.1. 先决条件</a></span></dt><dt><span class="section"><a href="#d1934e4393">8.1.2. Server-side Configuration for Secure Operation</a></span></dt><dt><span class="section"><a href="#d1934e4405">8.1.3. 客户端安全操作配置</a></span></dt><dt><span class="section"><a href="#d1934e4447">8.1.4. 客户端安全操作配置 - Thrift Gateway</a></span></dt><dt><span class="section"><a href="#d1934e4462">8.1.5. 客户端安全操作配置 - REST Gateway</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.accesscontrol.configuration">8.2. 访问控制</a></span></dt><dd><dl><dt><span class="section"><a href="#d1934e4487">8.2.1. 先决条件</a></span></dt><dt><span class="section"><a href="#d1934e4494">8.2.2. 概述</a></span></dt><dt><span class="section"><a href="#d1934e4651">8.2.3. Server-side Configuration for Access Control</a></span></dt><dt><span class="section"><a href="#d1934e4663">8.2.4. Shell Enhancements for Access Control</a></span></dt></dl></dd></dl></div><div class="section" title="8.1.&nbsp;Secure Client Access to HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.secure.configuration"></a>8.1.&nbsp;安全客户端访问HBase</h2></div></div></div>
     <p>新版 HBase (&gt;= 0.92) 支持客户端可选 SASL 认证.</p>
     <p>这里描述如何设置HBase 和 HBase 客户端，以安全连接到HBase 资源. </p><div class="section" title="8.1.1.&nbsp;Prerequisites"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e4347"></a>8.1.1.&nbsp;先决条件</h3></div></div></div>
     <p>
       HBase 必须使用 安全Hadoop/HBase的新 maven 配置文件： <code class="code">-P security</code>. Secure Hadoop dependent classes are separated under a pseudo-module in the security/ directory and are only included if built with the secure Hadoop profile. 
    </p><p>
        You need to have a working Kerberos KDC.
    </p><p>
        A HBase configured for secure client access is expected to be running
        on top of a secured HDFS cluster. HBase must be able to authenticate
        to HDFS services. HBase needs Kerberos credentials to interact with
        the Kerberos-enabled HDFS daemons. Authenticating a service should be
        done using a keytab file. The procedure for creating keytabs for HBase
        service is the same as for creating keytabs for Hadoop. Those steps
        are omitted here. Copy the resulting keytab files to wherever HBase
        Master and RegionServer processes are deployed and make them readable
        only to the user account under which the HBase daemons will run.
    </p><p>
        A Kerberos principal has three parts, with the form 
        <code class="code">username/fully.qualified.domain.name@YOUR-REALM.COM</code>. We
        recommend using <code class="code">hbase</code> as the username portion.
    </p><p>
        The following is an example of the configuration properties for
        Kerberos operation that must be added to the 
        <code class="code">hbase-site.xml</code> file on every server machine in the
        cluster. Required for even the most basic interactions with a
        secure Hadoop configuration, independent of HBase security.
    </p><pre class="programlisting">      &lt;property&gt;
        &lt;name&gt;hbase.regionserver.kerberos.principal&lt;/name&gt;
        &lt;value&gt;hbase/_HOST@YOUR-REALM.COM&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.regionserver.keytab.file&lt;/name&gt;
        &lt;value&gt;/etc/hbase/conf/keytab.krb5&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.master.kerberos.principal&lt;/name&gt;
        &lt;value&gt;hbase/_HOST@YOUR-REALM.COM&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.master.keytab.file&lt;/name&gt;
        &lt;value&gt;/etc/hbase/conf/keytab.krb5&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        Each HBase client user should also be given a Kerberos principal. This
        principal should have a password assigned to it (as opposed to a
        keytab file). The client principal's <code class="code">maxrenewlife</code> should
        be set so that it can be renewed enough times for the HBase client
        process to complete. For example, if a user runs a long-running HBase
        client process that takes at most 3 days, we might create this user's
        principal within <code class="code">kadmin</code> with: <code class="code">addprinc -maxrenewlife
        3days</code>
    </p><p>
        Long running daemons with indefinite lifetimes that require client
        access to HBase can instead be configured to log in from a keytab. For
        each host running such daemons, create a keytab with 
        <code class="code">kadmin</code> or <code class="code">kadmin.local</code>. The procedure for
        creating keytabs for HBase service is the same as for creating
        keytabs for Hadoop. Those steps are omitted here. Copy the resulting
        keytab files to where the client daemon will execute and make them
        readable only to the user account under which the daemon will run.
    </p></div><div class="section" title="8.1.2.&nbsp;Server-side Configuration for Secure Operation"><div class="titlepage"><div><div>
      <h3 class="title"><a name="d1934e4393"></a>8.1.2.&nbsp;安全操作的服务器端配置</h3></div></div></div><p>
        增加下列内容到 <code class="code">hbase-site.xml</code> file on every server machine in the cluster:
    </p><pre class="programlisting">      &lt;property&gt;
        &lt;name&gt;hbase.security.authentication&lt;/name&gt;
        &lt;value&gt;kerberos&lt;/value&gt; 
      &lt;/property&gt; 
      &lt;property&gt;
        &lt;name&gt;hbase.security.authorization&lt;/name&gt;
        &lt;value&gt;true&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.rpc.engine&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.ipc.SecureRpcEngine&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
      &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
       A full shutdown and restart of HBase service is required when deploying
       these configuration changes.
    </p></div><div class="section" title="8.1.3.&nbsp;Client-side Configuration for Secure Operation"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e4405"></a>8.1.3.&nbsp;客户端安全操作配置</h3></div></div></div>
    <p>
        每个客户端增加下列内容到 <code class="code">hbase-site.xml</code>: </p><pre class="programlisting">      &lt;property&gt;
        &lt;name&gt;hbase.security.authentication&lt;/name&gt;
        &lt;value&gt;kerberos&lt;/value&gt;
      &lt;/property&gt; 
      &lt;property&gt;
        &lt;name&gt;hbase.rpc.engine&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.ipc.SecureRpcEngine&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        The client environment must be logged in to Kerberos from KDC or
        keytab via the <code class="code">kinit</code> command before communication with
        the HBase cluster will be possible.
    </p><p>
        Be advised that if the <code class="code">hbase.security.authentication</code>
        and <code class="code">hbase.rpc.engine</code> properties in the client- and
        server-side site files do not match, the client will not be able to
        communicate with the cluster.
    </p><p>
        Once HBase is configured for secure RPC it is possible to optionally
        configure encrypted communication. To do so, 增加下列内容到
        <code class="code">hbase-site.xml</code> file on every client:
    </p><pre class="programlisting">      &lt;property&gt;
        &lt;name&gt;hbase.rpc.protection&lt;/name&gt;
        &lt;value&gt;privacy&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        This configuration property can also be set on a per connection basis.
        Set it in the <code class="code">Configuration</code> supplied to
        <code class="code">HTable</code>:
    </p><pre class="programlisting">      Configuration conf = HBaseConfiguration.create();
      conf.set("hbase.rpc.protection", "privacy");
      HTable table = new HTable(conf, tablename);
    </pre><p>
        Expect a ~10% performance penalty for encrypted communication.
    </p></div><div class="section" title="8.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway"><div class="titlepage"><div><div>
      <h3 class="title"><a name="d1934e4447"></a>8.1.4.&nbsp;客户端安全操作配置 - Thrift 网关</h3></div></div></div>
    <p>
      每个Thrift网关增加下列内容到 <code class="code">hbase-site.xml</code>: </p><pre class="programlisting">    &lt;property&gt;
      &lt;name&gt;hbase.thrift.keytab.file&lt;/name&gt;
      &lt;value&gt;/etc/hbase/conf/hbase.keytab&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.thrift.kerberos.principal&lt;/name&gt;
      &lt;value&gt;$USER/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
    &lt;/property&gt;
    </pre><p>
    </p><p>
        Substitute the appropriate credential and keytab for $USER and $KEYTAB
        respectively.
    </p><p>
        The Thrift gateway will authenticate with HBase using the supplied
        credential. No authentication will be performed by the Thrift gateway
        itself. All client access via the Thrift gateway will use the Thrift
        gateway's credential and have its privilege.
    </p></div><div class="section" title="8.1.5.&nbsp;Client-side Configuration for Secure Operation - REST Gateway"><div class="titlepage"><div><div>
      <h3 class="title"><a name="d1934e4462"></a>8.1.5.&nbsp;客户端安全操作配置 - REST 网关</h3></div></div></div>
    <p>
      每个REST网关增加下列内容到 <code class="code">hbase-site.xml</code>: </p><pre class="programlisting">    &lt;property&gt;
      &lt;name&gt;hbase.rest.keytab.file&lt;/name&gt;
      &lt;value&gt;$KEYTAB&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.rest.kerberos.principal&lt;/name&gt;
      &lt;value&gt;$USER/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
    &lt;/property&gt;
    </pre><p>
    </p><p>
        Substitute the appropriate credential and keytab for $USER and $KEYTAB
        respectively.
    </p><p>
        The REST gateway will authenticate with HBase using the supplied
        credential. No authentication will be performed by the REST gateway
        itself. All client access via the REST gateway will use the REST
        gateway's credential and have its privilege.
    </p><p>
        It should be possible for clients to authenticate with the HBase
        cluster through the REST gateway in a pass-through manner via SPEGNO
        HTTP authentication. This is future work.
    </p></div></div></div>
   <div class="section" title="8.2.&nbsp;Access Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.accesscontrol.configuration"></a>8.2.&nbsp;访问控制</h2></div></div></div><p>
        Newer releases of HBase (&gt;= 0.92) support optional access control
        list (ACL-) based protection of resources on a column family and/or
        table basis.
    </p><p>
        This describes how to set up Secure HBase for access control, with an
        example of granting and revoking user permission on table resources
        provided.
    </p><div class="section" title="8.2.1.&nbsp;Prerequisites"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e4487"></a>8.2.1.&nbsp;先决条件</h3></div></div></div><p>
       You must configure HBase for secure operation. Refer to the section
       "安全客户端访问HBase" and complete all of the steps described
       there.
    </p><p>
       You must also configure ZooKeeper for secure operation. Changes to ACLs
       are synchronized throughout the cluster using ZooKeeper. Secure 
       authentication to ZooKeeper must be enabled or otherwise it will be
       possible to subvert HBase access control via direct client access to
       ZooKeeper. Refer to the section on secure ZooKeeper configuration and
       complete all of the steps described there.
    </p></div><div class="section" title="8.2.2.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e4494"></a>8.2.2.&nbsp;概述</h3></div></div></div><p>
        With Secure RPC and Access Control enabled, client access to HBase is
        authenticated and user data is private unless access has been
        explicitly granted. Access to data can be granted at a table or per
        column family basis. 
    </p><p>
        However, the following items have been left out of the initial
        implementation for simplicity:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Row-level or per value (cell): This would require broader changes for storing the ACLs inline with rows. It is a future goal.</p></li><li class="listitem"><p>Push down of file ownership to HDFS: HBase is not designed for the case where files may have different permissions than the HBase system principal. Pushing file ownership down into HDFS would necessitate changes to core code. Also, while HDFS file ownership would make applying quotas easy, and possibly make bulk imports more straightforward, it is not clear that it would offer a more secure setup.</p></li><li class="listitem"><p>HBase managed "roles" as collections of permissions: We will not model "roles" internally in HBase to begin with. We instead allow group names to be granted permissions, which allows external modeling of roles via group membership. Groups are created and manipulated externally to HBase, via the Hadoop group mapping service.</p></li></ol></div><p>
Access control mechanisms are mature and fairly standardized in the relational database world. The HBase implementation approximates current convention, but HBase has a simpler feature set than relational databases, especially in terms of client operations. We don't distinguish between an insert (new record) and update (of existing record), for example, as both collapse down into a Put. Accordingly, the important operations condense to four permissions: READ, WRITE, CREATE, and ADMIN.
    </p>Operation To Permission MappingPermissionOperationReadGetExistsScanWritePutDeleteLock/UnlockRowIncrementColumnValueCheckAndDelete/PutFlushCompactCreateCreateAlterDropAdminEnable/DisableSplitMajor CompactGrantRevokeShutdown<table id="d1934e4513"><thead></thead><tbody></tbody></table><p>
        Permissions can be granted in any of the following scopes, though
        CREATE and ADMIN permissions are effective only at table scope.
    </p><p>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Table</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Read: User can read from any column family in table</p></li><li class="listitem"><p>Write: User can write to any column family in table</p></li><li class="listitem"><p>Create: User can alter table attributes; add, alter, or drop column families; and drop the table.</p></li><li class="listitem"><p>Admin: User can alter table attributes; add, alter, or drop column families; and enable, disable, or drop the table. User can also trigger region (re)assignments or relocation.</p></li></ul></div><p>
        </p></li><li class="listitem"><p>Column Family</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Read: User can read from the column family</p></li><li class="listitem"><p>Write: User can write to the column family</p></li></ul></div><p>
        </p></li></ul></div><p>
    </p><p>
       There is also an implicit global scope for the superuser.
    </p><p>
       The superuser is a principal, specified in the HBase site configuration
       file, that has equivalent access to HBase as the 'root' user would on a
       UNIX derived system. Normally this is the principal that the HBase
       processes themselves authenticate as. Although future versions of HBase
       Access Control may support multiple superusers, the superuser privilege
       will always include the principal used to run the HMaster process. Only
       the superuser is allowed to create tables, switch the balancer on or
       off, or take other actions with global consequence. Furthermore, the
       superuser has an implicit grant of all permissions to all resources.
    </p><p>
       Tables have a new metadata attribute: OWNER, the user principal who owns
       the table. By default this will be set to the user principal who creates
       the table, though it may be changed at table creation time or during an
       alter operation by setting or changing the OWNER table attribute. Only a
       single user principal can own a table at a given time. A table owner will
       have all permissions over a given table. 
    </p></div><div class="section" title="8.2.3.&nbsp;Server-side Configuration for Access Control"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e4651"></a>8.2.3.&nbsp;Server-side Configuration for Access Control</h3></div></div></div><p>
        Enable the AccessController coprocessor in the cluster configuration
        and restart HBase. The restart can be a rolling one. Complete the
        restart of all Master and RegionServer processes before setting up
        ACLs.
    </p><p>
        To enable the AccessController, modify the <code class="code">hbase-site.xml</code> file on every server machine in the cluster to look like:
    </p><pre class="programlisting">      &lt;property&gt;
        &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
      &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider,
        org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt;
    </pre></div><div class="section" title="8.2.4.&nbsp;Shell Enhancements for Access Control"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e4663"></a>8.2.4.&nbsp;Shell Enhancements for Access Control</h3></div></div></div><p>
The HBase shell has been extended to provide simple commands for editing and updating user permissions. The following commands have been added for access control list management: 
    </p>
    Grant
    <p>
    </p><pre class="programlisting">    grant &lt;user&gt; &lt;permissions&gt; &lt;table&gt; [ &lt;column family&gt; [ &lt;column qualifier&gt; ] ]
    </pre><p>
    </p><p>
    <code class="code">&lt;permissions&gt;</code> is zero or more letters from the set "RWCA": READ('R'), WRITE('W'), CREATE('C'), ADMIN('A'). 
    </p><p>
    Note: Grants and revocations of individual permissions on a resource are both accomplished using the <code class="code">grant</code> command. A separate <code class="code">revoke</code> command is also provided by the shell, but this is for fast revocation of all of a user's access rights to a given resource only.
    </p><p>
    Revoke
    </p><p>
    </p><pre class="programlisting">    revoke &lt;user&gt; &lt;table&gt; [ &lt;column family&gt; [ &lt;column qualifier&gt; ] ]
    </pre><p>
    </p><p>
    Alter
    </p><p>
    The <code class="code">alter</code> command has been extended to allow ownership assignment:
    </p><pre class="programlisting">      alter 'tablename', {OWNER =&gt; 'username'}
    </pre><p>
    </p><p>
    User Permission
    </p><p>
    The <code class="code">user_permission</code> command shows all access permissions for the current user for a given table:
    </p><pre class="programlisting">      user_permission &lt;table&gt;
    </pre><p>
    </p>
    <div title="8.3. Secure Bulk Load">
      <div>
        <div>
          <div>
            <h2>8.3. Secure Bulk Load</h2>
          </div>
        </div>
      </div>
      <p>Bulk loading in secure mode is a bit more involved than normal setup, since the client has to transfer the ownership of the files generated from the mapreduce job to HBase. Secure bulk loading is implemented by a coprocessor, named <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/security/access/SecureBulkLoadEndpoint.html" target="_top">SecureBulkLoadEndpoint</a>. SecureBulkLoadEndpoint uses a staging directory "hbase.bulkload.staging.dir", which defaults to /tmp/hbase-staging/. The algorithm is as follows.</p>
      <div>
        <ul type="disc">
          <li>Create an hbase owned staging directory which is world traversable (-rwx--x--x, 711) /tmp/hbase-staging.</li>
          <li>A user writes out data to his secure output directory: /user/foo/data</li>
          <li>A call is made to hbase to create a secret staging directory which is globally readable/writable (-rwxrwxrwx, 777): /tmp/hbase-staging/averylongandrandomdirectoryname</li>
          <li>The user makes the data world readable and writable, then moves it into the random staging directory, then calls bulkLoadHFiles()</li>
        </ul>
      </div>
      <p>Like delegation tokens the strength of the security lies in the length and randomness of the secret directory.</p>
      <p>You have to enable the secure bulk load to work properly. You can modify the hbase-site.xml file on every server machine in the cluster and add the SecureBulkLoadEndpoint class to the list of regionserver coprocessors:</p>
      <pre>      &lt;property&gt;          &lt;name&gt;hbase.bulkload.staging.dir&lt;/name&gt;          &lt;value&gt;/tmp/hbase-staging&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;          &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider,          org.apache.hadoop.hbase.security.access.AccessController,org.apache.hadoop.hbase.security.access.SecureBulkLoadEndpoint&lt;/value&gt;        &lt;/property&gt;      </pre>
    </div>
    <div><br>
    </div>
    <br>
    </div></div>
    
   <div class="chapter" title="Chapter 8. HBase 的 Schema 设计"><div class="titlepage"><div><div></div></div></div><div class="section" title="8.1.  Schema 创建"><div class="titlepage"><div><div></div></div></div></div></div><div class="chapter" title="Chapter 9. Metrics"><div class="titlepage"><div><div>
     <div class="titlepage">
       <div>
         <div>
           <h2 class="title"><a name="architecture"></a>Chapter&nbsp;9.&nbsp;架构</h2>
         </div>
       </div>
     </div>
     <div class="toc">
       <p><b>Table of Contents</b></p>
       <dl>
         <dt><a href="#arch.overview">9.1. 概述</a></dt>
         <dt><a href="#arch.catalog">9.2. 目录表</a> </dt>
         <dt><a href="#client">9.3. Client</a> </dt>
         <dt><a href="#client.filter">9.4. 客户端请求过滤器</a> </dt>
         <dt><a href="#master">9.5. Master</a> </dt>
         <dt><a href="#regionserver.arch">9.6. RegionServer</a> </dt>
         <dt><a href="#regions.arch">9.7. Regions</a> </dt>
         <dt><a href="#arch.bulk.load">9.8. Bulk Loading</a> </dt>
         <dt><a href="#arch.hdfs">9.9. HDFS</a> </dt>
       </dl>
<p>&nbsp;</p>
</div>
     <div class="section" title="9.1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch.overview"></a>9.1.&nbsp;概述</h2></div></div></div><div class="section" title="9.1.1.&nbsp;NoSQL?"><div class="titlepage"><div><div><h3 class="title"><a name="arch.overview.nosql"></a>9.1.1.&nbsp;NoSQL?</h3></div></div></div>
     <p>HBase是一种 "NoSQL" 数据库.  "NoSQL"是一个通用词表示数据库不是RDBMS ，后者支持 SQL 作为主要访问手段。有许多种 NoSQL 数据库:  BerkeleyDB 是本地 NoSQL 数据库例子, 而 HBase 是大型分布式数据库。  技术上来说,
	  HBase 更像是"数据存储(Data Store)" 多于 "数据库(Data Base)"。因为缺少很多RDBMS特性,
	  如列类型，第二索引，触发器，高级查询语言等.
	  </p>
     <p>然而, HBase 有许多特征同时支持线性化和模块化扩充。  HBase 集群通过增加RegionServers进行扩充。 它可以放在普通的服务器中。例如，如果集群从10个扩充到20个RegionServer，存储空间和处理容量都同时翻倍。
	  RDBMS 也能很好扩充， 但仅对一个点 - 特别是对一个单独数据库服务器的大小 - 同时，为了更好的性能，需要特殊的硬件和存储设备。  HBase 特性：
	        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
              <li class="listitem">强一致性读写:  HBase 不是 "最终一致性(eventually consistent)" 数据存储.  这让它很适合高速计数聚合类任务。</li>
              <li class="listitem">自动分片(Automatic sharding):  HBase 表通过region分布在集群中。数据增长时，region会自动分割并重新分布。</li>
              <li class="listitem"> RegionServer 自动故障转移</li>
              <li class="listitem">Hadoop/HDFS 集成:  HBase 支持本机外HDFS 作为它的分布式文件系统。</li>
              <li class="listitem">MapReduce:  HBase 通过MapReduce支持大并发处理， HBase 可以同时做源和目标.</li>
              <li class="listitem">Java 客户端 API:  HBase 支持易于使用的 Java API 进行编程访问.</li>
              <li class="listitem">Thrift/REST API:  HBase 也支持Thrift 和 REST 作为非Java 前端.</li>
              <li class="listitem">Block Cache 和 Bloom Filters:  对于大容量查询优化， HBase支持 Block Cache 和 Bloom Filters。</li>
              <li class="listitem">运维管理:  HBase提供内置网页用于运维视角和JMX 度量.</li></ul></div><p>
	  </p></div><div class="section" title="9.1.2.&nbsp;When Should I Use HBase?"><div class="titlepage"><div><div>
	    <h3 class="title"><a name="arch.overview.when"></a>9.1.2.&nbsp;什么时候用 HBase?</h3></div></div></div>
	  <p>HBase不适合所有问题.</p>
	  <p>首先，确信有足够多数据，如果有上亿或上千亿行数据，HBase是很好的备选。 如果只有上千或上百万行，则用传统的RDBMS可能是更好的选择。因为所有数据可以在一两个节点保存，集群其他节点可能闲置。</p>
	  <p>其次，确信可以不依赖所有RDBMS的额外特性 (e.g., 列数据类型,
	          第二索引, 事物,高级查询语言等.)  一个建立在RDBMS上应用，如不能仅通过改变一个JDBC驱动移植到HBase。相对于移植，  需考虑从RDBMS 到 HBase是一次完全的重新设计。 </p>
	  <p>第三， 确信你有足够硬件。甚至 HDFS 在小于5个数据节点时，干不好什么事情 (根据如 HDFS 块复制具有缺省值 3), 还要加上一个 NameNode.
                </p>
	  <p>HBase 能在单独的笔记本上运行良好。但这应仅当成开发配置。</p></div><div class="section" title="9.1.3.&nbsp;What Is The Difference Between HBase and Hadoop/HDFS?"><div class="titlepage"><div><div>
	    <h3 class="title"><a name="arch.overview.hbasehdfs"></a>9.1.3.&nbsp; HBase 和 Hadoop/HDFS 的区别?</h3></div></div></div>
	  <p><a class="link" href="http://hadoop.apache.org/hdfs/" target="_top">HDFS</a> 是分布式文件系统，适合保存大文件。官方宣称它并非普通用途文件系统，不提供文件的个别记录的快速查询。 
         另一方面，HBase基于HDFS且提供大表的记录快速查找(和更新)。这有时可能引起概念混乱。  HBase 内部将数据放到索引好的 "存储文件(StoreFiles)" ，以便高速查询。存储文件位于 HDFS中。参考<a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>数据模型</i></a> 和该章其他内容获取更多HBase如何归档的信息。</p></div></div>
        
     <div class="section" title="9.2.&nbsp;Catalog Tables"><div class="titlepage"><div><div>
       <h2 class="title" style="clear: both"><a name="arch.catalog"></a>9.2.&nbsp;目录表(Catalog Tables)</h2></div></div></div>
     <p>目录表 -ROOT- 和 .META. 作为 HBase 表存在。他们被HBase shell的 <code class="code">list 命令过滤掉了，</code> 但他们和其他表一样存在。 </p>
     <div class="section" title="9.2.1.&nbsp;ROOT"><div class="titlepage"><div><div><h3 class="title"><a name="arch.catalog.root"></a>9.2.1.&nbsp;ROOT</h3></div></div></div>
     <p>-ROOT- 保存 .META. 表存在哪里的踪迹.   -ROOT- 表结构如下: 
       </p>
     <p>Key:   
       </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">.META. region key (<code class="code">.META.,,1</code>)</li></ul></div><p>
       </p><p>Values:   
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
              <li class="listitem"><code class="code">info:regioninfo</code> (序列化.META.的 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html" target="_top">HRegionInfo</a>
               实例 )</li>
              <li class="listitem"><code class="code">info:server</code> (   保存 .META.的RegionServer的server:port)</li>
              <li class="listitem"><code class="code">info:serverstartcode</code> ( 保存 .META.的RegionServer进程的启动时间)</li></ul></div><p>
       </p></div><div class="section" title="9.2.2.&nbsp;META"><div class="titlepage"><div><div><h3 class="title"><a name="arch.catalog.meta"></a>9.2.2.&nbsp;META</h3></div></div></div>
       <p> .META. 保存系统中所有region列表。 .META.表结构如下: </p><p>Key:   
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
              <li class="listitem">Region key 格式 (<code class="code">[table],[region start key],[region id]</code>)</li></ul></div><p>
       </p><p>Values:   
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">info:regioninfo</code> (序列化.META.的 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html" target="_top">HRegionInfo</a> 实例 ) </li><li class="listitem"><code class="code">info:server</code> (   保存 .META.的RegionServer的server:port)</li><li class="listitem"><code class="code">info:serverstartcode</code> ( 保存 .META.的RegionServer进程的启动时间)</li></ul></div><p>
       </p>
            <p>当表在分割过程中，会创建额外的两列, <code class="code">info:splitA</code> 和 <code class="code">info:splitB</code> 
       代表两个女儿 region.  这两列的值同样是序列化HRegionInfo 实例.
       region最终分割完毕后，这行会删除。</p>
            <p> HRegionInfo的备注:  空 key 用于指示表的开始和结束。具有空开始键值的region是表内的首region。  如果 region 同时有空起始和结束key，说明它是表内的唯一region。 </p>
            <p>在需要编程访问(希望不要)目录元数据时，参考
         <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/Writables.html#getHRegionInfo%28byte[]%29" target="_top">Writables</a> 工具.
       </p></div><div class="section" title="9.2.3.&nbsp;Startup Sequencing"><div class="titlepage"><div><div>
         <h3 class="title"><a name="arch.catalog.startup"></a>9.2.3.&nbsp;启动时序</h3></div></div></div>
       <p> META 地址首先在ROOT 中设置。META 会更新 server 和 startcode 的值. </p>
       <p>需要 region-RegionServer 分配信息, 参考 <a class="xref" href="#regions.arch.assignment" title="9.7.2.&nbsp;Region-RegionServer Assignment">Section&nbsp;9.7.2, “Region-RegionServer 分配”</a>.
	    </p></div></div>
	    
     <div class="section" title="12.1. 客户端">
       <div class="titlepage">
         <div>
           <div>
             <h2 class="title" style="clear: both"><a name="client"></a>9.3.&nbsp;客户端</h2>
           </div>
         </div>
       </div>
       <p>HBase客户端的 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>类负责寻找相应的RegionServers来处理行。他是先查询 <code class="code">.META.</code> 和 <code class="code">-ROOT</code> 目录表。然后再确定region的位置。定位到所需要的区域后，客户端会<span class="emphasis"><em>直接</em></span> 去访问相应的region(不经过master)，发起读写请求。这些信息会缓存在客户端，这样就不用每发起一个请求就去查一下。如果一个region已经废弃(原因可能是master load balance或者RegionServer死了)，客户端就会重新进行这个步骤，决定要去访问的新的地址。 </p>
       <p> 参考 <a href="#master.runtime" title="9.5.2. Runtime Impact">Section 9.5.2, “Runtime Impact”</a> for more information about the impact of the Master on HBase Client communication. </p>
       <p>管理集群操作是经由<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html" target="_top">HBaseAdmin</a>发起的 </p>
       <div class="section" title="12.1.1. 连接">
         <div class="titlepage">
           <div>
             <div>
               <h3 class="title"><a name="client.connections"></a>9.3.1.&nbsp;连接</h3>
             </div>
           </div>
         </div>
         <p>关于连接的配置信息，参见<a class="xref" href="#client_dependencies" title="3.7. 连接HBase集群的客户端配置和依赖">Section&nbsp;3.7, “连接HBase集群的客户端配置和依赖”</a>. </p>
         <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>不是线程安全的。建议使用同一个<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration" target="_top">HBaseConfiguration</a>实例来创建HTable实例。这样可以共享ZooKeeper和socket实例。例如，最好这样做： </p>
         <pre class="programlisting">HBaseConfiguration conf = HBaseConfiguration.create();
HTable table1 = new HTable(conf, "myTable");
HTable table2 = new HTable(conf, "myTable");</pre>
         <p> 而不是这样： </p>
         <pre class="programlisting">HBaseConfiguration conf1 = HBaseConfiguration.create();
HTable table1 = new HTable(conf1, "myTable");
HBaseConfiguration conf2 = HBaseConfiguration.create();
HTable table2 = new HTable(conf2, "myTable");</pre>
         <p> 如果你想知道的更多的关于HBase客户端connection的知识，可以参照： <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnectionManager.html" target="_top">HConnectionManager</a>. </p>
         <div>
           <div>
             <div>
               <h4>9.3.1.1. 连接池 </h4>
             </div>
           </div>
         </div>
         <p>对需要高端多线程访问的应用 (如网页服务器或应用服务器需要在一个JVM服务很多应用线程)，参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTablePool.html" target="_top">HTablePool</a>.</p>
<p>&nbsp;</p>
       </div>
       <div class="section" title="12.1.2. 写缓冲和批量操作">
         <div class="titlepage">
           <div>
             <div>
               <h3 class="title"><a name="client.writebuffer"></a>9.3.2.&nbsp;写缓冲和批量操作 </h3>
             </div>
           </div>
         </div>
         <p>若关闭了<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>中的 <a class="xref" href="#perf.hbase.client.autoflush" title="13.6.1. AutoFlush">Section&nbsp;11.10.4, “AutoFlush”</a>，<code class="classname">Put</code>操作会在写缓冲填满的时候向RegionServer发起请求。默认情况下，写缓冲是2MB.在Htable被废弃之前，要调用<code class="methodname">close()</code>, <code class="methodname">flushCommits()</code>操作，这样写缓冲就不会丢失。 </p>
         <p>要想更好的细粒度控制 <code class="classname">Put</code>或<code class="classname">Delete</code>的批量操作，可以参考Htable中的<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29" target="_top">batch</a> 方法. </p>
         <div title="9.3.3. External Clients">
           <div>
             <div>
               <div>
                 <h3>9.3.3. 外部客户端</h3>
               </div>
             </div>
           </div>
           <p>关于非Java客户端和定制协议信息，在 <a href="#external_apis" title="Chapter 10. External APIs">Chapter 10, <em>外部 API</em></a></p>
         </div>
         <div title="9.3.4. RowLocks">
           <div>
             <div>
               <div>
                 <h3><a name="client.rowlocks"></a>9.3.4. 行锁</h3>
               </div>
             </div>
           </div>
           <p><a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#lockRow%28byte[]%29" target="_top">行锁</a> 在客户端 API中仍然存在， <em>但是</em> 不鼓励使用，因为管理不好，会锁定整个RegionServer.</p>
           <p>这里是优秀ticket <a href="https://issues.apache.org/jira/browse/HBASE-2332" target="_top">HBASE-2332</a> 从终端移除该特性。</p>
         </div>
<p>&nbsp;</p>
       </div>
       
       <div class="section" title="9.4.&nbsp;Client Request Filters"><div class="titlepage"><div><div>
         <h2 class="title" style="clear: both"><a name="client.filter"></a>9.4.&nbsp;客户端请求过滤器</h2></div></div></div>
       <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a> 和 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a> 实例可以用 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/Filter.html" target="_top">filters</a> 配置，以应用于 RegionServer. 
      </p>
       <p>过滤器可能会搞混，因为有很多类型的过滤器， 最好通过理解过滤器功能组来了解他们。</p><div class="section" title="9.4.1.&nbsp;Structural"><div class="titlepage"><div><div>
         <h3 class="title"><a name="client.filter.structural"></a>9.4.1.&nbsp;结构(Structural)过滤器</h3></div></div></div>
       <p>结构过滤器包含其他过滤器</p><div class="section" title="9.4.1.1.&nbsp;FilterList"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.structural.fl"></a>9.4.1.1.&nbsp;FilterList</h4></div></div></div>
       <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FilterList.html" target="_top">FilterList</a>
          代表一个过滤器列表，过滤器间具有 <code class="code">FilterList.Operator.MUST_PASS_ALL</code> 或 
          <code class="code">FilterList.Operator.MUST_PASS_ONE</code> 关系。下面示例展示两个过滤器的'或'关系(检查同一属性的'my value' 或'my other value' ).
</p><pre class="programlisting">FilterList list = new FilterList(FilterList.Operator.MUST_PASS_ONE);
SingleColumnValueFilter filter1 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
list.add(filter1);
SingleColumnValueFilter filter2 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my other value")
	);
list.add(filter2);
scan.setFilter(list);
</pre><p>
          </p></div></div><div class="section" title="9.4.2.&nbsp;Column Value"><div class="titlepage"><div><div>
            <h3 class="title"><a name="client.filter.cv"></a>9.4.2.&nbsp;列值</h3></div></div></div><div class="section" title="9.4.2.1.&nbsp;SingleColumnValueFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cv.scvf"></a>9.4.2.1.&nbsp;SingleColumnValueFilter</h4></div></div></div>
            <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html" target="_top">SingleColumnValueFilter</a>
          用于测试列值相等 (<code class="code"><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/CompareFilter.CompareOp.html" target="_top">CompareOp.EQUAL</a>
          </code>), 不等 (<code class="code">CompareOp.NOT_EQUAL</code>),或范围
          (e.g., <code class="code">CompareOp.GREATER</code>).  下面示例检查列值和字符串'my value' 相等...
</p><pre class="programlisting">SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
scan.setFilter(filter);
</pre><p>
          </p></div></div><div class="section" title="9.4.3.&nbsp;Column Value Comparators"><div class="titlepage"><div><div>
            <h3 class="title"><a name="client.filter.cvp"></a>9.4.3.&nbsp;列值比较器</h3></div></div></div>
          <p>过滤器包内有好几种比较器类需要特别提及。这些比较器和其他过滤器一起使用, 如  <a class="xref" href="#client.filter.cv.scvf" title="9.4.2.1.&nbsp;SingleColumnValueFilter">Section&nbsp;9.4.2.1, “SingleColumnValueFilter”</a>.
        </p><div class="section" title="9.4.3.1.&nbsp;RegexStringComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.rcs"></a>9.4.3.1.&nbsp;RegexStringComparator</h4></div></div></div>
        <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RegexStringComparator.html" target="_top">RegexStringComparator</a>
          支持值比较的正则表达式 。</p><pre class="programlisting">RegexStringComparator comp = new RegexStringComparator("my.");   // any value that starts with 'my'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</pre>
          <p>
          参考 Oracle JavaDoc 了解 <a class="link" href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_top">supported RegEx patterns in Java</a>. 
          </p></div><div class="section" title="9.4.3.2.&nbsp;SubstringComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.rcs"></a>9.4.3.2.&nbsp;SubstringComparator</h4></div></div></div>
          <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SubstringComparator.html" target="_top">SubstringComparator</a>
          用于检测一个子串是否存在于值中。大小写不敏感。</p><pre class="programlisting">SubstringComparator comp = new SubstringComparator("y val");   // looking for 'my value'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</pre></div><div class="section" title="9.4.3.3.&nbsp;BinaryPrefixComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.bfp"></a>9.4.3.3.&nbsp;BinaryPrefixComparator</h4></div></div></div>
<p>参考 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryPrefixComparator.html" target="_top">BinaryPrefixComparator</a>.</p></div><div class="section" title="9.4.3.4.&nbsp;BinaryComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.bc"></a>9.4.3.4.&nbsp;BinaryComparator</h4></div></div></div>
<p>参考 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryComparator.html" target="_top">BinaryComparator</a>.</p></div></div><div class="section" title="9.4.4.&nbsp;KeyValue Metadata"><div class="titlepage"><div><div>
  <h3 class="title"><a name="client.filter.kvm"></a>9.4.4.&nbsp;键值元数据</h3></div></div></div>
<p>由于HBase 采用键值对保存内部数据，键值元数据过滤器评估一行的键是否存在(如 ColumnFamily:Column qualifiers)
        , 对应前节所述值的情况。
        </p><div class="section" title="9.4.4.1.&nbsp;FamilyFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.ff"></a>9.4.4.1.&nbsp;FamilyFilter</h4></div></div></div>
        <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FamilyFilter.html" target="_top">FamilyFilter</a> 用于过滤列族。  通常，在Scan中选择ColumnFamilie优于在过滤器中做。</p></div><div class="section" title="9.4.4.2.&nbsp;QualifierFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.qf"></a>9.4.4.2.&nbsp;QualifierFilter</h4></div></div></div>
        <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/QualifierFilter.html" target="_top">QualifierFilter</a> 用于基于列名(即 Qualifier)过滤.
          </p></div><div class="section" title="9.4.4.3.&nbsp;ColumnPrefixFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.cpf"></a>9.4.4.3.&nbsp;ColumnPrefixFilter</h4></div></div></div>
          <p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.html" target="_top">ColumnPrefixFilter</a> 可基于列名(即Qualifier)前缀过滤。</p><p>A ColumnPrefixFilter seeks ahead to the first column matching the prefix in each row and for each involved column family. It can be used to efficiently
	 	  get a subset of the columns in very wide rows.
	      </p><p>Note: The same column qualifier can be used in different column families. This filter returns all matching columns.
          </p><p>Example: Find all columns in a row and family that start with "abc"
</p><pre class="programlisting">HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] prefix = Bytes.toBytes("abc");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnPrefixFilter(prefix);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</pre><p>
</p></div><div class="section" title="9.4.4.4.&nbsp;MultipleColumnPrefixFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.mcpf"></a>9.4.4.4.&nbsp;MultipleColumnPrefixFilter</h4></div></div></div>
<p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.html" target="_top">MultipleColumnPrefixFilter</a> 和 ColumnPrefixFilter 行为差不多，但可以指定多个前缀。</p><p>Like ColumnPrefixFilter, MultipleColumnPrefixFilter efficiently seeks ahead to the first column matching the lowest prefix and also seeks past ranges of columns between prefixes.
	      It can be used to efficiently get discontinuous sets of columns from very wide rows.
		  </p><p>Example: Find all columns in a row and family that start with "abc" or "xyz"
</p><pre class="programlisting">HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[][] prefixes = new byte[][] {Bytes.toBytes("abc"), Bytes.toBytes("xyz")};
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new MultipleColumnPrefixFilter(prefixes);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</pre><p>
</p></div><div class="section" title="9.4.4.5.&nbsp;ColumnRangeFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.crf "></a>9.4.4.5.&nbsp;ColumnRangeFilter</h4></div></div></div>
<p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnRangeFilter.html" target="_top">ColumnRangeFilter</a> 可以进行高效内部扫描。</p><p>A ColumnRangeFilter can seek ahead to the first matching column for each involved column family. It can be used to efficiently
			get a 'slice' of the columns of a very wide row.
			 i.e. you have a million columns in a row but you only want to look at columns bbbb-bbdd.
            </p><p>Note: The same column qualifier can be used in different column families. This filter returns all matching columns.
            </p><p>Example: Find all columns in a row and family between "bbbb" (inclusive) and "bbdd" (inclusive)
</p><pre class="programlisting">HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] startColumn = Bytes.toBytes("bbbb");
byte[] endColumn = Bytes.toBytes("bbdd");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnRangeFilter(startColumn, true, endColumn, true);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</pre><p>
</p>
<p>Note:   HBase 0.92 引入</p></div></div><div class="section" title="9.4.5.&nbsp;RowKey"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.row"></a>9.4.5.&nbsp;RowKey</h3></div></div></div><div class="section" title="9.4.5.1.&nbsp;RowFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.row.rf"></a>9.4.5.1.&nbsp;RowFilter</h4></div></div></div>
<p>通常认为行选择时Scan采用 startRow/stopRow 方法比较好。然而 
          <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RowFilter.html" target="_top">RowFilter</a> 也可以用。</p></div></div><div class="section" title="9.4.6.&nbsp;Utility"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.utility"></a>9.4.6.&nbsp;Utility</h3></div></div></div><div class="section" title="9.4.6.1.&nbsp;FirstKeyOnlyFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.utility.fkof"></a>9.4.6.1.&nbsp;FirstKeyOnlyFilter</h4></div></div></div><p>This is primarily used for rowcount jobs.  
          参考 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html" target="_top">FirstKeyOnlyFilter</a>.</p></div></div></div>
       
       <div class="section" title="9.5.&nbsp;Master"><div class="titlepage"><div><div>
         <h2 class="title" style="clear: both"><a name="master"></a>9.5.&nbsp;主服务器</h2></div></div></div><p><code class="code">HMaster</code> is the implementation of the Master Server.  The Master server
       is responsible for monitoring all RegionServer instances in the cluster, and is
       the interface for all metadata changes.  In a distributed cluster, the Master typically runs on the <a class="xref" href="#arch.hdfs.nn" title="9.9.1.&nbsp;NameNode">Section&nbsp;9.9.1, “NameNode”</a>.
       </p><div class="section" title="9.5.1.&nbsp;Startup Behavior"><div class="titlepage"><div><div><h3 class="title"><a name="master.startup"></a>9.5.1.&nbsp;Startup Behavior</h3></div></div></div><p>If run in a multi-Master environment, all Masters compete to run the cluster.  If the active
         Master loses it's lease in ZooKeeper (or the Master shuts down), then then the remaining Masters jostle to 
         take over the Master role.
         </p></div><div class="section" title="9.5.2.&nbsp;Runtime Impact"><div class="titlepage"><div><div><h3 class="title"><a name="master.runtime"></a>9.5.2.&nbsp;Runtime Impact</h3></div></div></div><p>A common dist-list question is what happens to an HBase cluster when the Master goes down.  Because the
         HBase client talks directly to the RegionServers, the cluster can still function in a "steady 
         state."  Additionally, per <a class="xref" href="#arch.catalog" title="9.2.&nbsp;Catalog Tables">Section&nbsp;9.2, “Catalog Tables”</a> ROOT and META exist as HBase tables (i.e., are
         not resident in the Master).  However, the Master controls critical functions such as RegionServer failover and 
         completing region splits.  So while the cluster can still run <span class="emphasis"><em>for a time</em></span> without the Master, 
         the Master should be restarted as soon as possible.     
         </p></div><div class="section" title="9.5.3.&nbsp;Interface"><div class="titlepage"><div><div><h3 class="title"><a name="master.api"></a>9.5.3.&nbsp;Interface</h3></div></div></div><p>The methods exposed by <code class="code">HMasterInterface</code> are primarily metadata-oriented methods:
         </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Table (createTable, modifyTable, removeTable, enable, disable)
            </li><li class="listitem">ColumnFamily (addColumn, modifyColumn, removeColumn) 
            </li><li class="listitem">Region (move, assign, unassign)
            </li></ul></div><p>
         For example, when the <code class="code">HBaseAdmin</code> method <code class="code">disableTable</code> is invoked, it is serviced by the Master server. 
         </p></div><div class="section" title="9.5.4.&nbsp;Processes"><div class="titlepage"><div><div>
           <h3 class="title"><a name="master.processes"></a>9.5.4.&nbsp;进程</h3></div></div></div>
         <p> Master 后台运行几种线程: </p><div class="section" title="9.5.4.1.&nbsp;LoadBalancer"><div class="titlepage"><div><div><h4 class="title"><a name="master.processes.loadbalancer"></a>9.5.4.1.&nbsp;LoadBalancer</h4></div></div></div><p>Periodically, and when there are not any regions in transition,
             a load balancer will run and move regions around to balance cluster load.
             参考 <a class="xref" href="#balancer_config" title="2.8.3.1.&nbsp;Balancer">Section&nbsp;2.8.3.1, “Balancer”</a> for configuring this property.</p><p>参考 <a class="xref" href="#regions.arch.assignment" title="9.7.2.&nbsp;Region-RegionServer Assignment">Section&nbsp;9.7.2, “Region-RegionServer Assignment”</a> for more information on region assignment.
             </p></div><div class="section" title="9.5.4.2.&nbsp;CatalogJanitor"><div class="titlepage"><div><div><h4 class="title"><a name="master.processes.catalog"></a>9.5.4.2.&nbsp;CatalogJanitor</h4></div></div></div><p>Periodically checks and cleans up the .META. table.  参考 <a class="xref" href="#arch.catalog.meta" title="9.2.2.&nbsp;META">Section&nbsp;9.2.2, “META”</a> for more information on META.</p></div></div></div>
             
        
        <div class="section" title="9.6.&nbsp;RegionServer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="regionserver.arch"></a>9.6.&nbsp;RegionServer</h2></div></div></div><p><code class="code">HRegionServer</code> is the RegionServer implementation.  It is responsible for serving and managing regions.
       In a distributed cluster, a RegionServer runs on a <a class="xref" href="#arch.hdfs.dn" title="9.9.2.&nbsp;DataNode">Section&nbsp;9.9.2, “DataNode”</a>.  
       </p><div class="section" title="9.6.1.&nbsp;Interface"><div class="titlepage"><div><div>
         <h3 class="title"><a name="regionserver.arch.api"></a>9.6.1.&nbsp;接口</h3></div></div></div><p>The methods exposed by <code class="code">HRegionRegionInterface</code> contain both data-oriented and region-maintenance methods:
         </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Data (get, put, delete, next, etc.)
            </li><li class="listitem">Region (splitRegion, compactRegion, etc.)  
            </li></ul></div><p>
         For example, when the <code class="code">HBaseAdmin</code> method <code class="code">majorCompact</code> is invoked on a table, the client is actually iterating through
         all regions for the specified table and requesting a major compaction directly to each region. 
         </p></div><div class="section" title="9.6.2.&nbsp;Processes"><div class="titlepage"><div><div>
           <h3 class="title"><a name="regionserver.arch.processes"></a>9.6.2.&nbsp;进程</h3></div></div></div>
         <p>RegionServer 后台运行几种线程:</p><div class="section" title="9.6.2.1.&nbsp;CompactSplitThread"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.compactsplit"></a>9.6.2.1.&nbsp;CompactSplitThread</h4></div></div></div>
           <p>检查分割并处理最小紧缩。</p></div><div class="section" title="9.6.2.2.&nbsp;MajorCompactionChecker"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.majorcompact"></a>9.6.2.2.&nbsp;MajorCompactionChecker</h4></div></div></div>
           <p>检查主紧缩。</p></div><div class="section" title="9.6.2.3.&nbsp;MemStoreFlusher"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.memstore"></a>9.6.2.3.&nbsp;MemStoreFlusher</h4></div></div></div>
           <p>周期将写到内存存储的内容刷到文件存储。</p></div><div class="section" title="9.6.2.4.&nbsp;LogRoller"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.log"></a>9.6.2.4.&nbsp;LogRoller</h4></div></div></div>
           <p>周期检查RegionServer 的 HLog.</p></div></div><div class="section" title="9.6.3.&nbsp;Coprocessors"><div class="titlepage"><div><div>
             <h3 class="title"><a name="coprocessors"></a>9.6.3.&nbsp;协处理器</h3></div></div></div>
           <p>协处理器在0.92版添加。 有一个详细帖子 <a class="link" href="https://blogs.apache.org/hbase/entry/coprocessor_introduction" target="_top">Blog Overview of CoProcessors</a>
         供参考。文档最终会放到本参考手册，但该blog是当前能获取的大部分信息。</p></div><div class="section" title="9.6.4.&nbsp;Block Cache"><div class="titlepage"><div><div>
           <h3 class="title"><a name="block.cache"></a>9.6.4.&nbsp;块缓存</h3></div></div></div><div class="section" title="9.6.4.1.&nbsp;Design"><div class="titlepage"><div><div>
             <h4 class="title"><a name="block.cache.design"></a>9.6.4.1.&nbsp;设计</h4></div></div></div><p>The Block Cache is an LRU cache that contains three levels of block priority to allow for scan-resistance and in-memory ColumnFamilies:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Single access priority: The first time a block is loaded from HDFS it normally has this priority and it will be part of the first group to be considered
            during evictions. The advantage is that scanned blocks are more likely to get evicted than blocks that are getting more usage.
            </li><li class="listitem">Mutli access priority: If a block in the previous priority group is accessed again, it upgrades to this priority. It is thus part of the second group
            considered during evictions.
            </li><li class="listitem">In-memory access priority: If the block's family was configured to be "in-memory", it will be part of this priority disregarding the number of times it
            was accessed. Catalog tables are configured like this. This group is the last one considered during evictions.
            </li></ul></div><p>
        For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/LruBlockCache.html" target="_top">LruBlockCache source</a>
        </p></div><div class="section" title="9.6.4.2.&nbsp;Usage"><div class="titlepage"><div><div>
          <h4 class="title"><a name="block.cache.usage"></a>9.6.4.2.&nbsp;使用</h4></div></div></div><p>Block caching is enabled by default for all the user tables which means that any read operation will load the LRU cache. This might be good for a large number of use cases,
        but further tunings are usually required in order to achieve better performance. An important concept is the
        <a class="link" href="http://en.wikipedia.org/wiki/Working_set_size" target="_top">working set size</a>, or WSS, which is: "the amount of memory needed to compute the answer to a problem".
        For a website, this would be the data that's needed to answer the queries over a short amount of time.
        </p><p>The way to calculate how much memory is available in HBase for caching is:
        </p><pre class="programlisting">            number of region servers * heap size * hfile.block.cache.size * 0.85
        </pre><p>The default value for the block cache is 0.25 which represents 25% of the available heap. The last value (85%) is the default acceptable loading factor in the LRU cache after
        which eviction is started. The reason it is included in this equation is that it would be unrealistic to say that it is possible to use 100% of the available memory since this would
        make the process blocking from the point where it loads new blocks. Here are some examples:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">One region server with the default heap size (1GB) and the default block cache size will have 217MB of block cache available.
            </li><li class="listitem">20 region servers with the heap size set to 8GB and a default block cache size will have 34GB of block cache.
            </li><li class="listitem">100 region servers with the heap size set to 24GB and a block cache size of 0.5 will have about 1TB of block cache.
            </li></ul></div><p>Your data isn't the only resident of the block cache, here are others that you may have to take into account:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Catalog tables: The -ROOT- and .META. tables are forced into the block cache and have the in-memory priority which means that they are harder to evict. The former never uses
            more than a few hundreds of bytes while the latter can occupy a few MBs (depending on the number of regions).
            </li><li class="listitem">HFiles indexes: HFile is the file format that HBase uses to store data in HDFS and it contains a multi-layered index in order seek to the data without having to read the whole file.
            The size of those indexes is a factor of the block size (64KB by default), the size of your keys and the amount of data you are storing. For big data sets it's not unusual to see numbers around
            1GB per region server, although not all of it will be in cache because the LRU will evict indexes that aren't used.
            </li><li class="listitem">Keys: Taking into account only the values that are being stored is missing half the picture since every value is stored along with its keys
            (row key, family, qualifier, and timestamp). 参考 <a class="xref" href="#keysize" title="6.3.2.&nbsp;Try to minimize row and column sizes">Section&nbsp;6.3.2, “Try to minimize row and column sizes”</a>.
            </li><li class="listitem">Bloom filters: Just like the HFile indexes, those data structures (when enabled) are stored in the LRU.
            </li></ul></div><p>Currently the recommended way to measure HFile indexes and bloom filters sizes is to look at the region server web UI and checkout the relevant metrics. For keys,
        sampling can be done by using the HFile command line tool and look for the average key size metric.
        </p><p>It's generally bad to use block caching when the WSS doesn't fit in memory. This is the case when you have for example 40GB available across all your region servers' block caches
        but you need to process 1TB of data. One of the reasons is that the churn generated by the evictions will trigger more garbage collections unnecessarily. Here are two use cases:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Fully random reading pattern: This is a case where you almost never access the same row twice within a short amount of time such that the chance of hitting a cached block is close
            to 0. Setting block caching on such a table is a waste of memory and CPU cycles, more so that it will generate more garbage to pick up by the JVM. For more information on monitoring GC,
            see <a class="xref" href="#trouble.log.gc" title="12.2.3.&nbsp;JVM Garbage Collection Logs">Section&nbsp;12.2.3, “JVM Garbage Collection Logs”</a>.
            </li><li class="listitem">Mapping a table: In a typical MapReduce job that takes a table in input, every row will be read only once so there's no need to put them into the block cache. The Scan object has
            the option of turning this off via the setCaching method (set it to false). You can still keep block caching turned on on this table if you need fast random read access. An example would be
            counting the number of rows in a table that serves live traffic, caching every block of that table would create massive churn and would surely evict data that's currently in use.
            </li></ul></div></div></div><div class="section" title="9.6.5.&nbsp;Write Ahead Log (WAL)"><div class="titlepage"><div><div><h3 class="title"><a name="wal"></a>9.6.5.&nbsp;预写日志 (WAL)</h3></div></div></div><div class="section" title="9.6.5.1.&nbsp;Purpose"><div class="titlepage"><div><div><h4 class="title"><a name="purpose.wal"></a>9.6.5.1.&nbsp;Purpose</h4></div></div></div>
            <p>每个RegionServer会将更新(Puts, Deletes) 先记录到预写日志中(WAL)，然后将其更新在<a class="xref" href="#store" title="12.3.4. Store">Section&nbsp;9.7.5, “Store”</a>的<a class="xref" href="#store.memstore" title="12.3.4.1. MemStore">Section&nbsp;9.7.5.1, “MemStore”</a>里面。这样就保证了HBase的写的可靠性。如果没有WAL,当RegionServer宕掉的时候，MemStore还没有flush，StoreFile还没有保存，数据就会丢失。<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/wal/HLog.html" target="_top">HLog</a> 是HBase的一个WAL实现，一个RegionServer有一个HLog实例。 </p>
WAL 保存在HDFS 的 <code class="filename">/hbase/.logs/</code> 里面，每个region一个文件。
<p> 要想知道更多的信息，可以访问维基百科 <a class="link" href="http://en.wikipedia.org/wiki/Write-ahead_logging" target="_top">Write-Ahead Log</a> 的文章. </p>
<p>&nbsp;</p></div><div class="section" title="9.6.5.2.&nbsp;WAL Flushing"><div class="titlepage"><div><div><h4 class="title"><a name="wal_flush"></a>9.6.5.2.&nbsp;WAL Flushing</h4></div></div></div><p>TODO (describe).
          </p></div><div class="section" title="9.6.5.3.&nbsp;WAL Splitting"><div class="titlepage"><div><div><h4 class="title"><a name="wal_splitting"></a>9.6.5.3.&nbsp;WAL Splitting</h4></div></div></div><div class="section" title="9.6.5.3.1.&nbsp;How edits are recovered from a crashed RegionServer"><div class="titlepage"><div><div><h5 class="title"><a name="d1934e5412"></a>9.6.5.3.1.&nbsp;当RegionServer宕掉的时候，如何恢复</h5>
          </div></div></div><p>When a RegionServer crashes, it will lose its ephemeral lease in
         ZooKeeper...TODO</p></div><div class="section" title="9.6.5.3.2.&nbsp;hbase.hlog.split.skip.errors"><div class="titlepage"><div><div><h5 class="title"><a name="d1934e5417"></a>9.6.5.3.2.&nbsp;<code class="varname">hbase.hlog.split.skip.errors</code></h5></div></div></div>
           <p>默认设置为 <code class="constant">true</code>,在split执行中发生的任何错误会被记录，有问题的WAL会被移动到HBase <code class="varname">rootdir</code>目录下的<code class="filename">.corrupt</code>目录，接着进行处理。如果设置为 <code class="constant">false</code>，异常会被抛出，split会记录错误。<sup>[<a name="d613e3262" href="#ftn.d1934e5435" class="footnote">23</a>]</sup></p>
         </div><div class="section" title="9.6.5.3.3.&nbsp;How EOFExceptions are treated when splitting a crashed RegionServers' WALs"><div class="titlepage"><div>
           <div>
             <h5 class="title"><a name="d1934e5441"></a>9.6.5.3.3.&nbsp;如何处理一个发生在当RegionServers' WALs 分割时候的EOFExceptions异常</h5>
           </div></div></div><p>如果我们在分割日志的时候发生EOF,就是<code class="varname">hbase.hlog.split.skip.errors</code>设置为 <code class="constant">false</code>，我们也会进行处理。一个EOF会发生在一行一行读取Log，但是Log中最后一行似乎只写了一半就停止了。如果在处理过程中发生了EOF，我们还会继续处理，除非这个文件是要处理的最后一个文件。<sup>[<a name="d1934e5452" href="#ftn.d1934e5452" class="footnote">24</a>]</sup></p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d1934e5435" href="#d1934e5435" class="para">23</a>] </sup>参考 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2958" target="_top">HBASE-2958
            When hbase.hlog.split.skip.errors is set to false, we fail the
            split but thats it</a>. We need to do more than just fail split
            if this flag is set.</p></div><div class="footnote"><p><sup>[<a id="ftn.d1934e5452" href="#d1934e5452" class="para">24</a>] </sup>要想知道背景知识, 参见<a class="link" href="https://issues.apache.org/jira/browse/HBASE-2643" target="_top">HBASE-2643
            Figure how to deal with eof splitting logs</a></p></div></div></div>
            
        <div class="section" title="9.7.&nbsp;Regions"><div class="titlepage"><div><div>
          <h2 class="title" style="clear: both"><a name="regions.arch"></a>9.7.&nbsp;区域</h2></div></div></div>
        <p>区域是表获取和分布的基本元素，由每个列族的一个库(Store)组成。对象层级图如下：
</p><pre class="programlisting"><code class="filename">Table</code>       (HBase table)      
    <code class="filename">Region</code>       (Regions for the table)
         <code class="filename">Store</code>          (Store per ColumnFamily for each Region for the table)
              <code class="filename">MemStore</code>           (MemStore for each Store for each Region for the table)
              <code class="filename">StoreFile</code>          (StoreFiles for each Store for each Region for the table)
                    <code class="filename">Block</code>             (Blocks within a StoreFile within a Store for each Region for the table)
 </pre>
<p>
     关于HBase文件写到HDFS的描述，参考 <a class="xref" href="#trouble.namenode.hbase.objects" title="12.7.2.&nbsp;Browsing HDFS for HBase Objects">Section&nbsp;12.7.2, “浏览 HDFS的 HBase 对象”</a>.
            </p><div class="section" title="9.7.1.&nbsp;Region Size"><div class="titlepage"><div><div>
              <h3 class="title"><a name="arch.regions.size"></a>9.7.1.&nbsp;Region 大小</h3></div></div></div><p>Region的大小是一个棘手的问题，需要考量如下几个因素。 </p>
              <div class="itemizedlist">
                <ul class="itemizedlist" type="disc">
                  <li class="listitem">
                    <p>Regions是可用性和分布式的最基本单位</p>
                  </li>
                  <li class="listitem">
                    <p>HBase通过将region切分在许多机器上实现分布式。也就是说，你如果有16GB的数据，只分了2个region， 你却有20台机器，有18台就浪费了。</p>
                  </li>
                  <li class="listitem">
                    <p>region数目太多就会造成性能下降，现在比以前好多了。但是对于同样大小的数据，700个region比3000个要好。</p>
                  </li>
                  <li class="listitem">
                    <p>region数目太少就会妨碍可扩展性，降低并行能力。有的时候导致压力不够分散。这就是为什么，你向一个10节点的HBase集群导入200MB的数据，大部分的节点是idle的。</p>
                  </li>
                  <li class="listitem">
                    <p>RegionServer中1个region和10个region索引需要的内存量没有太多的差别。</p>
                  </li>
                </ul>
              </div>
              <p>最好是使用默认的配置，可以把热的表配小一点(或者受到split热点的region把压力分散到集群中)。如果你的cell的大小比较大(100KB或更大)，就可以把region的大小调到1GB。</p>
              <p>参考 <a class="xref" href="#bigger.regions" title="2.8.2.6.&nbsp;Bigger Regions">Section&nbsp;2.5.2.6, “更大区域”</a> 获取配置更多信息.
      </p></div><div class="section" title="9.7.2.&nbsp;Region-RegionServer Assignment"><div class="titlepage"><div><div>
        <h3 class="title"><a name="regions.arch.assignment"></a>9.7.2.&nbsp;区域-区域服务器分配</h3></div></div></div>
      <p>本节描述区域如何分配到区域服务器。</p><div class="section" title="9.7.2.1.&nbsp;Startup"><div class="titlepage"><div><div>
        <h4 class="title"><a name="regions.arch.assignment.startup"></a>9.7.2.1.&nbsp;启动</h4></div></div></div>
      <p>当HBase启动时，区域分配如下(短版本):
            </p><div class="orderedlist"><ol class="orderedlist" type="1">
              <li class="listitem">启动时主服务器调用<code class="code">AssignmentManager</code>. </li>
              <li class="listitem"><code class="code">AssignmentManager</code> 在META 中查找已经存在的区域分配。
              </li>
              <li class="listitem">如果区域分配还有效(如 RegionServer 还在线)
                ，那么分配继续保持。</li>
              <li class="listitem">如果区域分配失效，<code class="code">LoadBalancerFactory</code> 被调用来分配区域。 <code class="code">DefaultLoadBalancer</code> 将随机分配区域到RegionServer.
              </li>
              <li class="listitem">META 随 RegionServer 分配更新(如果需要) ， RegionServer 启动区域开启代码(RegionServer 启动时进程) </li></ol></div><p>
          </p></div><div class="section" title="9.7.2.2.&nbsp;Failover"><div class="titlepage"><div><div>
            <h4 class="title"><a name="regions.arch.assignment.failover"></a>9.7.2.2.&nbsp;故障转移</h4></div></div></div>
          <p>当区域服务器出故障退出时 (短版本):
            </p><div class="orderedlist"><ol class="orderedlist" type="1">
              <li class="listitem">区域立即不可获取，因为区域服务器退出。</li>
              <li class="listitem">主服务器会检测到区域服务器退出。</li>
              <li class="listitem">区域分配会失效并被重新分配，如同启动时序。</li></ol></div><p>
           </p></div><div class="section" title="9.7.2.3.&nbsp;Region Load Balancing"><div class="titlepage"><div><div>
             <h4 class="title"><a name="regions.arch.balancer"></a>9.7.2.3.&nbsp;区域负载均衡</h4></div></div></div>
           <p>
          区域可以定期移动，见<a class="xref" href="#master.processes.loadbalancer" title="9.5.4.1.&nbsp;LoadBalancer"> Section&nbsp;9.5.4.1, “LoadBalancer”</a>.
          </p></div></div><div class="section" title="9.7.3.&nbsp;Region-RegionServer Locality"><div class="titlepage"><div><div>
            <h3 class="title"><a name="regions.arch.locality"></a>9.7.3.&nbsp;区域-区域服务器本地化</h3></div></div></div><p>Over time, Region-RegionServer locality is achieved via HDFS block replication.
          The HDFS client does the following by default when choosing locations to write replicas:
           </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">First replica is written to local node
             </li><li class="listitem">Second replica is written to another node in same rack
             </li><li class="listitem">Third replica is written to a node in another rack (if sufficient nodes)
             </li></ol></div><p>
          Thus, HBase eventually achieves locality for a region after a flush or a compaction. 
          In a RegionServer failover situation a RegionServer may be assigned regions with non-local
          StoreFiles (because none of the replicas are local), however as new data is written
          in the region, or the table is compacted and StoreFiles are re-written, they will become "local"
          to the RegionServer.  
        </p><p>For more information, see <a class="link" href="http://hadoop.apache.org/common/docs/r0.20.205.0/hdfs_design.html#Replica+Placement%3A+The+First+Baby+Steps" target="_top">HDFS Design on Replica Placement</a>
        and also Lars George's blog on <a class="link" href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html" target="_top">HBase and HDFS locality</a>.      
        </p></div><div class="section" title="9.7.4.&nbsp;Region Splits"><div class="titlepage"><div><div>
          <h3 class="title"><a name="d1934e5583"></a>9.7.4.&nbsp;区域分割</h3></div></div></div>
        <p>区域服务器的分割操作是不可见的，因为Master不会参与其中。区域服务器切割region的步骤是，先将该region下线，然后切割，将其子region加入到META元信息中，再将他们加入到原本的区域服务器中，最后汇报Master.参见<a class="xref" href="#disable.splitting" title="3.6.6. 管理 Splitting">Section&nbsp;2.8.2.7, “管理 Splitting”</a>来手动管理切割操作(以及为何这么做)。</p><div class="section" title="9.7.4.1.&nbsp;Custom Split Policies"><div class="titlepage"><div><div>
          <h4 class="title"><a name="d1934e5590"></a>9.7.4.1.&nbsp;自定义分割策略</h4></div></div></div>
        <p>缺省分割策略可以被重写，采用自定义<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/RegionSplitPolicy.html" target="_top">RegionSplitPolicy</a> (HBase 0.94+).一般自定义分割策略应该扩展HBase的缺省分割策略: <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/ConstantSizeRegionSplitPolicy.html" target="_top">ConstantSizeRegionSplitPolicy</a>.
          </p>
        <p>策略可以HBaseConfiguration 全局使用，或基于每张表：</p><pre class="programlisting">HTableDescriptor myHtd = ...;
myHtd.setValue(HTableDescriptor.SPLIT_POLICY, MyCustomSplitPolicy.class.getName());
</pre><p>
          </p></div></div><div class="section" title="9.7.5.&nbsp;Store"><div class="titlepage"><div><div>
            <h3 class="title"><a name="store"></a>9.7.5.&nbsp;存储</h3></div></div></div>
          <p>一个存储包含了一个内存存储(MemStore)和若干个文件存储(StoreFile--HFile).一个存储可以定位到一个列族中的一个区.</p><div class="section" title="9.7.5.1.&nbsp;MemStore"><div class="titlepage"><div><div><h4 class="title"><a name="store.memstore"></a>9.7.5.1.&nbsp;MemStore</h4></div></div></div><p>MemStores是Store中的内存Store,可以进行修改操作。修改的内容是KeyValues。当flush的是，现有的memstore会生成快照，然后清空。在执行快照的时候，HBase会继续接收修改操作，保存在memstore外面，直到快照完成。</p></div><div class="section" title="9.7.5.2.&nbsp;StoreFile (HFile)"><div class="titlepage"><div><div><h4 class="title"><a name="hfile"></a>9.7.5.2.&nbsp;StoreFile (HFile)</h4></div></div></div>
          <p>文件存储是数据存在的地方。
      </p><div class="section" title="9.7.5.2.1.&nbsp;HFile Format"><div class="titlepage"><div><div><h5 class="title"><a name="d1934e5621"></a>9.7.5.2.1.&nbsp;HFile Format</h5></div></div></div>
      <p><span class="emphasis"><em>hfile</em></span>文件格式是基于<a class="link" href="http://labs.google.com/papers/bigtable.html" target="_top">BigTable [2006]</a>论文中的SSTable。构建在Hadoop的<a class="link" href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/io/file/tfile/TFile.html" target="_top">tfile</a>上面(直接使用了tfile的单元测试和压缩工具)。 Schubert Zhang 的博客<a class="link" href="http://cloudepr.blogspot.com/2009/09/hfile-block-indexed-file-format-to.html" target="_top">HFile: A Block-Indexed File Format to Store Sorted Key-Value Pairs</a>详细介绍了HBases的hfile。Matteo Bertozzi也做了详细的介绍<a class="link" href="http://th30z.blogspot.com/2011/02/hbase-io-hfile.html?spref=tw" target="_top">HBase I/O: HFile</a>。 </p>
      <p>For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFile.html" target="_top">HFile source code</a>.
          Also see <a class="xref" href="#hfilev2" title="Appendix&nbsp;E.&nbsp;HFile format version 2">Appendix&nbsp;E, <i>HFile format version 2</i></a> for information about the HFile v2 format that was included in 0.92.
          </p></div><div class="section" title="9.7.5.2.2.&nbsp;HFile Tool"><div class="titlepage"><div><div>
            <h5 class="title"><a name="hfile_tool"></a>9.7.5.2.2.&nbsp;HFile 工具</h5></div></div></div><p>要想看到hfile内容的文本化版本，你可以使用<code class="classname">org.apache.hadoop.hbase.io.hfile.HFile </code>工具。可以这样用：</p>
            <pre class="programlisting"><code class="code">$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile </code> </pre>
            <p>例如，你想看文件 <code class="filename">hdfs://10.81.47.41:9000/hbase/TEST/1418428042/DSMP/4759508618286845475</code>的内容,
              就执行如下的命令:</p>
            <pre class="programlisting"> <code class="code">$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile -v -f hdfs://10.81.47.41:9000/hbase/TEST/1418428042/DSMP/4759508618286845475 </code> </pre>
            <p>如果你没有输入-v,就仅仅能看到一个hfile的汇总信息。其他功能的用法可以看<code class="classname">HFile</code>的文档。</p>
          </div><div class="section" title="9.7.5.2.3.&nbsp;StoreFile Directory Structure on HDFS"><div class="titlepage"><div><div><h5 class="title"><a name="store.file.dir"></a>9.7.5.2.3.&nbsp;StoreFile Directory Structure on HDFS</h5></div></div></div><p>For more information of what StoreFiles look like on HDFS with respect to the directory structure, see <a class="xref" href="#trouble.namenode.hbase.objects" title="12.7.2.&nbsp;Browsing HDFS for HBase Objects">Section&nbsp;12.7.2, “Browsing HDFS for HBase Objects”</a>.
        </p></div></div><div class="section" title="9.7.5.3.&nbsp;Blocks"><div class="titlepage"><div><div><h4 class="title"><a name="hfile.blocks"></a>9.7.5.3.&nbsp;Blocks</h4></div></div></div><p>StoreFiles are composed of blocks.  The blocksize is configured on a per-ColumnFamily basis.
        </p><p>Compression happens at the block level within StoreFiles.  For more information on compression, see <a class="xref" href="#compression" title="Appendix&nbsp;C.&nbsp;Compression In HBase">Appendix&nbsp;C, <i>Compression In HBase</i></a>.
        </p><p>For more information on blocks, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFileBlock.html" target="_top">HFileBlock source code</a>.
        </p></div><div class="section" title="9.7.5.4.&nbsp;KeyValue"><div class="titlepage"><div><div><h4 class="title"><a name="keyvalue"></a>9.7.5.4.&nbsp;KeyValue</h4></div></div></div><p>The KeyValue class is the heart of data storage in HBase.  KeyValue wraps a byte array and takes offsets and lengths into passed array
         at where to start interpreting the content as KeyValue.  
        </p><p>The KeyValue format inside a byte array is:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">keylength</li><li class="listitem">valuelength</li><li class="listitem">key</li><li class="listitem">value</li></ul></div><p>
        </p><p>The Key is further decomposed as:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">rowlength</li><li class="listitem">row (i.e., the rowkey)</li><li class="listitem">columnfamilylength</li><li class="listitem">columnfamily</li><li class="listitem">columnqualifier</li><li class="listitem">timestamp</li><li class="listitem">keytype (e.g., Put, Delete, DeleteColumn, DeleteFamily)</li></ul></div><p>
        </p><p>KeyValue instances are <span class="emphasis"><em>not</em></span> split across blocks.
         For example, if there is an 8 MB KeyValue, even if the block-size is 64kb this KeyValue will be read
         in as a coherent block.  For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/KeyValue.html" target="_top">KeyValue source code</a>.
        </p><div class="section" title="9.7.5.4.1.&nbsp;Example"><div class="titlepage"><div><div><h5 class="title"><a name="keyvalue.example"></a>9.7.5.4.1.&nbsp;Example</h5></div></div></div><p>To emphasize the points above, examine what happens with two Puts for two different columns for the same row:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Put #1:  <code class="code">rowkey=row1, cf:attr1=value1</code></li><li class="listitem">Put #2:  <code class="code">rowkey=row1, cf:attr2=value2</code></li></ul></div><p>Even though these are for the same row, a KeyValue is created for each column:</p><p>Key portion for Put #1:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">rowlength <code class="code">------------&gt; 4</code></li><li class="listitem">row <code class="code">-----------------&gt; row1</code></li><li class="listitem">columnfamilylength <code class="code">---&gt; 2</code></li><li class="listitem">columnfamily <code class="code">--------&gt; cf</code></li><li class="listitem">columnqualifier <code class="code">------&gt; attr1</code></li><li class="listitem">timestamp <code class="code">-----------&gt; server time of Put</code></li><li class="listitem">keytype <code class="code">-------------&gt; Put</code></li></ul></div><p>
          </p><p>Key portion for Put #2:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">rowlength <code class="code">------------&gt; 4</code></li><li class="listitem">row <code class="code">-----------------&gt; row1</code></li><li class="listitem">columnfamilylength <code class="code">---&gt; 2</code></li><li class="listitem">columnfamily <code class="code">--------&gt; cf</code></li><li class="listitem">columnqualifier <code class="code">------&gt; attr2</code></li><li class="listitem">timestamp <code class="code">-----------&gt; server time of Put</code></li><li class="listitem">keytype <code class="code">-------------&gt; Put</code></li></ul></div><p>
           
          </p></div><p>It is critical to understand that the rowkey, ColumnFamily, and column (aka columnqualifier) are embedded within
       the KeyValue instance.  The longer these identifiers are, the bigger the KeyValue is.</p></div><div class="section" title="9.7.5.5.&nbsp;Compaction"><div class="titlepage"><div><div>
         <h4 class="title"><a name="compaction"></a>9.7.5.5.&nbsp;紧缩</h4></div></div></div>
       <p>有两种类型的紧缩：次紧缩和主紧缩。minor紧缩通常会将数个小的相邻的文件合并成一个大的。Minor不会删除打上删除标记的数据，也不会删除过期的数据，Major紧缩会删除过期的数据。有些时候minor紧缩就会将一个store中的全部文件紧缩，实际上这个时候他本身就是一个major压缩。对于一个minor紧缩是如何紧缩的，可以参见<a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/regionserver/Store.html#836" target="_top">ascii diagram in the Store source code.</a></p>
         <p>在执行一个major紧缩之后，一个store只会有一个sotrefile,通常情况下这样可以提供性能。注意：major紧缩将会将store中的数据全部重写，在一个负载很大的系统中，这个操作是很伤的。所以在大型系统中，通常会自己<a class="xref" href="#disable.splitting" title="3.6.6. 管理 Splitting">Section&nbsp;2.8.2.8, “管理 Splitting”</a>。 </p>
         <p>紧缩 <span class="emphasis"><em>不会</em></span> 进行分区合并。参考 <a class="xref" href="#ops.regionmgt.merge" title="14.2.2.&nbsp;Merge">Section&nbsp;14.2.2, “Merge”</a> 获取更多合并的信息。        </p><div class="section" title="9.7.5.5.1.&nbsp;Compaction File Selection"><div class="titlepage"><div><div><h5 class="title"><a name="compaction.file.selection"></a>9.7.5.5.1.&nbsp;Compaction File Selection</h5></div></div></div><p>To understand the core algorithm for StoreFile selection, there is some ASCII-art in the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/regionserver/Store.html#836" target="_top">Store source code</a> that 
          will serve as useful reference.  It has been copied below:
</p><pre class="programlisting">/* normal skew:
 *
 *         older ----&gt; newer
 *     _
 *    | |   _
 *    | |  | |   _
 *  --|-|- |-|- |-|---_-------_-------  minCompactSize
 *    | |  | |  | |  | |  _  | |
 *    | |  | |  | |  | | | | | |
 *    | |  | |  | |  | | | | | |
 */
</pre><p>
          Important knobs:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">hbase.store.compaction.ratio</code> Ratio used in compaction
            file selection algorithm (default 1.2f). </li><li class="listitem"><code class="code">hbase.hstore.compaction.min</code> (.90 hbase.hstore.compactionThreshold) (files) Minimum number
            of StoreFiles per Store to be selected for a compaction to occur (default 2).</li><li class="listitem"><code class="code">hbase.hstore.compaction.max</code> (files) Maximum number of StoreFiles to compact per minor compaction (default 10).</li><li class="listitem"><code class="code">hbase.hstore.compaction.min.size</code> (bytes) 
            Any StoreFile smaller than this setting with automatically be a candidate for compaction.  Defaults to 
            <code class="code">hbase.hregion.memstore.flush.size</code> (128 mb). </li><li class="listitem"><code class="code">hbase.hstore.compaction.max.size</code> (.92) (bytes) 
            Any StoreFile larger than this setting with automatically be excluded from compaction (default Long.MAX_VALUE). </li></ul></div><p>
          </p><p>The minor compaction StoreFile selection logic is size based, and selects a file for compaction when the file
           &lt;= sum(smaller_files) * <code class="code">hbase.hstore.compaction.ratio</code>.
          </p></div><div class="section" title="9.7.5.5.2.&nbsp;Minor Compaction File Selection - Example #1 (Basic Example)"><div class="titlepage"><div><div><h5 class="title"><a name="compaction.file.selection.example1"></a>9.7.5.5.2.&nbsp;Minor Compaction File Selection - Example #1 (Basic Example)</h5></div></div></div><p>This example mirrors an example from the unit test <code class="code">TestCompactSelection</code>.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">hbase.store.compaction.ratio</code> = 1.0f </li><li class="listitem"><code class="code">hbase.hstore.compaction.min</code> = 3 (files) </li><li class="listitem"><code class="code">hbase.hstore.compaction.max</code> = 5 (files) </li><li class="listitem"><code class="code">hbase.hstore.compaction.min.size</code> = 10 (bytes) </li><li class="listitem"><code class="code">hbase.hstore.compaction.max.size</code> = 1000 (bytes) </li></ul></div><p>
          The following StoreFiles exist: 100, 50, 23, 12, and 12 bytes apiece (oldest to newest).
          With the above parameters, the files that would be selected for minor compaction are 23, 12, and 12.
          </p><p>Why?
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">100 --&gt;  No, because sum(50, 23, 12, 12) * 1.0 = 97. </li><li class="listitem">50 --&gt;  No, because sum(23, 12, 12) * 1.0 = 47. </li><li class="listitem">23 --&gt;  Yes, because sum(12, 12) * 1.0 = 24. </li><li class="listitem">12 --&gt;  Yes, because the previous file has been included, and because this 
          does not exceed the the max-file limit of 5  </li><li class="listitem">12 --&gt;  Yes, because the previous file had been included, and because this 
          does not exceed the the max-file limit of 5.</li></ul></div><p>
          </p></div><div class="section" title="9.7.5.5.3.&nbsp;Minor Compaction File Selection - Example #2 (Not Enough Files To Compact)"><div class="titlepage"><div><div><h5 class="title"><a name="compaction.file.selection.example2"></a>9.7.5.5.3.&nbsp;Minor Compaction File Selection - Example #2 (Not Enough Files To Compact)</h5></div></div></div><p>This example mirrors an example from the unit test <code class="code">TestCompactSelection</code>.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">hbase.store.compaction.ratio</code> = 1.0f </li><li class="listitem"><code class="code">hbase.hstore.compaction.min</code> = 3 (files) </li><li class="listitem"><code class="code">hbase.hstore.compaction.max</code> = 5 (files) </li><li class="listitem"><code class="code">hbase.hstore.compaction.min.size</code> = 10 (bytes) </li><li class="listitem"><code class="code">hbase.hstore.compaction.max.size</code> = 1000 (bytes) </li></ul></div><p>
          </p><p>The following StoreFiles exist: 100, 25, 12, and 12 bytes apiece (oldest to newest).
          With the above parameters, the files that would be selected for minor compaction are 23, 12, and 12.         
          </p><p>Why?
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">100 --&gt; No, because sum(25, 12, 12) * 1.0 = 47</li><li class="listitem">25 --&gt;  No, because sum(12, 12) * 1.0 = 24</li><li class="listitem">12 --&gt;  No. Candidate because sum(12) * 1.0 = 12, there are only 2 files to compact and that is less than the threshold of 3</li><li class="listitem">12 --&gt;  No. Candidate because the previous StoreFile was, but there are not enough files to compact</li></ul></div><p>
          </p></div><div class="section" title="9.7.5.5.4.&nbsp;Minor Compaction File Selection - Example #3 (Limiting Files To Compact)"><div class="titlepage"><div><div><h5 class="title"><a name="compaction.file.selection.example2"></a>9.7.5.5.4.&nbsp;Minor Compaction File Selection - Example #3 (Limiting Files To Compact)</h5></div></div></div><p>This example mirrors an example from the unit test <code class="code">TestCompactSelection</code>.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">hbase.store.compaction.ratio</code> = 1.0f </li><li class="listitem"><code class="code">hbase.hstore.compaction.min</code> = 3 (files) </li><li class="listitem"><code class="code">hbase.hstore.compaction.max</code> = 5 (files) </li><li class="listitem"><code class="code">hbase.hstore.compaction.min.size</code> = 10 (bytes) </li><li class="listitem"><code class="code">hbase.hstore.compaction.max.size</code> = 1000 (bytes) </li></ul></div><p>
          The following StoreFiles exist: 7, 6, 5, 4, 3, 2, and 1 bytes apiece (oldest to newest).
          With the above parameters, the files that would be selected for minor compaction are 7, 6, 5, 4, 3.         
          </p><p>Why?
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">7 --&gt;  Yes, because sum(6, 5, 4, 3, 2, 1) * 1.0 = 21.  Also, 7 is less than the min-size</li><li class="listitem">6 --&gt;  Yes, because sum(5, 4, 3, 2, 1) * 1.0 = 15.  Also, 6 is less than the min-size. </li><li class="listitem">5 --&gt;  Yes, because sum(4, 3, 2, 1) * 1.0 = 10.  Also, 5 is less than the min-size. </li><li class="listitem">4 --&gt;  Yes, because sum(3, 2, 1) * 1.0 = 6.  Also, 4 is less than the min-size. </li><li class="listitem">3 --&gt;  Yes, because sum(2, 1) * 1.0 = 3.  Also, 3 is less than the min-size. </li><li class="listitem">2 --&gt;  No.  Candidate because previous file was selected and 2 is less than the min-size, but the max-number of files to compact has been reached. </li><li class="listitem">1 --&gt;  No.  Candidate because previous file was selected and 1 is less than the min-size, but max-number of files to compact has been reached. </li></ul></div><p>
          </p></div><div class="section" title="9.7.5.5.5.&nbsp;Impact of Key Configuration Options"><div class="titlepage"><div><div><h5 class="title"><a name="compaction.config.impact"></a>9.7.5.5.5.&nbsp;Impact of Key Configuration Options</h5></div></div></div><p><code class="code">hbase.store.compaction.ratio</code>.  A large ratio (e.g., 10) will produce a single giant file.  Conversely, a value of .25 will
          produce behavior similar to the BigTable compaction algorithm - resulting in 4 StoreFiles.
          </p><p><code class="code">hbase.hstore.compaction.min.size</code>.  Because
          this limit represents the "automatic include" limit for all StoreFiles smaller than this value, this value may need to
          be adjusted downwards in write-heavy environments where many 1 or 2 mb StoreFiles are being flushed, because every file
          will be targeted for compaction and the resulting files may still be under the min-size and require further compaction, etc. 
          </p></div></div></div><div class="section" title="9.7.6.&nbsp;Bloom Filters"><div class="titlepage"><div><div></div></div></div><div class="section" title="9.7.6.1.&nbsp;Bloom StoreFile footprint"></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d1934e6050" href="#d1934e6050" class="para">25</a>] </sup>For description of the development process -- why static blooms
        rather than dynamic -- and for an overview of the unique properties
        that pertain to blooms in HBase, as well as possible future
        directions, see the <span class="emphasis"><em>Development Process</em></span> section
        of the document <a class="link" href="https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf" target="_top">BloomFilters
        in HBase</a> attached to <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1200" target="_top">HBase-1200</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.d1934e6062" href="#d1934e6062" class="para">26</a>] </sup>The bloom filters described here are actually version two of
        blooms in HBase. In versions up to 0.19.x, HBase had a dynamic bloom
        option based on work done by the <a class="link" href="http://www.one-lab.org" target="_top">European Commission One-Lab
        Project 034819</a>. The core of the HBase bloom work was later
        pulled up into Hadoop to implement org.apache.hadoop.io.BloomMapFile.
        Version 1 of HBase blooms never worked that well. Version 2 is a
        rewrite from scratch though again it starts with the one-lab
        work.</p></div></div></div>
        
        <div class="section" title="9.8.&nbsp;Bulk Loading"><div class="titlepage"><div><div>
          <h2 class="title" style="clear: both"><a name="arch.bulk.load"></a>9.8.&nbsp;批量装载(Bulk Loading)</h2></div></div></div><div class="section" title="9.8.1.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="arch.bulk.load.overview"></a>9.8.1.&nbsp;概述</h3></div></div></div>
          <p>
        HBase 有好几种方法将数据装载到表。最直接的方式即可以通过MapReduce任务，也可以通过普通客户端API。但是这都不是高效方法。</p>
          <p>
        批量装载特性采用 MapReduce 任务，将表数据输出为HBase的内部数据格式，然后可以将产生的存储文件直接装载到运行的集群中。批量装载比简单使用 HBase API 消耗更少的CPU和网络资源。</p></div><div class="section" title="9.8.2.&nbsp;Bulk Load Architecture"><div class="titlepage"><div><div>
          <h3 class="title"><a name="arch.bulk.load.arch"></a>9.8.2.&nbsp;批量装载架构</h3></div></div></div>
        <p>
        HBase 批量装载过程包含两个主要步骤。</p><div class="section" title="9.8.2.1.&nbsp;Preparing data via a MapReduce job"><div class="titlepage"><div><div>
          <h4 class="title"><a name="arch.bulk.load.prep"></a>9.8.2.1.&nbsp;通过MapReduce 任务准备数据</h4></div></div></div>
        <p>
          批量装载第一步，从MapReduce任务通过<code class="code">HFileOutputFormat</code>产生HBase数据文件(StoreFiles) 。输出数据为HBase的内部数据格式，以便随后装载到集群更高效。</p>
        <p>
          为了处理高效， <code class="code">HFileOutputFormat</code> 必须比配置为每个HFile适合在一个分区内。为了做到这一点，输出将被批量装载到HBase的任务，使用Hadoop 的<code class="code">TotalOrderPartitioner</code> 类来分开map输出为分开的键空间区间。对应于表内每个分区(region)的键空间。</p>
<p>
  <code class="code">HFileOutputFormat</code> 包含一个方便的函数,
  <code class="code">configureIncrementalLoad()</code>, 可以基于表当前分区边界自动设置<code class="code">TotalOrderPartitioner</code>。</p></div><div class="section" title="9.8.2.2.&nbsp;Completing the data load"><div class="titlepage"><div><div>
          <h4 class="title"><a name="arch.bulk.load.complete"></a>9.8.2.2.&nbsp;完成数据装载</h4></div></div></div><p>
          After the data has been prepared using
          <code class="code">HFileOutputFormat</code>, it is loaded into the cluster using
          <code class="code">completebulkload</code>. This command line tool iterates
          through the prepared data files, and for each one determines the
          region the file belongs to. It then contacts the appropriate Region
          Server which adopts the HFile, moving it into its storage directory
          and making the data available to clients.
        </p><p>
          If the region boundaries have changed during the course of bulk load
          preparation, or between the preparation and completion steps, the
          <code class="code">completebulkloads</code> utility will automatically split the
          data files into pieces corresponding to the new boundaries. This
          process is not optimally efficient, so users should take care to
          minimize the delay between preparing a bulk load and importing it
          into the cluster, especially if other clients are simultaneously
          loading data through other means.
        </p></div></div><div class="section" title="9.8.3.&nbsp;Importing the prepared data using the completebulkload tool"><div class="titlepage"><div><div>
          <h3 class="title"><a name="arch.bulk.load.import"></a>9.8.3.&nbsp;采用completebulkload 工具导入准备的数据 </h3></div></div></div><p>
        After a data import has been prepared, either by using the
        <code class="code">importtsv</code> tool with the
        "<code class="code">importtsv.bulk.output</code>" option or by some other MapReduce
        job using the <code class="code">HFileOutputFormat</code>, the
        <code class="code">completebulkload</code> tool is used to import the data into the
        running cluster.
      </p><p>
        The <code class="code">completebulkload</code> tool simply takes the output path
        where <code class="code">importtsv</code> or your MapReduce job put its results, and
        the table name to import into. For example:
      </p><code class="code">$ hadoop jar hbase-VERSION.jar completebulkload [-c /path/to/hbase/config/hbase-site.xml] /user/todd/myoutput mytable</code><p>
        The <code class="code">-c config-file</code> option can be used to specify a file
        containing the appropriate hbase parameters (e.g., hbase-site.xml) if
        not supplied already on the CLASSPATH (In addition, the CLASSPATH must
        contain the directory that has the zookeeper configuration file if
        zookeeper is NOT managed by HBase).
      </p><p>
        Note: If the target table does not already exist in HBase, this
        tool will create the table automatically.</p><p>
        This tool will run quickly, after which point the new data will be visible in
        the cluster.
      </p></div><div class="section" title="9.8.4.&nbsp;See Also"><div class="titlepage"><div><div>
        <h3 class="title"><a name="arch.bulk.load.also"></a>9.8.4.&nbsp;参考</h3></div></div></div><p>For more information about the referenced utilities, see <a class="xref" href="#importtsv" title="14.1.9.&nbsp;ImportTsv">Section&nbsp;14.1.9, “ImportTsv”</a> and  <a class="xref" href="#completebulkload" title="14.1.10.&nbsp;CompleteBulkLoad">Section&nbsp;14.1.10, “CompleteBulkLoad”</a>.
      </p></div><div class="section" title="9.8.5.&nbsp;Advanced Usage"><div class="titlepage"><div><div>
        <h3 class="title"><a name="arch.bulk.load.adv"></a>9.8.5.&nbsp;高级使用</h3></div></div></div><p>
        Although the <code class="code">importtsv</code> tool is useful in many cases, advanced users may
        want to generate data programatically, or import data from other formats. To get
        started doing so, dig into <code class="code">ImportTsv.java</code> and check the JavaDoc for
        HFileOutputFormat.
      </p><p>
        The import step of the bulk load can also be done programatically. 参考 the
        <code class="code">LoadIncrementalHFiles</code> class 获取更多信息。
      </p></div></div>
           
       <div class="section" title="9.9.&nbsp;HDFS"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch.hdfs"></a>9.9.&nbsp;HDFS</h2></div></div></div>
       <p>由于 HBase 在 HDFS 上运行(每个存储文件也被写为HDFS的文件)，必须理解 HDFS 结构，特别是它如何存储文件，处理故障转移，备份块。</p>
       <p>参考 Hadoop 文档 <a class="link" href="http://hadoop.apache.org/common/docs/current/hdfs_design.html" target="_top">HDFS Architecture</a>
       获取更多信息。</p><div class="section" title="9.9.1.&nbsp;NameNode"><div class="titlepage"><div><div><h3 class="title"><a name="arch.hdfs.nn"></a>9.9.1.&nbsp;NameNode</h3></div></div></div>
       <p> NameNode 负责维护文件系统元数据。参考上述HDFS结构链接获取更多信息。</p></div><div class="section" title="9.9.2.&nbsp;DataNode"><div class="titlepage"><div><div><h3 class="title"><a name="arch.hdfs.dn"></a>9.9.2.&nbsp;DataNode</h3></div></div></div>
       <p> DataNode 负责存储HDFS 块。  参考上述HDFS结构链接获取更多信息。
         </p></div></div>
         
         <div class="chapter" title="Chapter&nbsp;10.&nbsp;External APIs"><div class="titlepage"><div><div>
           <h2 class="title">&nbsp;</h2>
           <hr width="100" align="left">
           <div>
             <p>[<a id="ftn.d1952e5435" href="http://hbase.apache.org/#d1952e5435">23</a>] 参考 <a href="https://issues.apache.org/jira/browse/HBASE-2958" target="_top">HBASE-2958 When hbase.hlog.split.skip.errors is set to false, we fail the split but thats it</a>. We need to do more than just fail split if this flag is set.</p>
           </div>
           <div>
             <p>[<a id="ftn.d1952e5452" href="http://hbase.apache.org/#d1952e5452">24</a>] For background, see <a href="https://issues.apache.org/jira/browse/HBASE-2643" target="_top">HBASE-2643 Figure how to deal with eof splitting logs</a></p>
           </div>
           <div>
             <p>[<a id="ftn.d1952e6050" href="http://hbase.apache.org/#d1952e6050">25</a>] For description of the development process -- why static blooms rather than dynamic -- and for an overview of the unique properties that pertain to blooms in HBase, as well as possible future directions, see the <em>Development Process</em> section of the document<a href="https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf" target="_top">BloomFilters in HBase</a> attached to <a href="https://issues.apache.org/jira/browse/HBASE-1200" target="_top">HBase-1200</a>.</p>
           </div>
           <div>
             <p>[<a id="ftn.d1952e6062" href="http://hbase.apache.org/#d1952e6062">26</a>] The bloom filters described here are actually version two of blooms in HBase. In versions up to 0.19.x, HBase had a dynamic bloom option based on work done by the <a href="http://www.one-lab.org/" target="_top">European Commission One-Lab Project 034819</a>. The core of the HBase bloom work was later pulled up into Hadoop to implement org.apache.hadoop.io.BloomMapFile. Version 1 of HBase blooms never worked that well. Version 2 is a rewrite from scratch though again it starts with the one-lab work.</p>
           </div>
<h2 class="title"><a name="external_apis"></a>Chapter&nbsp;10.&nbsp;外部 API</h2>
         </div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#nonjava.jvm">10.1. 非Java 语言和 JVM 通话</a></span></dt><dt><span class="section"><a href="#rest">10.2. REST</a></span></dt><dt><span class="section"><a href="#thrift">10.3. Thrift</a></span></dt><dd><dl><dt><span class="section"><a href="#thrift.filter-language">10.3.1. 过滤器语言</a></span></dt></dl></dd></dl></div>
  This chapter will cover access to HBase either through non-Java languages, or through custom protocols.
  
  <div class="section" title="10.1.&nbsp;Non-Java Languages Talking to the JVM"><div class="titlepage"><div><div>
    <h2 class="title" style="clear: both"><a name="nonjava.jvm"></a>10.1.&nbsp;非Java 语言和 JVM 通话</h2></div></div></div>
  <p>当前本话题大部分文档在 
      <a class="link" href="http://wiki.apache.org/hadoop/HBase" target="_top">HBase Wiki</a>.
      参考 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/thrift/package-summary.html#package_description" target="_top">Thrift API Javadoc</a>.
    </p></div></div>
    <div class="section" title="10.2.&nbsp;REST"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest"></a>10.2.&nbsp;REST</h2></div></div></div>
      <p>当前 REST大部分文档在 
      <a class="link" href="http://wiki.apache.org/hadoop/HBase/Stargate" target="_top">HBase Wiki on REST</a>.
    </p></div>
    <div class="section" title="10.3.&nbsp;Thrift"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="thrift"></a>10.3.&nbsp;Thrift</h2></div></div></div><p>当前 Thrift大部分文档在 
      <a class="link" href="http://wiki.apache.org/hadoop/HBase/ThriftApi" target="_top">HBase Wiki on Thrift</a>.
    </p><div class="section" title="10.3.1.&nbsp;Filter Language"><div class="titlepage"><div><div><h3 class="title"><a name="thrift.filter-language"></a>10.3.1.&nbsp;过滤器语言</h3></div></div></div><div class="section" title="10.3.1.1.&nbsp;Use Case"><div class="titlepage"><div><div>
      <h4 class="title"><a name="use-case"></a>10.3.1.1.&nbsp;用例</h4></div></div></div>
    <p>注意:  本特性在 HBase 0.92 中加入。</p><p>This allows the user to perform server-side filtering when accessing HBase over Thrift. The user specifies a filter via a string. The string is parsed on the server to construct the filter</p></div><div class="section" title="10.3.1.2.&nbsp;General Filter String Syntax"><div class="titlepage"><div><div>
      <h4 class="title"><a name="general-syntax"></a>10.3.1.2.&nbsp;通用过滤字符串语法</h4></div></div></div><p>A simple filter expression is expressed as: <code class="code">“FilterName (argument, argument, ... , argument)”</code></p><p>You must specify the name of the filter followed by the argument list in parenthesis. Commas separate the individual arguments</p><p>If the argument represents a string, it should be enclosed in single quotes.</p><p>If it represents a boolean, an integer or a comparison operator like &lt;,
                 &gt;, != etc. it should not be enclosed in quotes</p><p>The filter name must be one word. All ASCII characters are allowed except for whitespace, single quotes and parenthesis.</p><p>The filter’s arguments can contain any ASCII character. <code class="code">If single quotes are present in the argument, they must be escaped by a
                   preceding single quote</code></p></div><div class="section" title="10.3.1.3.&nbsp;Compound Filters and Operators"><div class="titlepage"><div><div><h4 class="title"><a name="compound-filters-and-operators"></a>10.3.1.3.&nbsp;Compound Filters and Operators</h4></div></div></div><p>Currently, two binary operators – AND/OR and two unary operators – WHILE/SKIP are supported.</p><p>Note: the operators are all in uppercase</p><p><span class="bold"><strong>AND</strong></span> – as the name suggests, if this
                 operator is used, the key-value must pass both the filters</p><p><span class="bold"><strong>OR</strong></span> – as the name suggests, if this operator
                 is used, the key-value must pass at least one of the filters</p><p><span class="bold"><strong>SKIP</strong></span> – For a particular row, if any of the
                 key-values don’t pass the filter condition, the entire row is skipped</p><p><span class="bold"><strong>WHILE</strong></span> - For a particular row, it continues
                 to emit key-values until a key-value is reached that fails the filter condition</p><p><span class="bold"><strong>Compound Filters:</strong></span> Using these operators, a
                 hierarchy of filters can be created. For example: <code class="code">“(Filter1 AND Filter2) OR (Filter3 AND Filter4)”</code></p></div><div class="section" title="10.3.1.4.&nbsp;Order of Evaluation"><div class="titlepage"><div><div><h4 class="title"><a name="order-of-evaluation"></a>10.3.1.4.&nbsp;Order of Evaluation</h4></div></div></div><p>Parenthesis have the highest precedence. The SKIP and WHILE operators are next and have the same precedence.The AND operator has the next highest precedence followed by the OR operator.</p><p>For example:</p><p>A filter string of the form:<code class="code">“Filter1 AND Filter2 OR Filter3”</code>
                 will be evaluated as:<code class="code">“(Filter1 AND Filter2) OR Filter3”</code></p><p>A filter string of the form:<code class="code">“Filter1 AND SKIP Filter2 OR Filter3”</code>
                 will be evaluated as:<code class="code">“(Filter1 AND (SKIP Filter2)) OR Filter3”</code></p></div><div class="section" title="10.3.1.5.&nbsp;Compare Operator"><div class="titlepage"><div><div>
                   <h4 class="title"><a name="compare-operator"></a>10.3.1.5.&nbsp;比较运算符</h4></div></div></div>
                 <p>比较运算符可以是下面之一:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>LESS (&lt;)</p></li><li class="listitem"><p>LESS_OR_EQUAL (&lt;=)</p></li><li class="listitem"><p>EQUAL (=)</p></li><li class="listitem"><p>NOT_EQUAL (!=)</p></li><li class="listitem"><p>GREATER_OR_EQUAL (&gt;=)</p></li><li class="listitem"><p>GREATER (&gt;)</p></li><li class="listitem"><p>NO_OP (no operation)</p></li></ol></div>
                 <p>客户端应该使用 (&lt;, &lt;=, =, !=, &gt;, &gt;=) 来表达比较操作.</p></div><div class="section" title="10.3.1.6.&nbsp;Comparator"><div class="titlepage"><div><div>
                   <h4 class="title"><a name="comparator"></a>10.3.1.6.&nbsp;比较器(Comparator)</h4></div></div></div>
                 <p>比较器可以是下面之一:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong>BinaryComparator</strong></span> - This
                     lexicographically compares against the specified byte array using
                     Bytes.compareTo(byte[], byte[])</p></li><li class="listitem"><p><span class="bold"><strong>BinaryPrefixComparator</strong></span> - This
                     lexicographically compares against a specified byte array. It only compares up to
                     the length of this byte array.</p></li><li class="listitem"><p><span class="bold"><strong>RegexStringComparator</strong></span> - This compares
                     against the specified byte array using the given regular expression. Only EQUAL
                     and NOT_EQUAL comparisons are valid with this comparator</p></li><li class="listitem"><p><span class="bold"><strong>SubStringComparator</strong></span> - This tests if
                     the given substring appears in a specified byte array. The comparison is case
                     insensitive. Only EQUAL and NOT_EQUAL comparisons are valid with this
                     comparator</p></li></ol></div><p>The general syntax of a comparator is:<code class="code"> ComparatorType:ComparatorValue</code></p><p>The ComparatorType for the various comparators is as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong>BinaryComparator</strong></span> - binary</p></li><li class="listitem"><p><span class="bold"><strong>BinaryPrefixComparator</strong></span> - binaryprefix</p></li><li class="listitem"><p><span class="bold"><strong>RegexStringComparator</strong></span> - regexstring</p></li><li class="listitem"><p><span class="bold"><strong>SubStringComparator</strong></span> - substring</p></li></ol></div><p>The ComparatorValue can be any value.</p><p>Example1:<code class="code"> &gt;, 'binary:abc' </code>will match everything that is lexicographically greater than "abc" </p><p>Example2:<code class="code"> =, 'binaryprefix:abc' </code>will match everything whose first 3 characters are lexicographically equal to "abc"</p><p>Example3:<code class="code"> !=, 'regexstring:ab*yz' </code>will match everything that doesn't begin with "ab" and ends with "yz"</p><p>Example4:<code class="code"> =, 'substring:abc123' </code>will match everything that begins with the substring "abc123"</p></div><div class="section" title="10.3.1.7.&nbsp;Example PHP Client Program that uses the Filter Language"><div class="titlepage"><div><div>
                       <h4 class="title"><a name="example PHP Client Program"></a>10.3.1.7.&nbsp; PHP 客户端编程使用过滤器示例</h4></div></div></div><pre class="programlisting">&lt;? $_SERVER['PHP_ROOT'] = realpath(dirname(__FILE__).'/..');
   require_once $_SERVER['PHP_ROOT'].'/flib/__flib.php';
   flib_init(FLIB_CONTEXT_SCRIPT);
   require_module('storage/hbase');
   $hbase = new HBase('&lt;server_name_running_thrift_server&gt;', &lt;port on which thrift server is running&gt;);
   $hbase-&gt;open();
   $client = $hbase-&gt;getClient();
   $result = $client-&gt;scannerOpenWithFilterString('table_name', "(PrefixFilter ('row2') AND (QualifierFilter (&gt;=, 'binary:xyz'))) AND (TimestampsFilter ( 123, 456))");
   $to_print = $client-&gt;scannerGetList($result,1);
   while ($to_print) {
      print_r($to_print);
      $to_print = $client-&gt;scannerGetList($result,1);
    }
   $client-&gt;scannerClose($result);
?&gt;
        </pre></div><div class="section" title="10.3.1.8.&nbsp;Example Filter Strings"><div class="titlepage"><div><div>
          <h4 class="title"><a name="example-filter-strings"></a>10.3.1.8.&nbsp;过滤字符串示例</h4></div></div></div><p>
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">“PrefixFilter (‘Row’) AND PageFilter (1) AND FirstKeyOnlyFilter ()”</code> will return all key-value pairs that match the following conditions:</p><p>1) The row containing the key-value should have prefix “Row” </p><p>2) The key-value must be located in the first row of the table </p><p>3) The key-value pair must be the first key-value in the row </p></li></ul></div><p>
        </p><div class="orderedlist"><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">“(RowFilter (=, ‘binary:Row 1’) AND TimeStampsFilter (74689, 89734)) OR
                    ColumnRangeFilter (‘abc’, true, ‘xyz’, false))”</code> will return all key-value pairs that match both the following conditions:</p><p>1) The key-value is in a row having row key “Row 1” </p><p>2) The key-value must have a timestamp of either 74689 or 89734.</p><p>Or it must match the following condition:</p><p>1) The key-value pair must be in a column that is lexicographically &gt;= abc and &lt; xyz&nbsp;</p></li></ul></div><p>
          </p><ol class="orderedlist" type="1"></ol></div><p>
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">“SKIP ValueFilter (0)”</code> will skip the entire row if any of the values in the row is not 0</p></li></ul></div><p>
        </p></div><div class="section" title="10.3.1.9.&nbsp;Individual Filter Syntax"><div class="titlepage"><div><div>
          <h4 class="title"><a name="Individual Filter Syntax"></a>10.3.1.9.&nbsp;独有过滤器语法</h4></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong><span class="underline">KeyOnlyFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter doesn’t take any
              arguments. It returns only the key component of each key-value. </p><p><span class="bold"><strong>Syntax:</strong></span> KeyOnlyFilter () </p><p><span class="bold"><strong>Example:</strong></span> "KeyOnlyFilter ()"</p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">FirstKeyOnlyFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter doesn’t take any
              arguments. It returns only the first key-value from each row. </p><p><span class="bold"><strong>Syntax:</strong></span> FirstKeyOnlyFilter () </p><p><span class="bold"><strong>Example:</strong></span> "FirstKeyOnlyFilter ()" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">PrefixFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes one argument – a prefix of a
              row key. It returns only those key-values present in a row that starts with the
              specified row prefix</p><p><span class="bold"><strong>Syntax:</strong></span> PrefixFilter (‘&lt;row_prefix&gt;’) </p><p><span class="bold"><strong>Example:</strong></span> "PrefixFilter (‘Row’)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">
                  ColumnPrefixFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes one argument
              – a column prefix. It returns only those key-values present in a column that starts
              with the specified column prefix. The column prefix must be of the form: <code class="code">“qualifier” </code></p><p><span class="bold"><strong>Syntax:</strong></span>ColumnPrefixFilter(‘&lt;column_prefix&gt;’)</p><p><span class="bold"><strong>Example:</strong></span> "ColumnPrefixFilter(‘Col’)"</p></li><li class="listitem"><p><span class="underline"><span class="bold"><strong>MultipleColumnPrefixFilter</strong></span></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes a list of
              column prefixes. It returns key-values that are present in a column that starts with
              any of the specified column prefixes. Each of the column prefixes must be of the form: <code class="code">“qualifier”</code></p><p><span class="bold"><strong>Syntax:</strong></span>MultipleColumnPrefixFilter(‘&lt;column_prefix&gt;’, ‘&lt;column_prefix&gt;’, …, ‘&lt;column_prefix&gt;’)</p><p><span class="bold"><strong>Example:</strong></span> "MultipleColumnPrefixFilter(‘Col1’, ‘Col2’)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">ColumnCountGetFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes one argument
              – a limit. It returns the first limit number of columns in the table</p><p><span class="bold"><strong>Syntax:</strong></span> ColumnCountGetFilter (‘&lt;limit&gt;’)</p><p><span class="bold"><strong>Example:</strong></span> "ColumnCountGetFilter (4)"</p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">PageFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes one argument
              – a page size. It returns page size number of rows from the table. </p><p><span class="bold"><strong>Syntax:</strong></span> PageFilter (‘&lt;page_size&gt;’)</p><p><span class="bold"><strong>Example:</strong></span> "PageFilter (2)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">ColumnPaginationFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes two
              arguments – a limit and offset. It returns limit number of columns after offset number
              of columns. It does this for all the rows</p><p><span class="bold"><strong>Syntax:</strong></span> ColumnPaginationFilter(‘&lt;limit&gt;’, ‘&lt;offest&gt;’) </p><p><span class="bold"><strong>Example:</strong></span> "ColumnPaginationFilter (3, 5)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">InclusiveStopFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes one argument
              – a row key on which to stop scanning. It returns all key-values present in rows up to
              and including the specified row</p><p><span class="bold"><strong>Syntax:</strong></span> InclusiveStopFilter(‘&lt;stop_row_key&gt;’) </p><p><span class="bold"><strong>Example:</strong></span> "InclusiveStopFilter ('Row2')" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">TimeStampsFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes a list of
              timestamps. It returns those key-values whose timestamps matches any of the specified
              timestamps</p><p> <span class="bold"><strong>Syntax:</strong></span> TimeStampsFilter (&lt;timestamp&gt;, &lt;timestamp&gt;, ... ,&lt;timestamp&gt;) </p><p> <span class="bold"><strong>Example:</strong></span> "TimeStampsFilter (5985489, 48895495, 58489845945)"</p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">RowFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes a compare
              operator and a comparator. It compares each row key with the comparator using the
              compare operator and if the comparison returns true, it returns all the key-values in
              that row</p><p><span class="bold"><strong>Syntax:</strong></span> RowFilter (&lt;compareOp&gt;, ‘&lt;row_comparator&gt;’) </p><p><span class="bold"><strong>Example: </strong></span>"RowFilter (&lt;=, ‘xyz)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">Family Filter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes a compare
              operator and a comparator. It compares each qualifier name with the comparator using
              the compare operator and if the comparison returns true, it returns all the key-values
              in that column</p><p><span class="bold"><strong>Syntax:</strong></span> QualifierFilter (&lt;compareOp&gt;, ‘&lt;qualifier_comparator&gt;’) </p><p><span class="bold"><strong>Example:</strong></span> "QualifierFilter (=, ‘Column1’)"</p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">QualifierFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes a compare
              operator and a comparator. It compares each qualifier name with the comparator using
              the compare operator and if the comparison returns true, it returns all the key-values
              in that column</p><p><span class="bold"><strong>Syntax:</strong></span> QualifierFilter (&lt;compareOp&gt;,‘&lt;qualifier_comparator&gt;’) </p><p><span class="bold"><strong>Example:</strong></span> "QualifierFilter (=,‘Column1’)"</p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">ValueFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes a compare operator and a
              comparator. It compares each value with the comparator using the compare operator and
              if the comparison returns true, it returns that key-value</p><p><span class="bold"><strong>Syntax:</strong></span> ValueFilter (&lt;compareOp&gt;,‘&lt;value_comparator&gt;’) </p><p><span class="bold"><strong>Example:</strong></span> "ValueFilter (!=, ‘Value’)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">DependentColumnFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes two arguments – a family
              and a qualifier. It tries to locate this column in each row and returns all key-values
              in that row that have the same timestamp. If the row doesn’t contain the specified
              column – none of the key-values in that row will be returned.</p><p>The filter can also take an optional boolean argument – dropDependentColumn. If set to true, the column we were depending on doesn’t get returned.</p><p>The filter can also take two more additional optional arguments – a compare operator and a value comparator, which are further checks in addition to the family and qualifier. If the dependent column is found, its value should also pass the value check and then only is its timestamp taken into consideration</p><p><span class="bold"><strong>Syntax:</strong></span> DependentColumnFilter (‘&lt;family&gt;’, ‘&lt;qualifier&gt;’, &lt;boolean&gt;, &lt;compare operator&gt;, ‘&lt;value comparator’)</p><p><span class="bold"><strong>Syntax:</strong></span> DependentColumnFilter (‘&lt;family&gt;’, ‘&lt;qualifier&gt;’, &lt;boolean&gt;) </p><p><span class="bold"><strong>Syntax:</strong></span> DependentColumnFilter (‘&lt;family&gt;’, ‘&lt;qualifier&gt;’) </p><p><span class="bold"><strong>Example:</strong></span> "DependentColumnFilter (‘conf’, ‘blacklist’, false, &gt;=, ‘zebra’)" </p><p><span class="bold"><strong>Example:</strong></span> "DependentColumnFilter (‘conf’, 'blacklist', true)"</p><p><span class="bold"><strong>Example:</strong></span> "DependentColumnFilter (‘conf’, 'blacklist')"</p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">SingleColumnValueFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes a column family, a
              qualifier, a compare operator and a comparator. If the specified column is not found –
              all the columns of that row will be emitted. If the column is found and the comparison
              with the comparator returns true, all the columns of the row will be emitted. If the
              condition fails, the row will not be emitted. </p><p>This filter also takes two additional optional boolean arguments – filterIfColumnMissing and setLatestVersionOnly</p><p>If the filterIfColumnMissing flag is set to true the columns of the row will not be emitted if the specified column to check is not found in the row. The default value is false.</p><p>If the setLatestVersionOnly flag is set to false, it will test previous versions (timestamps) too. The default value is true.</p><p>These flags are optional and if you must set neither or both</p><p><span class="bold"><strong>Syntax:</strong></span> SingleColumnValueFilter(&lt;compare operator&gt;, ‘&lt;comparator&gt;’, ‘&lt;family&gt;’, ‘&lt;qualifier&gt;’,&lt;filterIfColumnMissing_boolean&gt;, &lt;latest_version_boolean&gt;) </p><p><span class="bold"><strong>Syntax:</strong></span> SingleColumnValueFilter(&lt;compare operator&gt;, ‘&lt;comparator&gt;’, ‘&lt;family&gt;’, ‘&lt;qualifier&gt;) </p><p><span class="bold"><strong>Example:</strong></span> "SingleColumnValueFilter (&lt;=, ‘abc’,‘FamilyA’, ‘Column1’, true, false)" </p><p><span class="bold"><strong>Example:</strong></span> "SingleColumnValueFilter (&lt;=, ‘abc’,‘FamilyA’, ‘Column1’)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">SingleColumnValueExcludeFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter takes the same arguments and
              behaves same as SingleColumnValueFilter – however, if the column is found and the
              condition passes, all the columns of the row will be emitted except for the tested
              column value. </p><p><span class="bold"><strong>Syntax:</strong></span> SingleColumnValueExcludeFilter(&lt;compare operator&gt;, '&lt;comparator&gt;', '&lt;family&gt;', '&lt;qualifier&gt;',&lt;latest_version_boolean&gt;, &lt;filterIfColumnMissing_boolean&gt;)</p><p><span class="bold"><strong>Syntax:</strong></span> SingleColumnValueExcludeFilter(&lt;compare operator&gt;, '&lt;comparator&gt;', '&lt;family&gt;', '&lt;qualifier&gt;') </p><p><span class="bold"><strong>Example:</strong></span> "SingleColumnValueExcludeFilter (‘&lt;=’, ‘abc’,‘FamilyA’, ‘Column1’, ‘false’, ‘true’)"</p><p><span class="bold"><strong>Example:</strong></span> "SingleColumnValueExcludeFilter (‘&lt;=’, ‘abc’, ‘FamilyA’, ‘Column1’)" </p></li><li class="listitem"><p><span class="bold"><strong><span class="underline">ColumnRangeFilter</span></strong></span></p><p><span class="bold"><strong>Description:</strong></span> This filter is used for selecting only those
              keys with columns that are between minColumn and maxColumn. It also takes two boolean
       variables to indicate whether to include the minColumn and maxColumn or not.</p><p>If you don’t want to set the minColumn or the maxColumn – you can pass in an empty argument.</p><p><span class="bold"><strong>Syntax:</strong></span> ColumnRangeFilter (‘&lt;minColumn&gt;’, &lt;minColumnInclusive_bool&gt;, ‘&lt;maxColumn&gt;’, &lt;maxColumnInclusive_bool&gt;)</p><p><span class="bold"><strong>Example:</strong></span> "ColumnRangeFilter (‘abc’, true, ‘xyz’, false)"</p></li>
          </ol>
            <div>
              <div>
                <div>
                  <h2>10.4. C/C++ Apache HBase Client</h2>
                </div>
              </div>
            </div>
            <p>Facebook的 Chip Turner 写了个纯 C/C++ 客户端。 <a href="https://github.com/facebook/native-cpp-hbase-client" target="_top">Check it out</a>.</p>
          </div></div></div></div>  
       <div class="section" title="12.1.3. Filters">
         <div class="titlepage">
           <div>
             <div></div>
           </div>
         </div>
       </div>
     </div>
     <div class="chapter" title="Chapter&nbsp;11.&nbsp;Performance Tuning"><div class="titlepage"><div><div>
       <h2 class="title"><a name="performance"></a>Chapter&nbsp;11.&nbsp;性能调优</h2>
     </div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl>
       <dt><a href="#perf.os">11.1. 操作系统</a></dt>
       <dt><a href="#perf.network">11.2. 网络</a></dt>
       <dt><a href="#jvm">11.3. Java</a></dt>
       <dt><a href="#perf.configurations">11.4. HBase 配置</a></dt>
       <dt><a href="#perf.zookeeper">11.5. ZooKeeper</a></dt>
       <dt><a href="#perf.schema">11.6. Schema 设计</a></dt>
       <dt><a href="#perf.writing">11.8. 写到 HBase</a></dt>
       <dt><a href="#perf.reading">11.9. 从 HBase读取</a></dt>
       <dt><a href="#perf.deleting">11.10. 从 HBase删除</a></dt>
       <dt><a href="#perf.hdfs">11.11. HDFS</a></dt>
       <dt><a href="#perf.ec2">11.11. Amazon EC2</a></dt>
       <dt><a href="#perf.casestudy">11.12. 案例</a></dt>
       <dt>&nbsp;</dt></dl>
</div><div class="section" title="11.1.&nbsp;Operating System"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.os"></a>11.1.&nbsp;操作系统</h2></div></div></div><div class="section" title="11.1.1.&nbsp;Memory"><div class="titlepage"><div><div>
  <h3 class="title"><a name="perf.os.ram"></a>11.1.1.&nbsp;内存</h3></div></div></div>
<p>RAM, RAM, RAM.  不要饿着 HBase.</p></div><div class="section" title="11.1.2.&nbsp;64-bit"><div class="titlepage"><div><div><h3 class="title"><a name="perf.os.64"></a>11.1.2.&nbsp;64-bit</h3></div></div></div>
<p>使用 64-bit 平台(和64-bit JVM).</p></div><div class="section" title="11.1.3.&nbsp;Swapping"><div class="titlepage"><div><div>
  <h3 class="title"><a name="perf.os.swap"></a>11.1.3.&nbsp;交换区</h3></div></div></div>
<p>小心交换，将交换区设为0。</p></div></div></div>
    
    <div class="section" title="11.2.&nbsp;Network"><div class="titlepage"><div><div>
      <h2 class="title" style="clear: both"><a name="perf.network"></a>11.2.&nbsp;网络</h2></div></div></div>
    <p>
    也许，避免网络问题降低Hadoop和HBase性能的最重要因素就是所使用的交换机硬件。在项目范围内，集群大小翻倍或三倍甚至更多时，早期的决定可能导致主要的问题。</p>
    <p>
    要考虑的重要事项：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
        <li class="listitem">设备交换机容量</li>
        <li class="listitem">系统连接数量</li>
        <li class="listitem">上行容量</li></ul></div><p>
    </p><div class="section" title="11.2.1.&nbsp;Single Switch"><div class="titlepage"><div><div>
      <h3 class="title"><a name="perf.network.1switch"></a>11.2.1.&nbsp;单交换机</h3></div></div></div>
    <p>单交换机配置最重要的因素，是硬件交换容量，所有系统连接到交换机产生的流量的处理能力。一些低价硬件商品，相对全交换机，具有较低交换能力。</p></div><div class="section" title="11.2.2.&nbsp;Multiple Switches"><div class="titlepage"><div><div>
        <h3 class="title"><a name="perf.network.2switch"></a>11.2.2.&nbsp;多交换机</h3></div></div></div>
    <p>多交换机在系统结构中是潜在陷阱。低价硬件的最常用配置是1Gbps上行连接到另一个交换机。 该常被忽略的窄点很容易成为集群通讯的瓶颈。特别是MapReduce任务通过该上行连接同时读写大量数据时，会导致饱和。</p>
    <p>缓解该问题很简单，可以通过多种途径完成：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
        <li class="listitem">针对要创建的集群容量，采用合适硬件。</li>
        <li class="listitem">采用更大单交换机配置，如单48 端口相较2x 24 端口为优。</li>
        <li class="listitem">配置上行端口聚合(port trunking)来利用多网络接口增加交换机带宽。(译者注：port trunk：
          <pre id="best-content-432716237" accuse="aContent">将交换机上的多个端口在物理上连接起来，在逻辑上捆绑在一起，形成一个拥有较大带宽的端口，组成一个干路，以达到平衡负载和提供备份线路，扩充带宽的目的。
)        </pre>
        </li>
    </ul></div><p>
      </p></div><div class="section" title="11.2.3.&nbsp;Multiple Racks"><div class="titlepage"><div><div>
        <h3 class="title"><a name="perf.network.multirack"></a>11.2.3.&nbsp;多机架</h3></div></div></div>
      <p>多机架配置带来多交换机同样的潜在问题。导致性能降低的原因主要来自两个方面：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
          <li class="listitem">较低的交换机容量性能</li>
          <li class="listitem">到其他机架的上行链路不足</li></ul></div>
      <p>
      如果机架上的交换机有合适交换容量，可以处理所有主机全速通信，那么下一个问题就是如何自动导航更多的交错在机架中的集群。最简单的避免横跨多机架问题的办法，是采用端口聚合来创建到其他机架的捆绑的上行的连接。然而该方法下行侧，是潜在被使用的端口开销。举例：从机架A到机架B创建 8Gbps 端口通道，采用24端口中的8个来和其他机架互通，ROI(投资回报率)很低。采用太少端口意味着不能从集群中传出最多的东西。 
      </p>
      <p>机架间采用10Gbe 链接将极大增加性能，确保交换机都支持10Gbe 上行连接或支持扩展卡，后者相对上行连接，允许你节省机器端口。</p></div><div class="section" title="11.2.4.&nbsp;Network Interfaces"><div class="titlepage"><div><div>
        <h3 class="title"><a name="perf.network.ints"></a>11.2.4.&nbsp;网络接口</h3></div></div></div>
      <p>所有网络接口功能正常吗？你确定？参考故障诊断用例：<a class="xref" href="#casestudies.slownode" title="13.3.1.&nbsp;Case Study #1 (Performance Issue On A Single Node)">Section&nbsp;13.3.1, “Case Study #1 (Performance Issue On A Single Node)”</a>.
      </p></div></div>
      
     <div class="section" title="12.2. Daemons">
       <div class="titlepage">
         <div>
           <div>
             <div class="toc">
               <p>&nbsp;</p>
             </div>
             <p>可以从 <a class="link" href="http://wiki.apache.org/hadoop/PerformanceTuning" target="_top">wiki
               Performance Tuning</a>看起。这个文档讲了一些主要的影响性能的方面:RAM, 压缩, JVM 设置, 等等。然后，可以看看下面的补充内容。</p>
             <div class="note" title="打开RPC-level日志" style="margin-left: 0.5in; margin-right: 0.5in;">
               <h3 class="title"><a name="rpc.logging"></a>打开RPC-level日志</h3>
               <p>在区域服务器打开RPC-level的日志对于深度的优化是有好处的。一旦打开，日志将喷涌而出。所以不建议长时间打开，只能看一小段时间。要想启用RPC-level的职责，可以使用区域服务器 UI点击<span class="emphasis"><em>Log Level</em></span>。将 <code class="classname">org.apache.hadoop.ipc</code> 的日志级别设为<code class="varname">DEBUG</code>。然后tail 区域服务器的日志，进行分析。</p>
               <p>要想关闭，只要把日志级别设为<code class="varname">INFO</code>就可以了. </p>
             </div>
             <div class="section" title="13.1. Java">
               <div class="titlepage">
                 <div>
                   <div>
                     <h2 class="title" style="clear: both"><a name="jvm"></a>11.3.&nbsp;Java</h2>
                   </div>
                 </div>
               </div>
               <div class="section" title="13.1.1. 垃圾收集和HBase">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="gc"></a>11.3.1.&nbsp;垃圾收集和Apache HBase</h3>
</div>
                   </div>
                 </div>
                 <div class="section" title="13.1.1.1. 长时间GC停顿">
                   <div class="titlepage">
                     <div>
                       <div>
                         <h4 class="title"><a name="gcpause"></a>11.3.1.1.&nbsp;长时间GC停顿</h4>
                       </div>
                     </div>
                   </div>
                   <p>在这个PPT <a class="link" href="http://www.slideshare.net/cloudera/hbase-hug-presentation" target="_top">Avoiding
                     Full GCs with MemStore-Local Allocation Buffers</a>, Todd Lipcon描述了在HBase中常见的两种“世界停止”式的GC操作，尤其是在加载的时候。一种是CMS失败的模式(译者注:CMS是一种GC的算法)，另一种是老一代的堆碎片导致的。要想定位第一种，只要将CMS执行的时间提前就可以了，加入<code class="code">-XX:CMSInitiatingOccupancyFraction</code>参数，把值调低。可以先从60%和70%开始(这个值调的越低，触发的GC次数就越多，消耗的CPU时间就越长)。要想定位第二种错误，Todd加入了一个实验性的功能，在HBase 0.90.x中这个是要明确指定的(在0.92.x中，这个是默认项)，将你的<code class="classname">Configuration</code>中的<code class="code">hbase.hregion.memstore.mslab.enabled</code>设置为true。详细信息，可以看这个PPT. [<a name="d352e6660" href="#ftn.d352e6660">27</a>]. Be aware that when enabled, each MemStore instance will occupy at least an MSLAB instance of memory. If you have thousands of regions or lots of regions each with many column families, this allocation of MSLAB may be responsible for a good portion of your heap allocation and in an extreme case cause you to OOME. Disable MSLAB in this case, or lower the amount of memory it uses or float less regions per server.</p>
<p> GC日志的更多信息，参考 <a href="#trouble.log.gc" title="12.2.3. JVM Garbage Collection Logs">Section 12.2.3, &ldquo;JVM <span class="title">垃圾收集日志</span>&rdquo;</a>.</p>
                 </div>
               </div>
             </div>
             <div class="section" title="13.2. 配置">
               <div class="titlepage">
                 <div>
                   <div>
                     <h2 class="title" style="clear: both"><a name="perf.configurations"></a>11.4.&nbsp;配置</h2>
                   </div>
                 </div>
               </div>
               <p>参见<a class="xref" href="#recommended_configurations" title="3.6. 推荐的配置">Section&nbsp;2.8.2, “推荐的配置”</a>.</p>
               <div class="section" title="13.2.1. Regions的数目">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.number.of.regions"></a>11.4.1.&nbsp;Regions的数目</h3>
                     </div>
                   </div>
                 </div>
                 <p>HBase中region的数目可以根据<a class="xref" href="#bigger.regions" title="3.6.5. 更大的 Regions">Section&nbsp;3.6.5, “更大的 Regions”</a>调整.也可以参见 <a class="xref" href="#arch.regions.size" title="12.3.1. Region大小">Section&nbsp;12.3.1, “Region大小”</a></p>
               </div>
               <div class="section" title="13.2.2. 管理压缩">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.compactions.and.splits"></a>11.4.2.&nbsp;管理紧缩</h3>
                     </div>
                   </div>
                 </div>
                 <p>对于大型的系统，你需要考虑管理<a class="link" href="#disable.splitting" title="3.6.6. 管理 Splitting">紧缩和分割</a></p>
               </div>
               <div class="section" title="13.2.3. 压缩">
                 <div class="titlepage">
                   <div>
                     <div></div>
                   </div>
                 </div>
               </div>
               <div class="section" title="13.2.4. hbase.regionserver.handler.count">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.handlers"></a>11.4.3.&nbsp;<code class="varname">hbase.regionserver.handler.count</code></h3>
                     </div>
                   </div>
                 </div>
                 <p>参见<a class="xref" href="#hbase.regionserver.handler.count" title="hbase.regionserver.handler.count"><code class="varname">hbase.regionserver.handler.count</code></a>.这个参数的本质是设置一个RegsionServer可以同时处理多少请求。 如果定的太高，吞吐量反而会降低;如果定的太低，请求会被阻塞，得不到响应。你可以<a class="xref" href="#rpc.logging" title="打开RPC-level日志">打开RPC-level日志</a>读Log，来决定对于你的集群什么值是合适的。(请求队列也是会消耗内存的) </p>
               </div>
               <div class="section" title="13.2.5. hfile.block.cache.size">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.hfile.block.cache.size"></a>11.4.4.&nbsp;<code class="varname">hfile.block.cache.size</code></h3>
                     </div>
                   </div>
                 </div>
                 <p>参见 <a class="xref" href="#hfile.block.cache.size" title="hfile.block.cache.size"><code class="varname">hfile.block.cache.size</code></a>. 对于区域服务器进程的内存设置。 </p>
               </div>
               <div class="section" title="13.2.6. hbase.regionserver.global.memstore.upperLimit">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.rs.memstore.upperlimit"></a>11.4.5.&nbsp;<code class="varname">hbase.regionserver.global.memstore.upperLimit</code></h3>
                     </div>
                   </div>
                 </div>
                 <p>参见 <a class="xref" href="#hbase.regionserver.global.memstore.upperLimit" title="hbase.regionserver.global.memstore.upperLimit"><code class="varname">hbase.regionserver.global.memstore.upperLimit</code></a>.  这个内存设置是根据区域服务器的需要来设定。 </p>
               </div>
               <div class="section" title="13.2.7. hbase.regionserver.global.memstore.lowerLimit">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.rs.memstore.lowerlimit"></a>11.4.6.&nbsp;<code class="varname">hbase.regionserver.global.memstore.lowerLimit</code></h3>
                     </div>
                   </div>
                 </div>
                 <p>参见 <a class="xref" href="#hbase.regionserver.global.memstore.lowerLimit" title="hbase.regionserver.global.memstore.lowerLimit"><code class="varname">hbase.regionserver.global.memstore.lowerLimit</code></a>.  
                   这个内存设置是根据区域服务器的需要来设定。 </p>
               </div>
               <div class="section" title="13.2.8. hbase.hstore.blockingStoreFiles">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.hstore.blockingstorefiles"></a>11.4.7.&nbsp;<code class="varname">hbase.hstore.blockingStoreFiles</code></h3>
                     </div>
                   </div>
                 </div>
                 <p>参见<a class="xref" href="#hbase.hstore.blockingStoreFiles" title="hbase.hstore.blockingStoreFiles"><code class="varname">hbase.hstore.blockingStoreFiles</code></a>.  
                   如果在区域服务器的Log中block,提高这个值是有帮助的。 </p>
               </div>
               <div class="section" title="13.2.9. hbase.hregion.memstore.block.multiplier">
                 <div class="titlepage">
                   <div>
                     <div>
                       <h3 class="title"><a name="perf.hregion.memstore.block.multiplier"></a>11.4.8.&nbsp;<code class="varname">hbase.hregion.memstore.block.multiplier</code></h3>
                     </div>
                   </div>
                 </div>
                 <p>参见 <a class="xref" href="#hbase.hregion.memstore.block.multiplier" title="hbase.hregion.memstore.block.multiplier"><code class="varname">hbase.hregion.memstore.block.multiplier</code></a>.  
                   如果有足够的RAM，提高这个值。 </p>
               </div>
             </div>
             <div class="section" title="13.3. Column Families的数目">
               <div class="titlepage">
                 <div>
                   <div>
                     <div>
                       <div>
                         <div>
                           <h2><a name="perf.zookeeper" id="perf.zookeeper"></a>11.5. ZooKeeper</h2>
                         </div>
                       </div>
                     </div>
                     <p>配置ZooKeeper信息，请参考 <a href="#zookeeper" title="2.5. ZooKeeper">Section 2.5, “ZooKeeper”</a>  , 参看关于使用专用磁盘部分。</p>
                     <div>
                       <div>
                         <div>
                           <h2><a name="perf.schema" id="perf.schema"></a>11.6. 模式设计</h2>
                         </div>
                       </div>
                     </div>
                     <div title="11.6.1. Number of Column Families">
                       <div>
                         <div>
                           <div>
                             <h3><a name="perf.number.of.cfs"></a>11.6.1.  列族<span class="title" style="clear: both">的数目</span></h3>
                           </div>
                         </div>
                       </div>
                       <p>参见 <a href="#number.of.cfs" title="6.2.  On the number of column families">Section 6.2, “ On the number of column families ”</a>.</p>
                     </div>
                     <div title="11.6.2. Key and Attribute Lengths">
                       <div>
                         <div>
                           <div>
                             <h3><a name="perf.schema.keys"></a>11.6.2. 键和属性长度</h3>
                           </div>
                         </div>
                       </div>
                       <p>参考 <a href="#keysize" title="6.3.2. Try to minimize row and column sizes">Section 6.3.2, “Try to minimize row and column sizes”</a>. 参考  <a href="#perf.compression.however" title="11.6.7.1. However...">Section 11.6.7.1, “However...”</a> 获取压缩申请终止( compression caveats)</p>
                     </div>
                     <div title="11.6.3. Table RegionSize">
                       <div>
                         <div>
                           <div>
                             <h3><a name="schema.regionsize"></a>11.6.3. 表的区域大小</h3>
                           </div>
                         </div>
                       </div>
                       <p>区域大小可以通过基于每张表设置，当某些表需要与缺省设置的区域大小不同时，通过 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HTableDescriptor.html" target="_top">HTableDescriptor</a> 的setFileSize 的事件设置。</p>
                       <p>参考 <a href="#perf.number.of.regions" title="11.4.1. Number of Regions">Section 11.4.1, “Number of Regions”</a> 获取更多信息。</p>
                     </div>
                     <div title="11.6.4. Bloom Filters">
                       <div>
                         <div>
                           <div>
                             <h3><a name="schema.bloom"></a>11.6.4. 布隆过滤(Bloom Filters)</h3>
                           </div>
                         </div>
                       </div>
                       <p>布隆过滤可以每列族单独启用。使用 HColumnDescriptor.setBloomFilterType(NONE | ROW | ROWCOL) 对列族单独启用布隆。  Default = NONE 没有布隆过滤。对 ROW，行键的哈希在每次插入行时将被添加到布隆。对 ROWCOL，行键 + 列族 + 列族修饰的哈希将在每次插入行时添加到布隆。</p>
                       <p>参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a> 和 <a href="#blooms" title="9.7.6. Bloom Filters">Section 9.7.6, “布隆过滤(Bloom Filters)”</a> 获取更多信息。</p>
                     </div>
                     <div title="11.6.5. ColumnFamily BlockSize">
                       <div>
                         <div>
                           <div>
                             <h3><a name="schema.cf.blocksize"></a>11.6.5. 列族块大小</h3>
                           </div>
                         </div>
                       </div>
                       <p>The blocksize can be configured for each ColumnFamily in a table, and this defaults to 64k. Larger cell values require larger blocksizes. There is an inverse relationship between blocksize and the resulting StoreFile indexes (i.e., if the blocksize is doubled then the resulting indexes should be roughly halved).</p>
                       <p>参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a> and <a href="#store" title="9.7.5. Store">Section 9.7.5, “Store”</a>获取更多信息。</p>
                     </div>
                     <div title="11.6.6. In-Memory ColumnFamilies">
                       <div>
                         <div>
                           <div>
                             <h3><a name="cf.in.memory"></a>11.6.6. 内存中的列族</h3>
                           </div>
                         </div>
                       </div>
                       <p>ColumnFamilies can optionally be defined as in-memory. Data is still persisted to disk, just like any other ColumnFamily. In-memory blocks have the highest priority in the <a href="#block.cache" title="9.6.4. Block Cache">Section 9.6.4, “Block Cache”</a>, but it is not a guarantee that the entire table will be in memory.</p>
                       <p>参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a> 获取更多信息。</p>
                     </div>
                     <div title="11.6.7. Compression">
                       <div>
                         <div>
                           <div>
                             <h3><a name="perf.compression"></a>11.6.7. 压缩</h3>
                           </div>
                         </div>
                       </div>
                       <p>生产系统应该采用列族压缩定义。 参考 <a href="#compression" title="Appendix C. Compression In HBase">Appendix C, <em>Compression In HBase</em></a> 获取更多信息。</p>
                       <div title="11.6.7.1. However...">
                         <div>
                           <div>
                             <div>
                               <h4><a name="perf.compression.however"></a>11.6.7.1. 然而...</h4>
                             </div>
                           </div>
                         </div>
                         <p>Compression deflates data <em>on disk</em>. When it's in-memory (e.g., in the MemStore) or on the wire (e.g., transferring between RegionServer and Client) it's inflated. So while using ColumnFamily compression is a best practice, but it's not going to completely eliminate the impact of over-sized Keys, over-sized ColumnFamily names, or over-sized Column names.</p>
                         <p>参考 <a href="#keysize" title="6.3.2. Try to minimize row and column sizes">Section 6.3.2, “Try to minimize row and column sizes”</a> on for schema design tips, and <a href="#keyvalue" title="9.7.5.4. KeyValue">Section 9.7.5.4, “KeyValue”</a> for more information on HBase stores data internally.</p>
                       </div>
                     </div>
                     <div title="11.7. HBase General Patterns">
                       <div>
                         <div>
                           <div>
                             <h2>11.7. HBase 通用模式</h2>
                           </div>
                         </div>
                       </div>
                       <div title="11.7.1. Constants">
                         <div>
                           <div>
                             <div>
                               <h3><a name="perf.general.constants"></a>11.7.1. 常量</h3>
                             </div>
                           </div>
                         </div>
                         <p>人们刚开始使用HBase时，趋向于写如下的代码：</p>
                         <pre>Get get = new Get(rowkey);  Result r = htable.get(get);  byte[] b = r.getValue(Bytes.toBytes("cf"), Bytes.toBytes("attr"));  // returns current version of value  </pre>
                         <p>然而，特别是在循环内(和 MapReduce 工作内), 将列族和列名转为字节数组代价昂贵。最好使用字节数组常量，如下：</p>
                         <pre>public static final byte[] CF = "cf".getBytes();  public static final byte[] ATTR = "attr".getBytes();  ...  Get get = new Get(rowkey);  Result r = htable.get(get);  byte[] b = r.getValue(CF, ATTR);  // returns current version of value  </pre>
                       </div>
                     </div>
                     <div title="11.8. Writing to HBase">
                     <div>
                     <div>
                     <div>
                     <br>
                     <p>&nbsp;</p>
                     <div class="section" title="11.7.&nbsp;Writing to HBase"><div class="titlepage"><div><div>
  <h2 class="title" style="clear: both"><a name="perf.writing"></a>11.8.&nbsp;写到 HBase</h2></div></div></div><div class="section" title="11.7.1.&nbsp;Batch Loading"><div class="titlepage"><div><div>
    <h3 class="title"><a name="perf.batch.loading"></a>11.8.1.&nbsp;<span class="title" style="clear: both">批量</span>装载</h3></div></div></div>
  <p>如果可以的话，尽量使用批量导入工具，参见 <a class="xref" href="#arch.bulk.load" title="9.8.&nbsp;Bulk Loading">Section&nbsp;9.8, “批量装载”</a><a class="link" href="http://hbase.apache.org/bulk-loads.html" target="_top"></a>.否则就要详细看看下面的内容。</p></div><div class="section" title="11.7.2.&nbsp; Table Creation: Pre-Creating Regions"><div class="titlepage"><div><div>
    <h3 class="title"><a name="precreate.regions"></a>11.8.2.&nbsp;表创建: 预创建区域(Region) </h3>
</div></div></div><p>默认情况下HBase创建表会新建一个区域。执行批量导入，意味着所有的client会写入这个区域，直到这个区域足够大，以至于分裂。一个有效的提高批量导入的性能的方式，是预创建空的区域。最好稍保守一点，因为过多的区域会实实在在的降低性能。下面是一个预创建区域的例子。
                   (注意：这个例子里需要根据应用的key进行调整。): </p>
<p>
</p><pre class="programlisting">public static boolean createTable(HBaseAdmin admin, HTableDescriptor table, byte[][] splits)
throws IOException {
  try {
    admin.createTable( table, splits );
    return true;
  } catch (TableExistsException e) {
    logger.info("table " + table.getNameAsString() + " already exists");
    // the table already exists...
    return false;  
  }
}

public static byte[][] getHexSplits(String startKey, String endKey, int numRegions) {
  byte[][] splits = new byte[numRegions-1][];
  BigInteger lowestKey = new BigInteger(startKey, 16);
  BigInteger highestKey = new BigInteger(endKey, 16);
  BigInteger range = highestKey.subtract(lowestKey);
  BigInteger regionIncrement = range.divide(BigInteger.valueOf(numRegions));
  lowestKey = lowestKey.add(regionIncrement);
  for(int i=0; i &lt; numRegions-1;i++) {
    BigInteger key = lowestKey.add(regionIncrement.multiply(BigInteger.valueOf(i)));
    byte[] b = String.format("%016x", key).getBytes();
    splits[i] = b;
  }
  return splits;
}</pre><p>
  </p></div><div class="section" title="11.7.3.&nbsp; Table Creation: Deferred Log Flush"><div class="titlepage"><div><div>
    <h3 class="title"><a name="def.log.flush"></a>11.8.3.&nbsp;
    表创建: 延迟log刷写
    </h3></div></div></div>
  <p>
 Puts的缺省行为使用 Write Ahead Log (WAL)，会导致 <code class="classname">HLog</code> 编辑立即写盘。如果采用延迟刷写，WAL编辑会保留在内存中，直到刷写周期来临。好处是集中和异步写HLog，潜在问题是如果RegionServer退出，没有刷写的日志将丢失。但这也比Puts时不使用WAL安全多了。</p>
  <p>
延迟log刷写可以通过 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HTableDescriptor.html" target="_top">HTableDescriptor</a> 在表上设置，<code class="varname">hbase.regionserver.optionallogflushinterval</code>缺省值是1000ms.
</p></div><div class="section" title="11.7.4.&nbsp;HBase Client: AutoFlush"><div class="titlepage"><div><div>
          <h3 class="title"><a name="perf.hbase.client.autoflush"></a>11.8.4.&nbsp;HBase 客户端:  
              自动刷写</h3><div class="titlepage">
                <div>
            <div>
              <h3 class="title">&nbsp;</h3>
            </div>
          </div>
        </div>
        <p>当你进行大量的Put的时候，要确认你的<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>的setAutoFlush是关闭着的。否则的话，每执行一个Put就要想区域服务器发一个请求。通过<code class="code"> htable.add(Put)</code> 和 <code class="code"> htable.add( &lt;List&gt; Put)</code>来将Put添加到写缓冲中。如果 <code class="code">autoFlush = false</code>，要等到写缓冲都填满的时候才会发起请求。要想显式的发起请求，可以调用<code class="methodname">flushCommits</code>。在<code class="classname">HTable</code>实例上进行的<code class="methodname">close</code>操作也会发起<code class="methodname">flushCommits</code></p>
</div></div></div></div><div class="section" title="11.7.5.&nbsp;HBase Client: Turn off WAL on Puts"><div class="titlepage"><div><div>
  <h3 class="title"><a name="perf.hbase.client.putwal"></a>11.8.5.&nbsp;HBase 客户端:  在Puts上关闭WAL </h3></div></div></div>
<p>一个经常讨论的在<code class="classname">Put</code>s上增加吞吐量的选项是调用 <code class="code">writeToWAL(false)</code>。关闭它意味着 RegionServer 不再将 <code class="classname">Put</code> 写到 Write Ahead Log,
          仅写到内存。<strong>然而</strong>后果是如果出现 RegionServer 失败，将<em>导致数据丢失</em>。如果调用 <code class="code">writeToWAL(false)</code> ，需保持高度警惕。你会发现实际上基本没有不同，如果你的负载很好的分布到集群中。</p>
<p>通常而言，最好对Puts使用WAL， 而增加负载吞吐量与使用 <a class="link" href="#perf.batch.loading" title="11.7.1.&nbsp;Batch Loading">bulk loading</a> 替代技术有关。</p></div><div class="section" title="11.7.6.&nbsp;HBase Client: Group Puts by RegionServer"><div class="titlepage"><div><div>
  <h3 class="title"><a name="perf.hbase.client.regiongroup"></a>11.8.6.&nbsp;HBase 客户端:  RegionServer 成组写入</h3></div></div></div><p>In addition to using the writeBuffer, grouping <code class="classname">Put</code>s by RegionServer can reduce the number of client RPC calls per writeBuffer flush. 
      There is a utility <code class="classname">HTableUtil</code> currently on TRUNK that does this, but you can either copy that or implement your own verison for
      those still on 0.90.x or earlier.
      </p></div><div class="section" title="11.7.7.&nbsp;MapReduce: Skip The Reducer"><div class="titlepage"><div><div>
        <h3 class="title"><a name="perf.hbase.write.mr.reducer"></a>11.8.7.&nbsp;MapReduce:  跳过 Reducer</h3></div></div></div><p>When writing a lot of data to an HBase table from a MR job (e.g., with <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html" target="_top">TableOutputFormat</a>), and specifically where Puts are being emitted
      from the Mapper, skip the Reducer step.  When a Reducer step is used, all of the output (Puts) from the Mapper will get spooled to disk, then sorted/shuffled to other 
      Reducers that will most likely be off-node.  It's far more efficient to just write directly to HBase.   
      </p><p>For summary jobs where HBase is used as a source and a sink, then writes will be coming from the Reducer step (e.g., summarize values then write out result). 
      This is a different processing problem than from the the above case. 
      </p></div><div class="section" title="11.7.8.&nbsp;Anti-Pattern: One Hot Region"><div class="titlepage"><div><div><h3 class="title"><a name="perf.one.region"></a>11.8.8.&nbsp;Anti-Pattern:  One Hot Region</h3></div></div></div><p>If all your data is being written to one region at a time, then re-read the
    section on processing <a class="link" href="#timeseries" title="6.3.1.&nbsp; Monotonically Increasing Row Keys/Timeseries Data">timeseries</a> data.</p><p>Also, if you are pre-splitting regions and all your data is <span class="emphasis"><em>still</em></span> winding up in a single region even though
    your keys aren't monotonically increasing, confirm that your keyspace actually works with the split strategy.  There are a 
    variety of reasons that regions may appear "well split" but won't work with your data.   As
    the HBase client communicates directly with the RegionServers, this can be obtained via 
    <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#getRegionLocation(byte[])" target="_top">HTable.getRegionLocation</a>.
    </p><p>参考 <a class="xref" href="#precreate.regions" title="11.7.2.&nbsp; Table Creation: Pre-Creating Regions">Section&nbsp;11.8.2, “
    Table Creation: Pre-Creating Regions
    ”</a>, as well as <a class="xref" href="#perf.configurations" title="11.4.&nbsp;HBase Configurations">Section&nbsp;11.4, “HBase Configurations”</a> </p></div></div>
    
    <div class="section" title="11.8.&nbsp;Reading from HBase"><div class="titlepage"><div><div>
      <h2 class="title" style="clear: both"><a name="perf.reading"></a>11.9. 从HBase读</h2></div></div></div><div class="section" title="11.8.1.&nbsp;Scan Caching"><div class="titlepage"><div><div>
        <h3 class="title"><a name="perf.hbase.client.caching"></a>11.9.1.&nbsp;Scan 缓存</h3></div></div></div><p>如果HBase的输入源是一个MapReduce Job，要确保输入的<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a>的<code class="methodname">setCaching</code>值要比默认值0要大。使用默认值就意味着map-task每一行都会去请求一下region-server。可以把这个值设为500，这样就可以一次传输500行。当然这也是需要权衡的，过大的值会同时消耗客户端和服务端很大的内存，不是越大越好。</p>
    <div class="section" title="11.8.1.1.&nbsp;Scan Caching in MapReduce Jobs"><div class="titlepage"><div><div><h4 class="title"><a name="perf.hbase.client.caching.mr"></a>11.9.1.1.&nbsp;Scan Caching in MapReduce Jobs</h4></div></div></div><p>Scan settings in MapReduce jobs deserve special attention.  Timeouts can result (e.g., UnknownScannerException)
        in Map tasks if it takes longer to process a batch of records before the client goes back to the RegionServer for the
        next set of data.  This problem can occur because there is non-trivial processing occuring per row.  If you process
        rows quickly, set caching higher.  If you process rows more slowly (e.g., lots of transformations per row, writes), 
        then set caching lower.
        </p><p>Timeouts can also happen in a non-MapReduce use case (i.e., single threaded HBase client doing a Scan), but the
        processing that is often performed in MapReduce jobs tends to exacerbate this issue.
        </p></div></div><div class="section" title="11.8.2.&nbsp;Scan Attribute Selection"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.selection"></a>11.9.2.&nbsp;Scan 属性选择</h3></div></div></div><p>当Scan用来处理大量的行的时候(尤其是作为MapReduce的输入)，要注意的是选择了什么字段。如果调用了 <code class="code">scan.addFamily</code>，这个列族的所有属性都会返回。如果只是想过滤其中的一小部分，就指定那几个column，否则就会造成很大浪费，影响性能。 </p>
        </div><div class="section" title="11.8.3.&nbsp;MapReduce - Input Splits"><div class="titlepage"><div><div>
          <h3 class="title"><a name="perf.hbase.mr.input"></a>11.9.3.&nbsp;MapReduce - 输入分割</h3></div></div></div><p>For MapReduce jobs that use HBase tables as a source, if there a pattern where the "slow" map tasks seem to 
        have the same Input Split (i.e., the RegionServer serving the data), see the 
        Troubleshooting Case Study in <a class="xref" href="#casestudies.slownode" title="13.3.1.&nbsp;Case Study #1 (Performance Issue On A Single Node)">Section&nbsp;13.3.1, “Case Study #1 (Performance Issue On A Single Node)”</a>.
        </p></div><div class="section" title="11.8.4.&nbsp;Close ResultScanners"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.scannerclose"></a>11.9.4.&nbsp;关闭 ResultScanners</h3></div></div></div><p>这与其说是提高性能，倒不如说是避免发生性能问题。如果你忘记了关闭<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/ResultScanner.html" target="_top">ResultScanners</a>，会导致RegionServer出现问题。所以一定要把ResultScanner包含在try/catch 块中... </p>
        <pre class="programlisting">Scan scan = new Scan();
// set attrs...
ResultScanner rs = htable.getScanner(scan);
try {
  for (Result r = rs.next(); r != null; r = rs.next()) {
  // process result...
} finally {
  rs.close();  // always close the ResultScanner!
}
htable.close();</pre></div><div class="section" title="11.8.5.&nbsp;Block Cache"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.blockcache"></a>11.9.5.&nbsp;块缓存</h3>
</div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a>实例可以在RegionServer中使用块缓存，可以由<code class="methodname">setCacheBlocks</code>方法控制。如果Scan是MapReduce的输入源，要将这个值设置为 <code class="varname">false</code>。对于经常读到的行，就建议使用块缓冲。</p>
</div><div class="section" title="11.8.6.&nbsp;Optimal Loading of Row Keys"><div class="titlepage"><div><div>
  <h3 class="title"><a name="perf.hbase.client.rowkeyonly"></a>11.9.6.&nbsp;  行键的负载优化</h3></div></div></div><p>当<a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">scan</a>一个表的时候，
                   如果仅仅需要行键（不需要no families, qualifiers, values 和 timestamps）,在加入FilterList的时候，要使用Scanner的<code class="methodname">setFilter</code>方法的时候，要填上<code class="varname">MUST_PASS_ALL</code>操作参数(译者注：相当于And操作符)。一个FilterList要包含一个 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html" target="_top">FirstKeyOnlyFilter</a> 和一个 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/KeyOnlyFilter.html" target="_top">KeyOnlyFilter</a>.通过这样的filter组合，就算在最坏的情况下，RegionServer只会从磁盘读一个值，同时最小化客户端的网络带宽占用。 </p>
</div><div class="section" title="11.8.7.&nbsp;Concurrency: Monitor Data Spread"><div class="titlepage"><div><div>
  <h3 class="title"><a name="perf.hbase.read.dist"></a>11.9.7.&nbsp;并发:  监测数据扩散</h3></div></div></div>
<p>当优化大量读取时，监测数据扩散到目标表。如果目标表含区域太少，读取时感觉像只有很少节点提供服务一样。</p>
  <p>参考 <a class="xref" href="#precreate.regions" title="11.7.2.&nbsp; Table Creation: Pre-Creating Regions">Section&nbsp;11.9.2, “
    Table Creation: Pre-Creating Regions
    ”</a>, 及 <a class="xref" href="#perf.configurations" title="11.4.&nbsp;HBase Configurations">Section&nbsp;11.4, “HBase Configurations”</a> </p>
      <div>
        <div>
          <div>
            <h3>11.9.8. 布隆过滤(Bloom Filters)</h3>
          </div>
        </div>
      </div>
      <p>启用布隆过滤可以节省必须读磁盘过程，可以有助于改进读取延迟。</p>
      <p><a href="http://en.wikipedia.org/wiki/Bloom_filter" target="_top">Bloom filters</a> 在 <a href="https://issues.apache.org/jira/browse/HBASE-1200" target="_top">HBase-1200 Add bloomfilters</a>中开发。[<a name="d352e7127" href="#ftn.d352e7127">28</a>][<a name="d352e7139" href="#ftn.d352e7139">29</a>] </p>
      <p>参考 <a href="#schema.bloom" title="11.6.4. Bloom Filters">Section 11.6.4, &ldquo;布隆过滤(Bloom Filters)&rdquo;</a>.</p>
      <div title="11.8.8.1. Bloom StoreFile footprint">
        <div>
          <div>
            <div>
              <h4><a name="bloom_footprint"></a>11.9.8.1. Bloom StoreFile footprint</h4>
            </div>
          </div>
        </div>
        <p>Bloom filters add an entry to the StoreFile general FileInfo data structure and then two extra entries to the StoreFilemetadata section.</p>
        <div title="11.8.8.1.1. BloomFilter in the StoreFile FileInfo data structure">
          <div>
            <div>
              <div>
                <h5><a name="d352e7163"></a>11.9.8.1.1. BloomFilter in the StoreFile FileInfo data structure</h5>
              </div>
            </div>
          </div>
          <p>FileInfo has a BLOOM_FILTER_TYPE entry which is set to NONE, ROW or ROWCOL.</p>
        </div>
        <div title="11.8.8.1.2. BloomFilter entries in StoreFile metadata">
          <div>
            <div>
              <div>
                <h5><a name="d352e7187"></a>11.9.8.1.2. BloomFilter entries in StoreFile metadata</h5>
              </div>
            </div>
          </div>
          <p>BLOOM_FILTER_META holds Bloom Size, Hash Function used, etc. Its small in size and is cached on StoreFile.Reader load</p>
          <p>BLOOM_FILTER_DATA is the actual bloomfilter data. Obtained on-demand. Stored in the LRU cache, if it is enabled (Its enabled by default).</p>
        </div>
      </div>
      <p>&nbsp;</p>
      <div class="section" title="3.5. 必须的配置">
        <div class="titlepage">
          <div>
            <div>
              <div>
                <div>
                  <div>
                    <h4><a name="config.bloom" id="config.bloom"></a>11.9.8.2. 布隆过滤(Bloom Filter) 配置</h4>
                  </div>
                </div>
              </div>
              <div title="2.9.1. io.hfile.bloom.enabled global kill switch">
                <div>
                  <div>
                    <div>
                      <h5><a name="d1934e2830"></a>11.9.8.2.1. io.hfile.bloom.enabled 全局杀死开关</h5>
                    </div>
                  </div>
                </div>
                <p>配置文件的io.hfile.bloom.enabled 是一个当出错时的杀死开关。Default = true.</p>
              </div>
              <div title="2.9.2. io.hfile.bloom.error.rate">
                <div>
                  <div>
                    <div>
                      <h5><a name="d1934e2845"></a>11.9.8.2.2. io.hfile.bloom.error.rate</h5>
                    </div>
                  </div>
                </div>
                <p>io.hfile.bloom.error.rate = 平均误报率( average false positive rate ). 缺省 = 1%. 降低率为 ½ (如 .5%) == +1 位每布隆入口。</p>
              </div>
              <div title="2.9.3. io.hfile.bloom.max.fold">
                <div>
                  <div>
                    <div>
                      <h5><a name="d1934e2853"></a>11.9.8.2.3. io.hfile.bloom.max.fold</h5>
                    </div>
                  </div>
                </div>
                <p>io.hfile.bloom.max.fold = 保证最小折叠速率(guaranteed minimum fold rate). 大多时候不要管. Default = 7, 或压缩到原来大小的至少 1/128. 想获取更多本选项的意义，参看本文档 <em>开发进程</em> 节 <a href="https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf" target="_top">BloomFilters in HBase</a> </p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="section" title="3.6. 推荐的配置">
        <div class="titlepage">
          <div>
            <div>
              <div class="footnote">
                <p>&nbsp;</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>&nbsp;</p>
</div></div>
    
    
    
                     <div>
                       <div>
                         <div>
                           <h2><a name="perf.deleting" id="perf.deleting"></a>11.10. 从HBase删除</h2>
                         </div>
                       </div>
                     </div>
                     <div title="11.9.1. Using HBase Tables as Queues">
                       <div>
                         <div>
                           <div>
                             <h3><a name="perf.deleting.queue"></a>11.10.1. 将 HBase 表当 Queues用</h3>
                           </div>
                         </div>
                       </div>
                       <p>HBase tables are sometimes used as queues. In this case, special care must be taken to regularly perform major compactions on tables used in this manner. As is documented in <a href="#datamodel" title="Chapter 5. Data Model">Chapter 5, <em>Data Model</em></a>, marking rows as deleted creates additional StoreFiles which then need to be processed on reads. Tombstones only get cleaned up with major compactions.</p>
                       <p>参考  <a href="#compaction" title="9.7.5.5. Compaction">Section 9.7.5.5, “Compaction”</a> 和 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact(java.lang.String)" target="_top">HBaseAdmin.majorCompact</a>.</p>
                     </div>
                     <div title="11.9.2. Delete RPC Behavior">
                       <div>
                         <div>
                           <div>
                             <h3><a name="perf.deleting.rpc"></a>11.10.2. 删除的 RPC 行为</h3>
                           </div>
                         </div>
                       </div>
                       <p>Be aware that htable.delete(Delete) doesn't use the writeBuffer. It will execute an RegionServer RPC with each invocation. For a large number of deletes, consider htable.delete(List).</p>
                       <p>参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29" target="_top">http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29</a></p>
                     </div>
                     <div>
                       <div>
                         <div>
                           <h2><a name="perf.hdfs" id="perf.hdfs"></a>11.11. HDFS</h2>
                         </div>
                       </div>
                     </div>
                     <p>由于 HBase 在 <a href="#arch.hdfs" title="9.9. HDFS">Section 9.9, “HDFS”</a> 上运行，it is important to understand how it works and how it affects HBase.</p>
                     <div title="11.10.1. Current Issues With Low-Latency Reads">
                       <div>
                         <div>
                           <div>
                             <h3><a name="perf.hdfs.curr"></a>11.11.1. Current Issues With Low-Latency Reads</h3>
                           </div>
                         </div>
                       </div>
                       <p>The original use-case for HDFS was batch processing. As such, there low-latency reads were historically not a priority. With the increased adoption of HBase this is changing, and several improvements are already in development. 参考 the <a href="https://issues.apache.org/jira/browse/HDFS-1599" target="_top">Umbrella Jira Ticket for HDFS Improvements for HBase</a>.</p>
                     </div>
                     <div title="11.10.2. Performance Comparisons of HBase vs. HDFS">
                       <div>
                         <div>
                           <div>
                             <div title="11.10.2. Leveraging local data">
                               <div>
                                 <div>
                                   <div>
                                     <h3><br>
                                       11.11.2. Leveraging local data</h3>
                                   </div>
                                 </div>
                               </div>
                               <p>Since Hadoop 1.0.0 (also 0.22.1, 0.23.1, CDH3u3 and HDP 1.0) via <a href="https://issues.apache.org/jira/browse/HDFS-2246" target="_top">HDFS-2246</a>, it is possible for the DFSClient to take a "short circuit" and read directly from disk instead of going through the DataNode when the data is local. What this means for HBase is that the RegionServers can read directly off their machine's disks instead of having to open a socket to talk to the DataNode, the former being generally much faster[<a name="d352e7302" href="#ftn.d352e7302">30</a>]. Also see <a href="http://search-hadoop.com/m/zV6dKrLCVh1" target="_top">HBase, mail # dev - read short circuit</a> thread for more discussion around short circuit reads.</p>
                               <p>To enable "short circuit" reads, you must set two configurations. First, the hdfs-site.xml needs to be amended. Set the property dfs.block.local-path-access.user to be the <em>only</em> user that can use the shortcut. This has to be the user that started HBase. Then in hbase-site.xml, set dfs.client.read.shortcircuit to be true</p>
                               <p>For optimal performance when short-circuit reads are enabled, it is recommended that HDFS checksums are disabled. To maintain data integrity with HDFS checksums disabled, HBase can be configured to write its own checksums into its datablocks and verify against these. See <a href="#hbase.regionserver.checksum.verify" title="11.4.9. hbase.regionserver.checksum.verify">Section 11.4.9, &ldquo;hbase.regionserver.checksum.verify&rdquo;</a>.</p>
                               <p>The DataNodes need to be restarted in order to pick up the new configuration. Be aware that if a process started under another username than the one configured here also has the shortcircuit enabled, it will get an Exception regarding an unauthorized access but the data will still be read.</p>
                             </div>
                             <div title="11.10.3. Performance Comparisons of HBase vs. HDFS">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="perf.hdfs.comp"></a>11.11.3. Performance Comparisons of HBase vs. HDFS</h3>
                                   </div>
                                 </div>
                               </div>
                               <p>A fairly common question on the dist-list is why HBase isn't as performant as HDFS files in a batch context (e.g., as a MapReduce source or sink). The short answer is that HBase is doing a lot more than HDFS (e.g., reading the KeyValues, returning the most current row or specified timestamps, etc.), and as such HBase is 4-5 times slower than HDFS in this processing context. Not that there isn't room for improvement (and this gap will, over time, be reduced), but HDFS will always be faster in this use-case.</p>
                             </div>
                         <h3>&nbsp;</h3></div></div></div>
                     </div>
                     <div>
                       <div>
                         <div>
                           <h2><a name="perf.ec2" id="perf.ec2"></a>11.12. Amazon EC2</h2>
                         </div>
                       </div>
                     </div>
                     <p>Performance questions are common on Amazon EC2 environments because it is a shared environment. You will not see the same throughput as a dedicated server. In terms of running tests on EC2, run them several times for the same reason (i.e., it's a shared environment and you don't know what else is happening on the server).</p>
                     <p>If you are running on EC2 and post performance questions on the dist-list, please state this fact up-front that because EC2 issues are practically a separate class of performance issues.</p>
                     <div>
                       <div>
                         <div>
                           <h2><a name="perf.casestudy" id="perf.casestudy"></a>11.13. Case Studies</h2>
                         </div>
                       </div>
                     </div>
                     <p>For Performance and Troubleshooting Case Studies, see <a href="#casestudies" title="Chapter 13. Case Studies">Chapter 13, <em>Case Studies</em></a>.</p>
                     <div>
                       <p>[<a id="ftn.d352e6660" href="#d352e6660">27</a>] The latest jvms do better regards fragmentation so make sure you are running a recent release. Read down in the message,<a href="http://osdir.com/ml/hotspot-gc-use/2011-11/msg00002.html" target="_top">Identifying concurrent mode failures caused by fragmentation</a>.</p>
                     </div>
                     <div>
                       <p>[<a id="ftn.d352e7127" href="#d352e7127">28</a>] For description of the development process -- why static blooms rather than dynamic -- and for an overview of the unique properties that pertain to blooms in HBase, as well as possible future directions, see the <em>Development Process</em> section of the document <a href="https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf" target="_top">BloomFilters in HBase</a> attached to <a href="https://issues.apache.org/jira/browse/HBASE-1200" target="_top">HBase-1200</a>.</p>
                     </div>
                     <div>
                       <p>[<a id="ftn.d352e7139" href="#d352e7139">29</a>] The bloom filters described here are actually version two of blooms in HBase. In versions up to 0.19.x, HBase had a dynamic bloom option based on work done by the <a href="http://www.one-lab.org/" target="_top">European Commission One-Lab Project 034819</a>. The core of the HBase bloom work was later pulled up into Hadoop to implement org.apache.hadoop.io.BloomMapFile. Version 1 of HBase blooms never worked that well. Version 2 is a rewrite from scratch though again it starts with the one-lab work.</p>
                     </div>
                     <div>
                       <p>[<a id="ftn.d352e7302" href="#d352e7302">30</a>] See JD's <a href="http://files.meetup.com/1350427/hug_ebay_jdcryans.pdf" target="_top">Performance Talk</a></p>
                     </div>
                     <p>&nbsp;</p>
                     <div class="titlepage">
                       <div>
                         <div>
                           <h2 class="title"><a name="trouble"></a>Chapter&nbsp;12.&nbsp;HBase的故障排除和Debug</h2>
                         </div>
                       </div>
                     </div>
                     <div class="toc">
                       <p><b>Table of Contents</b></p>
                       <dl>
                         <dd><a href="#trouble.general">12.1. 通用指引</a></dd>
                         <dd>
                         <dl>
                           <dt><a href="#trouble.log">12.2. Logs</a></dt>
                           <dt><a href="#trouble.resources">12.3. 资源</a></dt>
                           <dt><a href="#trouble.tools">12.4. 工具</a></dt>
                           <dt><a href="#trouble.client">12.5. 客户端</a></dt>
                           <dt><a href="#trouble.mapreduce">12.6. MapReduce</a></dt>
                           <dt><a href="#trouble.namenode">12.7. NameNode</a></dt>
                           <dt><a href="#trouble.network">12.8. 网络</a></dt>
                           <dt><a href="#trouble.rs">12.9. RegionServer</a></dt>
                           <dt><a href="#trouble.master">12.10. Master</a></dt>
                           <dt><a href="#trouble.zookeeper">12.11. ZooKeeper</a></dt>
                           <dt><a href="#trouble.ec2">12.12. Amazon EC2</a></dt>
                           <dt><a href="#trouble.versions">12.13. HBase 和 Hadoop 版本相关</a></dt>
                           <dt><a href="#trouble.casestudy">12.14. 案例</a></dt>
                           </dl>
                         </dd>
                         <dt>&nbsp;</dt>
                         <div class="section" title="12.5.&nbsp;Client"><div class="titlepage"><div><div></div></div></div></div>
           
                         <dt><a href="#trouble.client">12.4. 客户端</a></dt>
                         <dd>
                           <dl>
                             <dt><a href="#trouble.client.scantimeout">12.4.1. ScannerTimeoutException</a></dt>
                           </dl>
                         </dd>
                         <dt><a href="#trouble.rs">12.5. RegionServer</a></dt>
                         <dd>
                           <dl>
                             <dt><a href="#trouble.rs.startup">12.5.1. 启动错误</a></dt>
                             <dt><a href="#trouble.rs.runtime">12.5.2. 运行时错误</a></dt>
                             <dt><a href="#trouble.rs.shutdown">12.5.3. 终止错误</a></dt>
                           </dl>
                         </dd>
                         <dt><a href="#trouble.master">12.6. Master</a></dt>
                         <dd>
                           <dl>
                             <dt><a href="#trouble.master.startup">12.6.1. 启动错误</a></dt>
                             <dt><a href="#trouble.master.startup">12.6.2. 终止错误</a></dt>
                           </dl>
                         </dd>
                       </dl>
                     </div>
                     <div class="section" title="15.1. 一般准则">
                       <div class="titlepage">
                         <div>
                           <div>
                             <h2 class="title" style="clear: both"><a name="trouble.general"></a>12.1.&nbsp;一般准则</h2>
                           </div>
                         </div>
                       </div>
                       <p> 总是先从主服务器的日志开始(TODO: 哪些行?)。通常情况下，他总是一行一行的重复信息。如果不是这样，说明有问题，可以Google或是用<a class="link" href="http://search-hadoop.com/" target="_top">search-hadoop.com</a>来搜索遇到的异常。 </p>
                       <p> 错误很少仅仅单独出现在HBase中，通常是某一个地方出了问题，引起各处大量异常和调用栈跟踪信息。遇到这样的错误，最好的办法是往上查日志，找到最初的异常。例如区域服务器会在退出的时候打印一些度量信息。Grep这个<span class="emphasis"><em>转储</em></span> 应该可以找到最初的异常信息。 </p>
                       <p> 区域服务器的自杀是很“正常”的。当一些事情发生错误的，他们就会自杀。如果ulimit和xcievers(最重要的两个设定，详见<a class="xref" href="#ulimit" title="1.3.1.6.  ulimit 和 nproc">Section&nbsp;2.2.5, “ <code class="varname">ulimit</code> 和 <code class="varname">nproc</code> ”</a>)没有修改，HDFS将无法运转正常，在HBase看来，HDFS死掉了。假想一下，你的MySQL突然无法访问它的文件系统，他会怎么做。同样的事情会发生在HBase和HDFS上。还有一个造成区域服务器切腹自杀的常见的原因是，他们执行了一个长时间的GC操作，这个时间超过了ZooKeeper的会话时长。关于GC停顿的详细信息，参见Todd Lipcon的 <a class="link" href="http://www.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/" target="_top">3 part blog post</a> by Todd Lipcon
                         和上面的 <a class="xref" href="#gcpause" title="13.1.1.1. 长时间GC停顿">Section&nbsp;11.3.1.1, “长时间GC停顿”</a>. </p>
                     </div>
                     <div class="section" title="15.2. Logs">
                       <div class="titlepage">
                         <div>
                           <div>
                             <h2 class="title" style="clear: both"><a name="trouble.log"></a>12.2.&nbsp;Logs</h2>
                           </div>
                         </div>
                       </div>
                       <p> 重要日志的位置( &lt;user&gt;是启动服务的用户，&lt;hostname&gt; 是机器的名字) </p>
                       <p> NameNode: <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-namenode-&lt;hostname&gt;.log</code> </p>
                       <p> DataNode: <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-datanode-&lt;hostname&gt;.log</code> </p>
                       <p> JobTracker: <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-jobtracker-&lt;hostname&gt;.log</code> </p>
                       <p> TaskTracker: <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-jobtracker-&lt;hostname&gt;.log</code> </p>
                       <p> HMaster: <code class="filename">$HBASE_HOME/logs/hbase-&lt;user&gt;-master-&lt;hostname&gt;.log</code> </p>
                       <p> RegionServer: <code class="filename">$HBASE_HOME/logs/hbase-&lt;user&gt;-regionserver-&lt;hostname&gt;.log</code> </p>
                       <p> ZooKeeper: <code class="filename">TODO</code> </p>
                       <div class="section" title="15.2.1. Log 位置">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.log.locations"></a>12.2.1.&nbsp;Log 位置</h3>
                             </div>
                           </div>
                         </div>
                         <p>对于单节点模式，Log都会在一台机器上，但是对于生产环境，都会运行在一个集群上。</p>
                         <div class="section" title="15.2.1.1. NameNode">
                           <div class="titlepage">
                             <div>
                               <div>
                                 <h4 class="title"><a name="trouble.log.locations.namenode"></a>12.2.1.1.&nbsp;NameNode</h4>
                               </div>
                             </div>
                           </div>
                           <p>NameNode的日志在NameNode server上。HBase Master 通常也运行在NameNode server上，ZooKeeper通常也是这样。</p>
                           <p>对于小一点的机器，JobTracker也通常运行在NameNode server上面。</p>
                         </div>
                         <div class="section" title="15.2.1.2. DataNode">
                           <div class="titlepage">
                             <div>
                               <div>
                                 <h4 class="title"><a name="trouble.log.locations.datanode"></a>12.2.1.2.&nbsp;DataNode</h4>
                               </div>
                             </div>
                           </div>
                           <p>每一台DataNode server有一个HDFS的日志，Region有一个HBase日志。</p>
                           <p>每个DataNode server还有一份TaskTracker的日志，来记录MapReduce的Task信息。</p>
                         </div>
                       </div>
                     </div>
                     <div class="section" title="12.2.2.&nbsp;Log Levels"><div class="titlepage"><div><div>
                       <h3 class="title"><a name="trouble.log.levels"></a>12.2.2.&nbsp;日志级别</h3></div></div></div><div class="section" title="12.2.2.1.&nbsp;Enabling RPC-level logging"><div class="titlepage"><div><div>
                         <h4 class="title"><a name="rpc.logging"></a>12.2.2.1.&nbsp;启用 RPC级别日志</h4></div></div></div><p>Enabling the RPC-level logging on a RegionServer can often given
           insight on timings at the server.  Once enabled, the amount of log
           spewed is voluminous.  It is not recommended that you leave this
           logging on for more than short bursts of time.  To enable RPC-level
           logging, browse to the RegionServer UI and click on 
           <span class="emphasis"><em>Log Level</em></span>.  Set the log level to <code class="varname">DEBUG</code> for the package
           <code class="classname">org.apache.hadoop.ipc</code> (Thats right, for
           <code class="classname">hadoop.ipc</code>, NOT, <code class="classname">hbase.ipc</code>).  Then tail the RegionServers log.  Analyze.</p><p>To disable, set the logging level back to <code class="varname">INFO</code> level.
           </p></div></div>
           <div class="section" title="12.2.3.&nbsp;JVM Garbage Collection Logs"><div class="titlepage"><div><div>
             <h3 class="title"><a name="trouble.log.gc"></a>12.2.3.&nbsp;JVM 垃圾收集日志</h3></div></div></div><p>HBase is memory intensive, and using the default GC you can see long pauses in all threads including the <span class="emphasis"><em>Juliet Pause</em></span> aka "GC of Death". 
           To help debug this or confirm this is happening GC logging can be turned on in the Java virtual machine.  
          </p><p>
          To enable, in <code class="filename">hbase-env.sh</code> add:
          </p><pre class="programlisting"> 
export HBASE_OPTS="-XX:+UseConcMarkSweepGC -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/home/hadoop/hbase/logs/gc-hbase.log"
          </pre><p>
           Adjust the log directory to wherever you log.  Note:  The GC log does NOT roll automatically, so you'll have to keep an eye on it so it doesn't fill up the disk. 
          </p><p>
         At this point you should see logs like so:
          </p><pre class="programlisting">64898.952: [GC [1 CMS-initial-mark: 2811538K(3055704K)] 2812179K(3061272K), 0.0007360 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
64898.953: [CMS-concurrent-mark-start]
64898.971: [GC 64898.971: [ParNew: 5567K-&gt;576K(5568K), 0.0101110 secs] 2817105K-&gt;2812715K(3061272K), 0.0102200 secs] [Times: user=0.07 sys=0.00, real=0.01 secs] 
          </pre><p>
          </p><p>
           In this section, the first line indicates a 0.0007360 second pause for the CMS to initially mark. This pauses the entire VM, all threads for that period of time.
            </p><p>
           The third line indicates a "minor GC", which pauses the VM for 0.0101110 seconds - aka 10 milliseconds. It has reduced the "ParNew" from about 5.5m to 576k.
           Later on in this cycle we see:
           </p><pre class="programlisting"> 
64901.445: [CMS-concurrent-mark: 1.542/2.492 secs] [Times: user=10.49 sys=0.33, real=2.49 secs] 
64901.445: [CMS-concurrent-preclean-start]
64901.453: [GC 64901.453: [ParNew: 5505K-&gt;573K(5568K), 0.0062440 secs] 2868746K-&gt;2864292K(3061272K), 0.0063360 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
64901.476: [GC 64901.476: [ParNew: 5563K-&gt;575K(5568K), 0.0072510 secs] 2869283K-&gt;2864837K(3061272K), 0.0073320 secs] [Times: user=0.05 sys=0.01, real=0.01 secs] 
64901.500: [GC 64901.500: [ParNew: 5517K-&gt;573K(5568K), 0.0120390 secs] 2869780K-&gt;2865267K(3061272K), 0.0121150 secs] [Times: user=0.09 sys=0.00, real=0.01 secs] 
64901.529: [GC 64901.529: [ParNew: 5507K-&gt;569K(5568K), 0.0086240 secs] 2870200K-&gt;2865742K(3061272K), 0.0087180 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
64901.554: [GC 64901.555: [ParNew: 5516K-&gt;575K(5568K), 0.0107130 secs] 2870689K-&gt;2866291K(3061272K), 0.0107820 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
64901.578: [CMS-concurrent-preclean: 0.070/0.133 secs] [Times: user=0.48 sys=0.01, real=0.14 secs] 
64901.578: [CMS-concurrent-abortable-preclean-start]
64901.584: [GC 64901.584: [ParNew: 5504K-&gt;571K(5568K), 0.0087270 secs] 2871220K-&gt;2866830K(3061272K), 0.0088220 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
64901.609: [GC 64901.609: [ParNew: 5512K-&gt;569K(5568K), 0.0063370 secs] 2871771K-&gt;2867322K(3061272K), 0.0064230 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
64901.615: [CMS-concurrent-abortable-preclean: 0.007/0.037 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] 
64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs] 
64901.621: [CMS-concurrent-sweep-start]
            </pre><p>
            </p><p>
            The first line indicates that the CMS concurrent mark (finding garbage) has taken 2.4 seconds. But this is a _concurrent_ 2.4 seconds, Java has not been paused at any point in time.
            </p><p>
            There are a few more minor GCs, then there is a pause at the 2nd last line:
            </p><pre class="programlisting">  
64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs] 
            </pre><p>
            </p><p>
            The pause here is 0.0049380 seconds (aka 4.9 milliseconds) to 'remark' the heap.  
            </p><p>
            At this point the sweep starts, and you can watch the heap size go down:
            </p><pre class="programlisting">64901.637: [GC 64901.637: [ParNew: 5501K-&gt;569K(5568K), 0.0097350 secs] 2871958K-&gt;2867441K(3061272K), 0.0098370 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
...  lines removed ...
64904.936: [GC 64904.936: [ParNew: 5532K-&gt;568K(5568K), 0.0070720 secs] 1365024K-&gt;1360689K(3061272K), 0.0071930 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
64904.953: [CMS-concurrent-sweep: 2.030/3.332 secs] [Times: user=9.57 sys=0.26, real=3.33 secs] 
            </pre><p>
            At this point, the CMS sweep took 3.332 seconds, and heap went from about ~ 2.8 GB to 1.3 GB (approximate).
            </p><p>
            The key points here is to keep all these pauses low. CMS pauses are always low, but if your ParNew starts growing, you can see minor GC pauses approach 100ms, exceed 100ms and hit as high at 400ms.
            </p><p>
            This can be due to the size of the ParNew, which should be relatively small. If your ParNew is very large after running HBase for a while, in one example a ParNew was about 150MB, then you might have to constrain the size of ParNew (The larger it is, the longer the collections take but if its too small, objects are promoted to old gen too quickly). In the below we constrain new gen size to 64m.
            </p><p>
             Add this to HBASE_OPTS:
            </p><pre class="programlisting"> 
export HBASE_OPTS="-XX:NewSize=64m -XX:MaxNewSize=64m &lt;cms options from above&gt; &lt;gc logging options from above&gt;"
            </pre><p>
            </p><p>
            For more information on GC pauses, see the <a class="link" href="http://www.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/" target="_top">3 part blog post</a>  by Todd Lipcon
            and <a class="xref" href="#gcpause" title="11.3.1.1.&nbsp;Long GC pauses">Section&nbsp;11.3.1.1, “Long GC pauses”</a> above.
            </p></div>
                     <div class="section" title="15.3. 工具">
                       <div class="titlepage">
                         <div>
                           <div>
                             <div>
                               <div>
                                 <div>
                                   <h2><a name="trouble.resources" id="trouble.resources"></a>12.3. 资源</h2>
                                 </div>
                               </div>
                             </div>
                             <div title="12.3.1. search-hadoop.com">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="trouble.resources.searchhadoop"></a>12.3.1. search-hadoop.com</h3>
                                   </div>
                                 </div>
                               </div>
                               <p><a href="http://search-hadoop.com/" target="_top">search-hadoop.com</a> 索引了全部邮件列表，很适合做历史检索。有问题时先在这里查询，因为别人可能已经遇到过你的问题。</p>
                             </div>
                             <div title="12.3.2. Mailing Lists">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="trouble.resources.lists"></a>12.3.2. 邮件列表</h3>
                                   </div>
                                 </div>
                               </div>
                               <p>Ask a question on the <a href="http://hbase.apache.org/mail-lists.html" target="_top">HBase mailing lists</a>. The 'dev' mailing list is aimed at the community of developers actually building HBase and for features currently under development, and 'user' is generally used for questions on released versions of HBase. Before going to the mailing list, make sure your question has not already been answered by searching the mailing list archives first. Use <a href="#trouble.resources.searchhadoop" title="12.3.1. search-hadoop.com">Section 12.3.1, “search-hadoop.com”</a>. Take some time crafting your question[<a name="d352e7542" href="#ftn.d352e7542">31</a>]; a quality question that includes all context and exhibits evidence the author has tried to find answers in the manual and out on lists is more likely to get a prompt response.</p>
                             </div>
                             <div title="12.3.3. IRC">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="trouble.resources.irc"></a>12.3.3. IRC</h3>
                                   </div>
                                 </div>
                               </div>
                               <p>#hbase on irc.freenode.net</p>
                             </div>
                             <div title="12.3.4. JIRA">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="trouble.resources.jira"></a>12.3.4. JIRA</h3>
                                   </div>
                                 </div>
                               </div>
                               <p><a href="https://issues.apache.org/jira/browse/HBASE" target="_top">JIRA</a> 在处理 Hadoop/HBase相关问题时也很有帮助。</p>
                             </div>
                             <div><br>
                               <div></div>
                             </div>
<h2 class="title" style="clear: both"><a name="trouble.tools"></a>12.4.&nbsp;工具</h2>
</div>
                         </div>
                       </div>
                       <div class="section" title="15.3.1. search-hadoop.com">
                         <div class="titlepage">
                           <div>
                             <div>
                               <div>
                                 <div>
                                   <div>
                                     <h3>12.4.1. 内置工具</h3>
                                   </div>
                                 </div>
                               </div>
                               <div title="12.4.1.1. Master Web Interface">
                                 <div>
                                   <div>
                                     <div>
                                       <h4><a name="trouble.tools.builtin.webmaster"></a>12.4.1.1. 主服务器Web接口</h4>
                                     </div>
                                   </div>
                                 </div>
                                 <p>主服务器启动了一个缺省端口是 60010的web接口。</p>
                                 <p>The Master web UI lists created tables and their definition (e.g., ColumnFamilies, blocksize, etc.). Additionally, the available RegionServers in the cluster are listed along with selected high-level metrics (requests, number of regions, usedHeap, maxHeap). The Master web UI allows navigation to each RegionServer's web UI.</p>
                               </div>
                               <div title="12.4.1.2. RegionServer Web Interface">
                                 <div>
                                   <div>
                                     <div>
                                       <h4><a name="trouble.tools.builtin.webregion"></a>12.4.1.2. 区域服务器Web接口</h4>
                                     </div>
                                   </div>
                                 </div>
                                 <p>区域服务器启动了一个缺省端口是 60030的web接口。</p>
                                 <p>The RegionServer web UI lists online regions and their start/end keys, as well as point-in-time RegionServer metrics (requests, regions, storeFileIndexSize, compactionQueueSize, etc.).</p>
                                 <p>参考 <a href="#hbase_metrics" title="14.4. HBase Metrics">Section 14.4, “HBase Metrics”</a> 获取更多度量信息。</p>
                               </div>
                               
                               <div class="section" title="12.4.1.3.&nbsp;zkcli"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.builtin.zkcli"></a>12.4.1.3.&nbsp;zkcli</h4></div></div></div>
                               <p><code class="code">zkcli</code>是一个研究 ZooKeeper相关问题的有用工具。调用：</p><pre class="programlisting">./hbase zkcli -server host:port &lt;cmd&gt; &lt;args&gt;
</pre>
                               <p>
              命令 (和参数) ：
</p><pre class="programlisting">	connect host:port
	get path [watch]
	ls path [watch]
	set path data [version]
	delquota [-n|-b] path
	quit 
	printwatches on|off
	create [-s] [-e] path data acl
	stat path [watch]
	close 
	ls2 path [watch]
	history 
	listquota path
	setAcl path acl
	getAcl path
	sync path
	redo cmdno
	addauth scheme auth
	delete path [version]
	setquota -n|-b val path
</pre><p>
            </p></div>
            
                               
                               <h3>12.4.2. 外部工具</h3>
                             </div>
                           </div>
                         </div>
                       </div>
                       <div class="section" title="15.3.2. tail">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.tools.tail"></a>12.4.2.1&nbsp;tail</h3>
                             </div>
                           </div>
                         </div>
                         <p> <code class="code">tail</code>是一个命令行工具，可以用来看日志的尾巴。加入的"-f"参数后，就会在数据更新的时候自己刷新。用它来看日志很方便。例如，一个机器需要花很多时间来启动或关闭，你可以tail他的master log(也可以是region server的log)。 </p>
                       </div>
                       <div class="section" title="15.3.3. top">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.tools.top"></a>12.4.2.2&nbsp;top</h3>
                             </div>
                           </div>
                         </div>
                         <p> <code class="code">top</code>是一个很重要的工具来看你的机器各个进程的资源占用情况。下面是一个生产环境的例子： </p>
                         <pre class="programlisting">top - 14:46:59 up 39 days, 11:55,  1 user,  load average: 3.75, 3.57, 3.84
Tasks: 309 total,   1 running, 308 sleeping,   0 stopped,   0 zombie
Cpu(s):  4.5%us,  1.6%sy,  0.0%ni, 91.7%id,  1.4%wa,  0.1%hi,  0.6%si,  0.0%st
Mem:  24414432k total, 24296956k used,   117476k free,     7196k buffers
Swap: 16008732k total,	14348k used, 15994384k free, 11106908k cached
 
  PID USER  	PR  NI  VIRT  RES  SHR S %CPU %MEM	TIME+  COMMAND                                                                                                                                                                      
15558 hadoop	18  -2 3292m 2.4g 3556 S   79 10.4   6523:52 java                                                                                                                                                                          
13268 hadoop	18  -2 8967m 8.2g 4104 S   21 35.1   5170:30 java                                                                                                                                                                          
 8895 hadoop	18  -2 1581m 497m 3420 S   11  2.1   4002:32 java
…
                     </pre>
                         这里你可以看到系统的load average在最近5分钟是3.75，意思就是说这5分钟里面平均有3.75个线程在CPU时间的等待队列里面。通常来说，最完美的情况是这个值和CPU和核数相等，比这个值低意味着资源闲置，比这个值高就是过载了。这是一个重要的概念，要想理解的更多，可以看这篇文章 <a class="link" href="http://www.linuxjournal.com/article/9001" target="_top">http://www.linuxjournal.com/article/9001</a>. 
                         <p> 处理负载，我们可以看到系统已经几乎使用了他的全部RAM，其中大部分都是用于OS cache(这是一件好事).Swap只使用了一点点KB,这正是我们期望的，如果数值很高的话，就意味着在进行交换，这对Java程序的性能是致命的。另一种检测交换的方法是看Load average是否过高(load average过高还可能是磁盘损坏或者其它什么原因导致的)。 </p>
                         <p> 默认情况下进程列表不是很有用，我们可以看到3个Java进程使用了111%的CPU。要想知道哪个进程是什么，可以输入"c"，每一行就会扩展信息。输入“1”可以显示CPU的每个核的具体状况。 </p>
                       </div>
                       <div class="section" title="15.3.4. jps">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.tools.jps"></a>12.4.2.3 &nbsp;jps</h3>
                             </div>
                           </div>
                         </div>
                         <p> <code class="code">jps</code>是JDK集成的一个工具，可以用来看当前用户的Java进程id。(如果是root,可以看到所有用户的id)，例如: </p>
                         <pre class="programlisting">hadoop@sv4borg12:~$ jps
1322 TaskTracker
17789 HRegionServer
27862 Child
1158 DataNode
25115 HQuorumPeer
2950 Jps
19750 ThriftServer
18776 jmx
                     </pre>
                         <p> 按顺序看 </p>
                         <div class="itemizedlist">
                           <ul class="itemizedlist" type="disc">
                             <li class="listitem">Hadoop TaskTracker,管理本地的Task</li>
                             <li class="listitem">HBase RegionServer,提供region的服务</li>
                             <li class="listitem">Child, 一个 MapReduce task,无法看出详细类型 </li>
                             <li class="listitem">Hadoop DataNode, 管理blocks</li>
                             <li class="listitem">HQuorumPeer, ZooKeeper集群的成员</li>
                             <li class="listitem">Jps, 就是这个进程</li>
                             <li class="listitem">ThriftServer, 当thrif启动后，就会有这个进程</li>
                             <li class="listitem">jmx, 这个是本地监控平台的进程。你可以不用这个。</li>
                           </ul>
                         </div>
                         <p></p>
                         <p> 你可以看到这个进程启动是全部命令行信息。 </p>
                         <pre class="programlisting">hadoop@sv4borg12:~$ ps aux | grep HRegionServer
hadoop   17789  155 35.2 9067824 8604364 ?     S&lt;l  Mar04 9855:48 /usr/java/jdk1.6.0_14/bin/java -Xmx8000m -XX:+DoEscapeAnalysis -XX:+AggressiveOpts -XX:+UseConcMarkSweepGC -XX:NewSize=64m -XX:MaxNewSize=64m -XX:CMSInitiatingOccupancyFraction=88 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/export1/hadoop/logs/gc-hbase.log -Dcom.sun.management.jmxremote.port=10102 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=/home/hadoop/hbase/conf/jmxremote.password -Dcom.sun.management.jmxremote -Dhbase.log.dir=/export1/hadoop/logs -Dhbase.log.file=hbase-hadoop-regionserver-sv4borg12.log -Dhbase.home.dir=/home/hadoop/hbase -Dhbase.id.str=hadoop -Dhbase.root.logger=INFO,DRFA -Djava.library.path=/home/hadoop/hbase/lib/native/Linux-amd64-64 -classpath /home/hadoop/hbase/bin/../conf:[many jars]:/home/hadoop/hadoop/conf org.apache.hadoop.hbase.regionserver.HRegionServer start
                     </pre>
                         <p> </p>
                       </div>
                       <div class="section" title="15.3.5. jstack">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.tools.jstack"></a>12.4.2.4 &nbsp;jstack</h3>
                             </div>
                           </div>
                         </div>
                         <p> <code class="code">jstack</code> 是一个最重要(除了看Log)的java工具，可以看到具体的Java进程的在做什么。可以先用Jps看到进程的Id,然后就可以用jstack。他会按线程的创建顺序显示线程的列表，还有这个线程在做什么。下面是例子： </p>
                         <p> 这个主线程是一个RegionServer正在等master返回什么信息。 </p>
                         <pre class="programlisting">      "regionserver60020" prio=10 tid=0x0000000040ab4000 nid=0x45cf waiting on condition [0x00007f16b6a96000..0x00007f16b6a96a70]
   java.lang.Thread.State: TIMED_WAITING (parking)
        	at sun.misc.Unsafe.park(Native Method)
        	- parking to wait for  &lt;0x00007f16cd5c2f30&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)
        	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1963)
        	at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:395)
        	at org.apache.hadoop.hbase.regionserver.HRegionServer.run(HRegionServer.java:647)
        	at java.lang.Thread.run(Thread.java:619)
 
        	The MemStore flusher thread that is currently flushing to a file:
"regionserver60020.cacheFlusher" daemon prio=10 tid=0x0000000040f4e000 nid=0x45eb in Object.wait() [0x00007f16b5b86000..0x00007f16b5b87af0]
   java.lang.Thread.State: WAITING (on object monitor)
        	at java.lang.Object.wait(Native Method)
        	at java.lang.Object.wait(Object.java:485)
        	at org.apache.hadoop.ipc.Client.call(Client.java:803)
        	- locked &lt;0x00007f16cb14b3a8&gt; (a org.apache.hadoop.ipc.Client$Call)
        	at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:221)
        	at $Proxy1.complete(Unknown Source)
        	at sun.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
        	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        	at java.lang.reflect.Method.invoke(Method.java:597)
        	at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:82)
        	at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:59)
        	at $Proxy1.complete(Unknown Source)
        	at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.closeInternal(DFSClient.java:3390)
        	- locked &lt;0x00007f16cb14b470&gt; (a org.apache.hadoop.hdfs.DFSClient$DFSOutputStream)
        	at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.close(DFSClient.java:3304)
        	at org.apache.hadoop.fs.FSDataOutputStream$PositionCache.close(FSDataOutputStream.java:61)
        	at org.apache.hadoop.fs.FSDataOutputStream.close(FSDataOutputStream.java:86)
        	at org.apache.hadoop.hbase.io.hfile.HFile$Writer.close(HFile.java:650)
        	at org.apache.hadoop.hbase.regionserver.StoreFile$Writer.close(StoreFile.java:853)
        	at org.apache.hadoop.hbase.regionserver.Store.internalFlushCache(Store.java:467)
        	- locked &lt;0x00007f16d00e6f08&gt; (a java.lang.Object)
        	at org.apache.hadoop.hbase.regionserver.Store.flushCache(Store.java:427)
        	at org.apache.hadoop.hbase.regionserver.Store.access$100(Store.java:80)
        	at org.apache.hadoop.hbase.regionserver.Store$StoreFlusherImpl.flushCache(Store.java:1359)
        	at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:907)
        	at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:834)
        	at org.apache.hadoop.hbase.regionserver.HRegion.flushcache(HRegion.java:786)
        	at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:250)
        	at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:224)
        	at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.run(MemStoreFlusher.java:146)
                     </pre>
                         <p></p>
                         <p> 一个处理线程是在等一些东西(例如put, delete, scan...): </p>
                         <pre class="programlisting">"IPC Server handler 16 on 60020" daemon prio=10 tid=0x00007f16b011d800 nid=0x4a5e waiting on condition [0x00007f16afefd000..0x00007f16afefd9f0]
   java.lang.Thread.State: WAITING (parking)
        	at sun.misc.Unsafe.park(Native Method)
        	- parking to wait for  &lt;0x00007f16cd3f8dd8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)
        	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1925)
        	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:358)
        	at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1013)
                     </pre>
                         <p></p>
                         <p> 有一个线程正在忙，在递增一个counter(这个阶段是正在创建一个scanner来读最新的值): </p>
                         <pre class="programlisting">"IPC Server handler 66 on 60020" daemon prio=10 tid=0x00007f16b006e800 nid=0x4a90 runnable [0x00007f16acb77000..0x00007f16acb77cf0]
   java.lang.Thread.State: RUNNABLE
        	at org.apache.hadoop.hbase.regionserver.KeyValueHeap.&lt;init&gt;(KeyValueHeap.java:56)
        	at org.apache.hadoop.hbase.regionserver.StoreScanner.&lt;init&gt;(StoreScanner.java:79)
        	at org.apache.hadoop.hbase.regionserver.Store.getScanner(Store.java:1202)
        	at org.apache.hadoop.hbase.regionserver.HRegion$RegionScanner.&lt;init&gt;(HRegion.java:2209)
        	at org.apache.hadoop.hbase.regionserver.HRegion.instantiateInternalScanner(HRegion.java:1063)
        	at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1055)
        	at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1039)
        	at org.apache.hadoop.hbase.regionserver.HRegion.getLastIncrement(HRegion.java:2875)
        	at org.apache.hadoop.hbase.regionserver.HRegion.incrementColumnValue(HRegion.java:2978)
        	at org.apache.hadoop.hbase.regionserver.HRegionServer.incrementColumnValue(HRegionServer.java:2433)
        	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
        	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        	at java.lang.reflect.Method.invoke(Method.java:597)
        	at org.apache.hadoop.hbase.ipc.HBaseRPC$Server.call(HBaseRPC.java:560)
        	at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1027)
                     </pre>
                         还有一个线程在从HDFS获取数据。 
                         <pre class="programlisting">        	
"IPC Client (47) connection to sv4borg9/10.4.24.40:9000 from hadoop" daemon prio=10 tid=0x00007f16a02d0000 nid=0x4fa3 runnable [0x00007f16b517d000..0x00007f16b517dbf0]
   java.lang.Thread.State: RUNNABLE
        	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
        	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:215)
        	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:65)
        	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:69)
        	- locked &lt;0x00007f17d5b68c00&gt; (a sun.nio.ch.Util$1)
        	- locked &lt;0x00007f17d5b68be8&gt; (a java.util.Collections$UnmodifiableSet)
        	- locked &lt;0x00007f1877959b50&gt; (a sun.nio.ch.EPollSelectorImpl)
        	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:80)
        	at org.apache.hadoop.net.SocketIOWithTimeout$SelectorPool.select(SocketIOWithTimeout.java:332)
        	at org.apache.hadoop.net.SocketIOWithTimeout.doIO(SocketIOWithTimeout.java:157)
        	at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:155)
        	at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:128)
        	at java.io.FilterInputStream.read(FilterInputStream.java:116)
        	at org.apache.hadoop.ipc.Client$Connection$PingInputStream.read(Client.java:304)
        	at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)
        	at java.io.BufferedInputStream.read(BufferedInputStream.java:237)
        	- locked &lt;0x00007f1808539178&gt; (a java.io.BufferedInputStream)
        	at java.io.DataInputStream.readInt(DataInputStream.java:370)
        	at org.apache.hadoop.ipc.Client$Connection.receiveResponse(Client.java:569)
        	at org.apache.hadoop.ipc.Client$Connection.run(Client.java:477)
                     </pre>
                         <p></p>
                         <p> 这里是一个RegionServer死了，master正在试着恢复。 </p>
                         <pre class="programlisting">"LeaseChecker" daemon prio=10 tid=0x00000000407ef800 nid=0x76cd waiting on condition [0x00007f6d0eae2000..0x00007f6d0eae2a70]
--
   java.lang.Thread.State: WAITING (on object monitor)
        	at java.lang.Object.wait(Native Method)
        	at java.lang.Object.wait(Object.java:485)
        	at org.apache.hadoop.ipc.Client.call(Client.java:726)
        	- locked &lt;0x00007f6d1cd28f80&gt; (a org.apache.hadoop.ipc.Client$Call)
        	at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:220)
        	at $Proxy1.recoverBlock(Unknown Source)
        	at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.processDatanodeError(DFSClient.java:2636)
        	at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.&lt;init&gt;(DFSClient.java:2832)
        	at org.apache.hadoop.hdfs.DFSClient.append(DFSClient.java:529)
        	at org.apache.hadoop.hdfs.DistributedFileSystem.append(DistributedFileSystem.java:186)
        	at org.apache.hadoop.fs.FileSystem.append(FileSystem.java:530)
        	at org.apache.hadoop.hbase.util.FSUtils.recoverFileLease(FSUtils.java:619)
        	at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1322)
        	at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1210)
        	at org.apache.hadoop.hbase.master.HMaster.splitLogAfterStartup(HMaster.java:648)
        	at org.apache.hadoop.hbase.master.HMaster.joinCluster(HMaster.java:572)
        	at org.apache.hadoop.hbase.master.HMaster.run(HMaster.java:503)
                     </pre>
                         <p></p>
                       </div>
                       <div class="section" title="15.3.6. OpenTSDB">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.tools.opentsdb"></a>12.4.2.5 &nbsp;OpenTSDB</h3>
                             </div>
                           </div>
                         </div>
                         <p> <a class="link" href="http://opentsdb.net/" target="_top">OpenTSDB</a>是一个Ganglia的很好的替代品，因为他使用HBase来存储所有的时序而不需要采样。使用OpenTSDB来监控你的HBase是一个很好的实践 </p>
                         <p> 这里有一个例子，集群正在同时进行上百个紧缩，严重影响了IO性能。(TODO:  在这里插入compactionQueueSize的图片) </p>
                         <p> 给集群构建一个图表监控是一个很好的实践。包括集群和每台机器。这样就可以快速定位到问题。例如，在StumbleUpon，每个机器有一个图表监控，包括OS和HBase，涵盖所有的重要的信息。你也可以登录到机器上，获取更多的信息。 </p>
                       </div>
                       <div class="section" title="15.3.7. clusterssh+top">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.tools.clustersshtop"></a>12.4.2.6 &nbsp;clusterssh+top</h3>
                             </div>
                           </div>
                         </div>
                         <p> clusterssh+top,感觉是一个穷人用的监控系统，但是他确实很有效，当你只有几台机器的是，很好设置。启动clusterssh后，你就会每台机器有个终端，还有一个终端，你在这个终端的操作都会反应到其他的每一个终端上。 这就意味着，你在一天机器执行“top”,集群中的所有机器都会给你全部的top信息。你还可以这样tail全部的log，等等。 </p>
                       </div>
                     </div>
                     
                     <div class="section" title="12.5.&nbsp;Client"><div class="titlepage"><div><div>
                       <h2 class="title" style="clear: both"><a name="trouble.client"></a>12.5.&nbsp;客户端</h2>
                             <p style="clear: both">&nbsp;</p>
                     </div></div></div>
                     <p> HBase 客户端的更多信息， 参考 <a class="xref" href="#client" title="9.3.&nbsp;Client">Section&nbsp;9.3, “Client”</a>. 
       </p><div class="section" title="12.5.1.&nbsp;ScannerTimeoutException or UnknownScannerException"><div class="titlepage"><div><div>
         <h3 class="title"><a name="trouble.client.scantimeout"></a>12.5.1.&nbsp;ScannerTimeoutException 或 UnknownScannerException</h3></div></div></div><p>当从客户端到RegionServer的RPC请求超时。例如如果Scan.setCacheing的值设置为500，RPC请求就要去获取500行的数据，每500次<code class="code">.next()</code>操作获取一次。因为数据是以大块的形式传到客户端的，就可能造成超时。将这个 serCacheing的值调小是一个解决办法，但是这个值要是设的太小就会影响性能。 </p>
       <p>参考 <a class="xref" href="#perf.hbase.client.caching" title="11.8.1.&nbsp;Scan Caching">Section&nbsp;11.10.1, “Scan Caching”</a>.
            </p></div><div class="section" title="12.5.2.&nbsp;Shell or client application throws lots of scary exceptions during normal operation"><div class="titlepage"><div><div>
              <h3 class="title"><a name="trouble.client.scarylogs"></a>12.5.2.&nbsp;普通操作时，Shell 或客户端应用抛出很多不太重要的异常 </h3></div></div></div><p>Since 0.20.0 the default log level for <code class="code">org.apache.hadoop.hbase.*</code>is DEBUG. </p><p>
            On your clients, edit <code class="filename">$HBASE_HOME/conf/log4j.properties</code> and change this: <code class="code">log4j.logger.org.apache.hadoop.hbase=DEBUG</code> to this: <code class="code">log4j.logger.org.apache.hadoop.hbase=INFO</code>, or even <code class="code">log4j.logger.org.apache.hadoop.hbase=WARN</code>. 
            </p></div><div class="section" title="12.5.3.&nbsp;Long Client Pauses With Compression"><div class="titlepage"><div><div>
              <h3 class="title"><a name="trouble.client.longpauseswithcompression"></a>12.5.3.&nbsp;压缩时客户端长时暂停</h3></div></div></div>
            <p>这是一个在HBase区列表中经常被问的问题。场景一般是客户端正在插入大量数据到相对未优化的HBase集群中时发生。压缩正好加重暂停，尽管这不是问题源头。</p>
            <p>参考 <a class="xref" href="#precreate.regions" title="11.7.2.&nbsp; Table Creation: Pre-Creating Regions">Section&nbsp;11.10.2, “
    Table Creation: Pre-Creating Regions
    ”</a> ，关于预先创建区域的模式部分，并确认表没有在单个区域中启动。</p>
            <p>参考 <a class="xref" href="#perf.configurations" title="11.4.&nbsp;HBase Configurations">Section&nbsp;11.4, “HBase Configurations”</a> 获取集群配置相关信息, 特别是 <code class="code">hbase.hstore.blockingStoreFiles</code>, <code class="code">hbase.hregion.memstore.block.multiplier</code>, 
            <code class="code">MAX_FILESIZE</code> (region size), 和 <code class="code">MEMSTORE_FLUSHSIZE.</code>  </p><p>A slightly longer explanation of why pauses can happen is as follows:  Puts are sometimes blocked on the MemStores which are blocked by the flusher thread which is blocked because there are 
            too many files to compact because the compactor is given too many small files to compact and has to compact the same data repeatedly.  This situation can occur even with minor compactions.
            Compounding this situation, HBase doesn't compress data in memory.  Thus, the 64MB that lives in the MemStore could become a 6MB file after compression - which results in a smaller StoreFile.  The upside is that
            more data is packed into the same region, but performance is achieved by being able to write larger files - which is why HBase waits until the flushize before writing a new StoreFile.  And smaller StoreFiles
            become targets for compaction.  Without compression the files are much bigger and don't need as much compaction, however this is at the expense of I/O.   
            </p><p>
            For additional information, see this thread on <a class="link" href="http://search-hadoop.com/m/WUnLM6ojHm1/Long+client+pauses+with+compression&amp;subj=Long+client+pauses+with+compression" target="_top">Long client pauses with compression</a>.
            </p></div><div class="section" title="12.5.4.&nbsp;ZooKeeper Client Connection Errors"><div class="titlepage"><div><div>
              <h3 class="title"><a name="trouble.client.zookeeper"></a>12.5.4.&nbsp;ZooKeeper 客户端连接错误</h3></div></div></div>
            <p>错误类似于...
</p><pre class="programlisting">11/07/05 11:26:41 WARN zookeeper.ClientCnxn: Session 0x0 for server null,
 unexpected error, closing socket connection and attempting reconnect
 java.net.ConnectException: Connection refused: no further information
        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)
        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)
 11/07/05 11:26:43 INFO zookeeper.ClientCnxn: Opening socket connection to
 server localhost/127.0.0.1:2181
 11/07/05 11:26:44 WARN zookeeper.ClientCnxn: Session 0x0 for server null,
 unexpected error, closing socket connection and attempting reconnect
 java.net.ConnectException: Connection refused: no further information
        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)
        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)
 11/07/05 11:26:45 INFO zookeeper.ClientCnxn: Opening socket connection to
 server localhost/127.0.0.1:2181
</pre>
<p>
            ... 要么是 ZooKeeper 不在了，或网络不可达问题。</p>
<p>工具 <a class="xref" href="trouble.tools.builtin.zkcli" title="12.4.1.3.&nbsp;zkcli">Section&nbsp;12.4.1.3, “zkcli”</a> 可以帮助调查 ZooKeeper 问题。
            </p></div><div class="section" title="12.5.5.&nbsp;Client running out of memory though heap size seems to be stable (but the off-heap/direct heap keeps growing)"><div class="titlepage"><div><div>
              <h3 class="title"><a name="trouble.client.oome.directmemory.leak"></a>12.5.5.&nbsp;客户端内存耗尽，但堆大小看起来不太变化( off-heap/direct heap 在增长)</h3></div></div></div><p>
You are likely running into the issue that is described and worked through in
the mail thread HBase, mail # user - Suspected memory leak
and continued over in HBase, mail # dev - FeedbackRe: Suspected memory leak.
A workaround is passing your client-side JVM a reasonable value for <code class="code">-XX:MaxDirectMemorySize</code>.  By default,
the <code class="varname">MaxDirectMemorySize</code> is equal to your <code class="code">-Xmx</code> max heapsize setting (if <code class="code">-Xmx</code> is set).
Try seting it to something smaller (for example, one user had success setting it to <code class="code">1g</code> when
they had a client-side heap of <code class="code">12g</code>).  If you set it too small, it will bring on <code class="code">FullGCs</code> so keep
it  a bit hefty.  You want to make this setting client-side only especially if you are running the new experiemental
server-side off-heap cache since this feature depends on being able to use big direct buffers (You may have to keep
separate client-side and server-side config dirs).
            </p></div><div class="section" title="12.5.6.&nbsp;Client Slowdown When Calling Admin Methods (flush, compact, etc.)"><div class="titlepage"><div><div>
              <h3 class="title"><a name="trouble.client.slowdown.admin"></a>12.5.6.&nbsp;客户端变慢，在调用管理方法(flush, compact, 等)时发生</h3></div></div></div>
            <p>
该客户端问题在 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-5073" target="_top">HBASE-5073</a> 版本 0.90.6中修订。 客户端的ZooKeeper 内存泄露，而客户端被管理API的额外调用产生的ZooKeeper事件连续调用。 
            </p></div><div class="section" title="12.5.7.&nbsp;Secure Client Cannot Connect ([Caused by GSSException: No valid credentials provided (Mechanism level: Failed to find any Kerberos tgt)])"><div class="titlepage"><div><div>
              <h3 class="title"><a name="trouble.client.security.rpc"></a>12.5.7.&nbsp;安全客户端不能连接 ([由 GSSException 引起: No valid credentials provided (Mechanism level: Failed to find any Kerberos tgt)])</h3></div></div></div><p>There can be several causes that produce this symptom.</p>
              <p>First, check that you have a valid Kerberos ticket. One is required in order to set up communication with a secure Apache HBase cluster. Examine the ticket currently in the credential cache, if any, by running the klist command line utility. If no ticket is listed, you must obtain a ticket by running the kinit command with either a keytab specified, or by interactively entering a password for the desired principal.</p>
              <p>Then, consult the <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jgss/tutorials/Troubleshooting.html" target="_top">Java Security Guide troubleshooting section</a>. The most common problem addressed there is resolved by setting javax.security.auth.useSubjectCredsOnly system property value to false.</p>
              <p>Because of a change in the format in which MIT Kerberos writes its credentials cache, there is a bug in the Oracle JDK 6 Update 26 and earlier that causes Java to be unable to read the Kerberos credentials cache created by versions of MIT Kerberos 1.8.1 or higher. If you have this problematic combination of components in your environment, to work around this problem, first log in with kinit and then immediately refresh the credential cache with kinit -R. The refresh will rewrite the credential cache without the problematic formatting.</p>
              <p>Finally, depending on your Kerberos configuration, you may need to install the <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html" target="_top">Java Cryptography Extension</a>, or JCE. Insure the JCE jars are on the classpath on both server and client systems.</p>
              <p>You may also need to download the <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_top">unlimited strength JCE policy files</a>. Uncompress and extract the downloaded file, and install the policy jars into &lt;java-home&gt;/lib/security.</p>
            </div></div>
                     <div class="section" title="12.6.&nbsp;MapReduce"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.mapreduce"></a>12.6.&nbsp;MapReduce</h2></div></div></div><div class="section" title="12.6.1.&nbsp;You Think You're On The Cluster, But You're Actually Local"><div class="titlepage"><div><div>
                       <h3 class="title"><a name="trouble.mapreduce.local"></a>12.6.1.&nbsp;你认为自己在用集群, 实际上你在用本地(Local)</h3></div></div></div>
                     <p>如下的调用栈在使用 <code class="code">ImportTsv</code>时发生，但同样的事可以在错误配置的任何任务中发生。 </p><pre class="programlisting">    WARN mapred.LocalJobRunner: job_local_0001
java.lang.IllegalArgumentException: Can't read partitions file
       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.setConf(TotalOrderPartitioner.java:111)
       at org.apache.hadoop.util.ReflectionUtils.setConf(ReflectionUtils.java:62)
       at org.apache.hadoop.util.ReflectionUtils.newInstance(ReflectionUtils.java:117)
       at org.apache.hadoop.mapred.MapTask$NewOutputCollector.&lt;init&gt;(MapTask.java:560)
       at org.apache.hadoop.mapred.MapTask.runNewMapper(MapTask.java:639)
       at org.apache.hadoop.mapred.MapTask.run(MapTask.java:323)
       at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)
Caused by: java.io.FileNotFoundException: File _partition.lst does not exist.
       at org.apache.hadoop.fs.RawLocalFileSystem.getFileStatus(RawLocalFileSystem.java:383)
       at org.apache.hadoop.fs.FilterFileSystem.getFileStatus(FilterFileSystem.java:251)
       at org.apache.hadoop.fs.FileSystem.getLength(FileSystem.java:776)
       at org.apache.hadoop.io.SequenceFile$Reader.&lt;init&gt;(SequenceFile.java:1424)
       at org.apache.hadoop.io.SequenceFile$Reader.&lt;init&gt;(SequenceFile.java:1419)
       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.readPartitions(TotalOrderPartitioner.java:296)
</pre>
                     <p>
      .. 看到调用栈的关键部分了吗？就是...
</p><pre class="programlisting">       at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)
</pre>
<p>
       LocalJobRunner 意思就是任务跑在本地，不在集群。
      </p><p>参考 
      <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/package-summary.html#classpath" target="_top">
      http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/package-summary.html#classpath</a> for more 
      information on HBase MapReduce jobs and classpaths.
      </p></div></div>
      <div class="section" title="12.7.&nbsp;NameNode"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.namenode"></a>12.7.&nbsp;NameNode</h2></div></div></div>
      <p> NameNode 更多信息, 参考 <a class="xref" href="#arch.hdfs" title="9.9.&nbsp;HDFS">Section&nbsp;9.9, “HDFS”</a>. 
       </p><div class="section" title="12.7.1.&nbsp;HDFS Utilization of Tables and Regions"><div class="titlepage"><div><div>
         <h3 class="title"><a name="trouble.namenode.disk"></a>12.7.1.&nbsp;表和区域的HDFS 工具</h3></div></div></div>
       <p> 要确定HBase 用了HDFS多大空间，可在NameNode使用 <code class="code">hadoop</code> shell命令，例如... </p><pre class="programlisting">hadoop fs -dus /hbase/</pre>
       <p> ...返回全部HBase对象磁盘占用的情况。</p><pre class="programlisting">hadoop fs -dus /hbase/myTable</pre>
       <p> ...返回HBase表'myTable'磁盘占用的情况。 </p><pre class="programlisting">hadoop fs -du /hbase/myTable</pre>
       <p> ...返回HBase的'myTable'表的各区域列表的磁盘占用情况。 </p>
       <p>更多关于 HDFS shell 命令的信息，参考 <a class="link" href="http://hadoop.apache.org/common/docs/current/file_system_shell.html" target="_top">HDFS 文件系统 Shell 文档</a>.
            </p></div><div class="section" title="12.7.2.&nbsp;Browsing HDFS for HBase Objects"><div class="titlepage"><div><div>
              <h3 class="title"><a name="trouble.namenode.hbase.objects"></a>12.7.2.&nbsp;浏览 HDFS ，查看 HBase 对象</h3></div></div></div>
            <p>有时需要浏览HDFS上的 HBase对象 。对象包括WALs (Write Ahead Logs), 表，区域，存储文件等。最简易的方法是在NameNode web应用中查看，端口 50070。NameNode web 应用提供到集群中所有 DataNode 的链接，可以无缝浏览。</p>
            <p> 存储在HDFS集群中的HBase表的目录结构是...
            </p><pre class="programlisting"><code class="filename">/hbase</code>
     <code class="filename">/&lt;Table&gt;</code>             (Tables in the cluster)
          <code class="filename">/&lt;Region&gt;</code>           (Regions for the table)
               <code class="filename">/&lt;ColumnFamiy&gt;</code>      (ColumnFamilies for the Region for the table)
                    <code class="filename">/&lt;StoreFile&gt;</code>        (StoreFiles for the ColumnFamily for the Regions for the table)
            </pre><p>
            </p>
            <p> HDFS 中的HBase WAL目录结构是..
            </p><pre class="programlisting"><code class="filename">/hbase</code>
     <code class="filename">/.logs</code>     
          <code class="filename">/&lt;RegionServer&gt;</code>    (RegionServers)
               <code class="filename">/&lt;HLog&gt;</code>           (WAL HLog files for the RegionServer)
            </pre><p>
            </p>
            <p>参考<a class="link" href="see http://hadoop.apache.org/common/docs/current/hdfs_user_guide.html" target="_top">HDFS User Guide</a> 获取其他非Shell诊断工具如<code class="code">fsck</code>. 
            </p><div class="section" title="12.7.2.1.&nbsp;Use Cases"><div class="titlepage"><div><div>
              <h4 class="title"><a name="trouble.namenode.uncompaction"></a>12.7.2.1.&nbsp;用例</h4></div></div></div>
            <p>查询HDFS，获取HBase对象的两个通常用例是研究未紧缩表的程度。如果每个列族有大量存储文件(StoreFile)，这表示需要主紧缩。另外，在主紧缩之后，如果存储文件的比较小，意味着表的列族要减少。</p></div></div></div>
                     <div class="section" title="15.4. 客户端">
                       <div class="titlepage">
                         <div>
                           <div>
                             <div>
                               <div>
                                 <div>
                                   <h2><a name="trouble.network" id="trouble.network"></a>12.8. 网络</h2>
                                 </div>
                               </div>
                             </div>
                             <div title="12.8.1. Network Spikes">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="trouble.network.spikes"></a>12.8.1. 网络峰值(Network Spikes)</h3>
                                   </div>
                                 </div>
                               </div>
                               <p>如果看到周期性网络峰值，你可能需要检查compactionQueues，是不是主紧缩正在进行。</p>
                               <p>参考 <a href="#managed.compactions" title="2.8.2.8. Managed Compactions">Section 2.8.2.8, “Managed Compactions”</a> ，获取更多管理紧缩的信息。</p>
                             </div>
                             <div title="12.8.2. Loopback IP">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="trouble.network.loopback"></a>12.8.2. 回环IP(Loopback IP)</h3>
                                   </div>
                                 </div>
                               </div>
                               <p>HBase 希望回环 IP 地址是 127.0.0.1. 参考开始章节 <a href="#loopback.ip" title="2.2.3. Loopback IP">Section 2.2.3, “Loopback IP”</a>.</p>
                             </div>
                             <div title="12.8.3. Network Interfaces">
                               <div>
                                 <div>
                                   <div>
                                     <h3><a name="trouble.network.ints"></a>12.8.3. 网络接口</h3>
                                   </div>
                                 </div>
                               </div>
                               <p>所有网络接口是否正常？你确定吗？参考故障诊断用例研究 <a href="#trouble.casestudy" title="12.14. Case Studies">Section 12.14, “Case Studies”</a>.</p>
                             </div>
                           </div>
                         </div>
                       </div>
</div>
                     <div class="section" title="15.5. RegionServer">
                       <div class="titlepage">
                         <div>
                           <div>
                             <h2 class="title" style="clear: both"><a name="trouble.rs"></a>12.9.&nbsp;区域服务器</h2>
                             <p style="clear: both"> RegionServer 的更多信息，参考 <a href="#regionserver.arch" title="9.6. RegionServer">Section 9.6, “RegionServer”</a>. </p>
                           </div>
                         </div>
                       </div>
                       <div class="section" title="15.5.1. 启动错误">
                         <div class="titlepage">
                           <div>
                             <div></div>
                           </div>
                         </div>
                         <div class="section" title="12.9.&nbsp;RegionServer"><div class="titlepage"></div><div class="section" title="12.9.1.&nbsp;Startup Errors"><div class="titlepage"><div>
                           <div><h3 class="title"><a name="trouble.rs.startup"></a>12.9.1.&nbsp;启动错误</h3>
                           </div></div></div><div class="section" title="12.9.1.1.&nbsp;Master Starts, But RegionServers Do Not"><div class="titlepage"><div><div>
                             <h4 class="title"><a name="trouble.rs.startup.master-no-region"></a>12.9.1.1.&nbsp;主服务器启动了，但区域服务器没有启动</h4></div></div></div>
                           <p>主服务器相信区域服务器有IP地址127.0.0.1 - 这是 localhost 并被解析到主服务器自己的localhost.
            </p>
                           <p>区域服务器错误的通知主服务器他们的IP地址是127.0.0.1. 
            </p>
                           <p>修改区域服务器的 <code class="filename">/etc/hosts</code> 从...  
            </p><pre class="programlisting"># Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               fully.qualified.regionservername regionservername  localhost.localdomain localhost
::1             localhost6.localdomain6 localhost6
            </pre>
            <p>
            ... 改到 (将主名称从localhost中移掉)...
            </p><pre class="programlisting"># Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
::1             localhost6.localdomain6 localhost6
            </pre><p>
            </p></div><div class="section" title="12.9.1.2.&nbsp;Compression Link Errors"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.startup.compression"></a>12.9.1.2.&nbsp;Compression Link Errors</h4></div></div></div><p>因为LZO压缩算法需要在集群中的每台机器都要安装，这是一个启动失败的常见错误。如果你获得了如下信息 </p>
              <pre class="programlisting">11/02/20 01:32:15 ERROR lzo.GPLNativeCodeLoader: Could not load native gpl library
java.lang.UnsatisfiedLinkError: no gplcompression in java.library.path
        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1734)
        at java.lang.Runtime.loadLibrary0(Runtime.java:823)
        at java.lang.System.loadLibrary(System.java:1028)
                     </pre>
              <p> 就意味着你的压缩库出现了问题。参见配置章节的 <a class="link" href="#lzo" title="3.6.4. LZO 压缩">LZO compression configuration</a>. </p></div></div><div class="section" title="12.9.2.&nbsp;Runtime Errors"><div class="titlepage"><div>
                <div><h3 class="title"><a name="trouble.rs.runtime"></a>12.9.2.&nbsp;运行时错误</h3>
                </div></div></div><div class="section" title="12.9.2.1.&nbsp;RegionServer Hanging"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.hang"></a>12.9.2.1.&nbsp;RegionServer Hanging</h4></div></div></div><p>
            Are you running an old JVM (&lt; 1.6.0_u21?)?  When you look at a thread dump,
            does it look like threads are BLOCKED but no one holds the lock all are
            blocked on?  参考 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3622" target="_top">HBASE 3622 Deadlock in HBaseServer (JVM bug?)</a>.
            Adding <code class="code">-XX:+UseMembar</code> to the HBase <code class="varname">HBASE_OPTS</code> in <code class="filename">conf/hbase-env.sh</code>
            may fix it.
            </p><p>Also, are you using <a class="xref" href="#client.rowlocks" title="9.3.4.&nbsp;RowLocks">Section&nbsp;9.3.4, “RowLocks”</a>?  These are discouraged because they can lock up the 
            RegionServers if not managed properly.
            </p></div><div class="section" title="12.9.2.2.&nbsp;java.io.IOException...(Too many open files)"><div class="titlepage"><div><div>
              <h4 class="title"><a name="trouble.rs.runtime.filehandles"></a>12.9.2.2.&nbsp;java.io.IOException...打开太多文件(Too many open files)</h4></div></div></div>
            <p>
           如果看到如下消息...
</p><pre class="programlisting">2010-09-13 01:24:17,336 WARN org.apache.hadoop.hdfs.server.datanode.DataNode: 
Disk-related IOException in BlockReceiver constructor. Cause is java.io.IOException: Too many open files
        at java.io.UnixFileSystem.createFileExclusively(Native Method)
        at java.io.File.createNewFile(File.java:883)
</pre><p>
           ... 参见快速入门的章节 <a class="link" href="#ulimit" title="2.2.5.&nbsp; ulimit and nproc">ulimit and nproc configuration</a>.
           </p></div><div class="section" title="12.9.2.3.&nbsp;xceiverCount 258 exceeds the limit of concurrent xcievers 256"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.xceivers"></a>12.9.2.3.&nbsp;xceiverCount 258 exceeds the limit of concurrent xcievers 256</h4></div></div></div><p>这个时常会出现在DataNode的日志中。 </p>
             <p> 参见快速入门章节的 <a class="link" href="#dfs.datanode.max.xcievers" title="1.3.1.7. dfs.datanode.max.xcievers">xceivers configuration</a>. </p>
             <p>&nbsp;</p>
           </div><div class="section" title="12.9.2.4.&nbsp;System instability, and the presence of &quot;java.lang.OutOfMemoryError: unable to create new native thread in exceptions&quot; HDFS DataNode logs or that of any system daemon"><div class="titlepage"><div><div>
             <h4 class="title"><a name="trouble.rs.runtime.oom-nt"></a>12.9.2.4. 系统不稳定,DataNode或者其他系统进程有 "java.lang.OutOfMemoryError: unable to create new native thread in exceptions"的错误</h4>
           </div></div></div>
           <p>参见快速入门章节的 <a class="link" href="#ulimit" title="1.3.1.6.  ulimit 和 nproc">ulimit and nproc configuration</a>..  最新的Linux发行版缺省值是 1024 - 这对HBase实在太小了。
           </p></div><div class="section" title="12.9.2.5.&nbsp;DFS instability and/or RegionServer lease timeouts"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.gc"></a>12.9.2.5.&nbsp;DFS不稳定或者RegionServer租期超时</h4>
           </div></div></div>
           <p>如果你收到了如下的消息:</p>
           <pre class="programlisting">2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 10000
2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 15000
2009-02-24 10:01:36,472 WARN org.apache.hadoop.hbase.regionserver.HRegionServer: unable to report to master for xxx milliseconds - retrying      
           </pre><p>
           ... 或者看到了全GC压缩操作，你可能正在执行一个全GC。</p></div><div class="section" title="12.9.2.6.&nbsp;&quot;No live nodes contain current block&quot; and/or YouAreDeadException"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.nolivenodes"></a>12.9.2.6.&nbsp;"No live nodes contain current block" and/or YouAreDeadException</h4></div></div></div><p>这个错误有可能是OS的文件句柄溢出，也可能是网络故障导致节点无法访问。 </p>
             <p> 参见快速入门章节 <a class="link" href="#ulimit" title="1.3.1.6.  ulimit 和 nproc">ulimit and nproc configuration</a>，检查你的网络。</p>
           </div><div class="section" title="12.9.2.7.&nbsp;ZooKeeper SessionExpired events"><div class="titlepage"><div><div>
             <h4 class="title"><a name="trouble.rs.runtime.zkexpired"></a>12.9.2.7.&nbsp;ZooKeeper 会话超时事件</h4></div></div></div><p>Master or RegionServers shutting down with messages like those in the logs: </p><pre class="programlisting">WARN org.apache.zookeeper.ClientCnxn: Exception
closing session 0x278bd16a96000f to sun.nio.ch.SelectionKeyImpl@355811ec
java.io.IOException: TIMED OUT
       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:906)
WARN org.apache.hadoop.hbase.util.Sleeper: We slept 79410ms, ten times longer than scheduled: 5000
INFO org.apache.zookeeper.ClientCnxn: Attempting connection to server hostname/IP:PORT
INFO org.apache.zookeeper.ClientCnxn: Priming connection to java.nio.channels.SocketChannel[connected local=/IP:PORT remote=hostname/IP:PORT]
INFO org.apache.zookeeper.ClientCnxn: Server connection successful
WARN org.apache.zookeeper.ClientCnxn: Exception closing session 0x278bd16a96000d to sun.nio.ch.SelectionKeyImpl@3544d65e
java.io.IOException: Session Expired
       at org.apache.zookeeper.ClientCnxn$SendThread.readConnectResult(ClientCnxn.java:589)
       at org.apache.zookeeper.ClientCnxn$SendThread.doIO(ClientCnxn.java:709)
       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:945)
ERROR org.apache.hadoop.hbase.regionserver.HRegionServer: ZooKeeper session expired           
           </pre><p>
           The JVM is doing a long running garbage collecting which is pausing every threads (aka "stop the world").
           Since the RegionServer's local ZooKeeper client cannot send heartbeats, the session times out.
           By design, we shut down any node that isn't able to contact the ZooKeeper ensemble after getting a timeout so that it stops serving data that may already be assigned elsewhere.  
           </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Make sure you give plenty of RAM (in <code class="filename">hbase-env.sh</code>), the default of 1GB won't be able to sustain long running imports.</li><li class="listitem">Make sure you don't swap, the JVM never behaves well under swapping.</li><li class="listitem">Make sure you are not CPU starving the RegionServer thread. For example, if you are running a MapReduce job using 6 CPU-intensive tasks on a machine with 4 cores, you are probably starving the RegionServer enough to create longer garbage collection pauses.</li><li class="listitem">Increase the ZooKeeper session timeout</li></ul></div><p>
           If you wish to increase the session timeout, add the following to your <code class="filename">hbase-site.xml</code> to increase the timeout from the default of 60 seconds to 120 seconds. 
           </p><pre class="programlisting">&lt;property&gt;
    &lt;name&gt;zookeeper.session.timeout&lt;/name&gt;
    &lt;value&gt;1200000&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.tickTime&lt;/name&gt;
    &lt;value&gt;6000&lt;/value&gt;
&lt;/property&gt;
            </pre><p>
           </p><p>
           Be aware that setting a higher timeout means that the regions served by a failed RegionServer will take at least
           that amount of time to be transfered to another RegionServer. For a production system serving live requests, we would instead 
           recommend setting it lower than 1 minute and over-provision your cluster in order the lower the memory load on each machines (hence having 
           less garbage to collect per machine).
           </p><p>
           If this is happening during an upload which only happens once (like initially loading all your data into HBase), consider bulk loading.
           </p>
           参考 <a class="xref" href="#trouble.zookeeper.general" title="12.11.2.&nbsp;ZooKeeper, The Cluster Canary">Section&nbsp;12.11.2, “ZooKeeper, The Cluster Canary”</a> for other general information about ZooKeeper troubleshooting.
        </div><div class="section" title="12.9.2.8.&nbsp;NotServingRegionException"><div class="titlepage"><div><div>
          <h4 class="title"><a name="trouble.rs.runtime.notservingregion"></a>12.9.2.8.&nbsp;无服务区域异常(NotServingRegionException)</h4></div></div></div><p>This exception is "normal" when found in the RegionServer logs at DEBUG level.  This exception is returned back to the client
           and then the client goes back to .META. to find the new location of the moved region.</p><p>However, if the NotServingRegionException is logged ERROR, then the client ran out of retries and something probably wrong.</p></div><div class="section" title="12.9.2.9.&nbsp;Regions listed by domain name, then IP"><div class="titlepage"><div><div>
             <h4 class="title"><a name="trouble.rs.runtime.double_listed_regions"></a>12.9.2.9.&nbsp;区域列示先是域名，然后IP</h4></div></div></div>
           <p>
           修复 DNS.   HBase 0.92.x以前的版本，反向 DNS 需要和正向查询相同答案。 参考 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3431" target="_top">HBASE 3431
           RegionServer is not using the name given it by the master; double entry in master listing of servers</a> 获取详细细节。</p></div><div class="section" title="12.9.2.10.&nbsp;Logs flooded with '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Got brand-new compressor' messages"><div class="titlepage"><div><div>
             <h4 class="title"><a name="trouble.rs.runtime.codecmsgs"></a>12.9.2.10.&nbsp;大量类似 '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Got
            brand-new compressor' 日志消息</h4></div></div></div>
           <p>没有采用本地压缩库版本。  参考 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1900" target="_top">HBASE-1900 Put back native support when hadoop 0.21 is released</a>。从hadoop的HBase库目录复制本地库或建立链接到正确位置，该消息将消失。
                </p></div><div class="section" title="12.9.2.11.&nbsp;Server handler X on 60020 caught: java.nio.channels.ClosedChannelException"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.client_went_away"></a>12.9.2.11.&nbsp;Server handler X on 60020 caught: java.nio.channels.ClosedChannelException</h4></div></div></div><p>
           If you see this type of message it means that the region server was trying to read/send data from/to a client but
           it already went away. Typical causes for this are if the client was killed (you see a storm of messages like this when a MapReduce
           job is killed or fails) or if the client receives a SocketTimeoutException. It's harmless, but you should consider digging in
           a bit more if you aren't doing something to trigger them.
           </p></div></div><div class="section" title="12.9.3.&nbsp;Shutdown Errors"><div class="titlepage"><div><div></div></div></div></div></div>
                       </div>
                     </div>
                   </div>
                 </div>
               </div>
               <div class="section" title="15.5.2. 运行时错误"> </div>
                       <div class="section" title="15.5.3. 终止错误">
                         <div class="titlepage">
                           <div>
                             <div>
                               <h3 class="title"><a name="trouble.rs.shutdown"></a>12.9.3.&nbsp;终止错误</h3>
                             </div>
                           </div>
                         </div>
                       </div>
                     </div>
                     <div class="section" title="15.6. Master">
                       <div class="titlepage">
                         <div>
                           <div>
                             <h2 class="title" style="clear: both"><a name="trouble.master"></a>12.10.&nbsp;Master</h2>
                           </div>
                         </div>
                       </div>
                       <div class="section" title="15.6.1. 启动错误">
                         <div class="titlepage">
                           <div>
                             <div>
                               <div>
                                 <div>
                                   <div></div>
                                 </div>
                               </div>
                               <p>Master 更多信息, 参考 <a href="#master" title="9.5. Master">Section 9.5, “Master”</a>.</p>
                               <div title="12.10.1. Startup Errors">
                                 <div>
                                   <div>
                                     <div>
                                       <h3><a name="trouble.master.startup"></a>12.10.1. <span class="title">启动错误</span></h3>
                                     </div>
                                   </div>
                                 </div>
                                 <div title="12.10.1.1. Master says that you need to run the hbase migrations script">
                                   <div>
                                     <div>
                                       <div>
                                         <h4><a name="trouble.master.startup.migration"></a>12.10.1.1. Master says that you need to run the hbase migrations script</h4>
                                       </div>
                                     </div>
                                   </div>
                                   <p>Upon running that, the hbase migrations script says no files in root directory.</p>
                                   <p>HBase expects the root directory to either not exist, or to have already been initialized by hbase running a previous time. If you create a new directory for HBase using Hadoop DFS, this error will occur. Make sure the HBase root directory does not currently exist or has been initialized by a previous run of HBase. Sure fire solution is to just use Hadoop dfs to delete the HBase root and let HBase create and initialize the directory itself.</p>
                                 </div>
                               </div>
                               <div title="12.10.2. Shutdown Errors">
                                 <div>
                                   <div>
                                     <div>
                                       <h3><a name="trouble.master.shutdown"></a>12.10.2. <span class="title">终止错误</span></h3>
                                     </div>
                                   </div>
                                 </div>
                               </div>
                             </div>
                           </div>
                         </div>
                       </div>
                       <div class="section" title="15.6.2. 终止错误">
                         <div class="titlepage">
                           <div> </div>
                         </div>
                       </div>
                     </div>
                     <div>
                       <div>
                         <div>
                           <h2><a name="trouble.zookeeper" id="trouble.zookeeper"></a>12.11. ZooKeeper</h2>
                         </div>
                       </div>
                     </div>
                     <div title="12.11.1. Startup Errors">
                       <div>
                         <div>
                           <div>
                             <h3><a name="trouble.zookeeper.startup"></a>12.11.1. 启动错误</h3>
                           </div>
                         </div>
                       </div>
                       <div title="12.11.1.1. Could not find my address: xyz in list of ZooKeeper quorum servers">
                         <div>
                           <div>
                             <div>
                               <h4><a name="trouble.zookeeper.startup.address"></a>12.11.1.1. 找不到地址: xyz in list of ZooKeeper quorum servers</h4>
                             </div>
                           </div>
                         </div>
                         <p>A ZooKeeper server wasn't able to start, throws that error. xyz is the name of your server.</p>
                         <p>This is a name lookup problem. HBase tries to start a ZooKeeper server on some machine but that machine isn't able to find itself in the hbase.zookeeper.quorumconfiguration.</p>
                         <p>Use the hostname presented in the error message instead of the value you used. If you have a DNS server, you can set hbase.zookeeper.dns.interface andhbase.zookeeper.dns.nameserver in hbase-site.xml to make sure it resolves to the correct FQDN.</p>
                       </div>
                     </div>
                     <div title="12.11.2. ZooKeeper, The Cluster Canary">
                       <div>
                         <div>
                           <div>
                             <h3><a name="trouble.zookeeper.general"></a>12.11.2. ZooKeeper, The Cluster Canary</h3>
                           </div>
                         </div>
                       </div>
                       <p>ZooKeeper is the cluster's "canary in the mineshaft". It'll be the first to notice issues if any so making sure its happy is the short-cut to a humming cluster.</p>
                       <p>参考  <a href="http://wiki.apache.org/hadoop/ZooKeeper/Troubleshooting" target="_top">ZooKeeper Operating Environment Troubleshooting</a> 页。 It has suggestions and tools for checking disk and networking performance; i.e. the operating environment your ZooKeeper and HBase are running in.</p>
                       <p>Additionally, the utility <a href="#trouble.tools.builtin.zkcli" title="12.4.1.3. zkcli">Section 12.4.1.3, “zkcli”</a> may help investigate ZooKeeper issues.</p>
                     </div>
<p>&nbsp;</p><div class="section" title="12.12.&nbsp;Amazon EC2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.ec2"></a>12.12.&nbsp;Amazon EC2</h2></div></div></div><div class="section" title="12.12.1.&nbsp;ZooKeeper does not seem to work on Amazon EC2"><div class="titlepage"><div><div>
  <h3 class="title"><a name="trouble.ec2.zookeeper"></a>12.12.1.&nbsp;ZooKeeper 在 Amazon EC2上看起来不工作？</h3></div></div></div><p>HBase does not start when deployed as Amazon EC2 instances.  Exceptions like the below appear in the Master and/or RegionServer logs: </p><pre class="programlisting">  2009-10-19 11:52:27,030 INFO org.apache.zookeeper.ClientCnxn: Attempting
  connection to server ec2-174-129-15-236.compute-1.amazonaws.com/10.244.9.171:2181
  2009-10-19 11:52:27,032 WARN org.apache.zookeeper.ClientCnxn: Exception
  closing session 0x0 to sun.nio.ch.SelectionKeyImpl@656dc861
  java.net.ConnectException: Connection refused
             </pre><p>
             Security group policy is blocking the ZooKeeper port on a public address. 
             Use the internal EC2 host names when configuring the ZooKeeper quorum peer list. 
             </p></div><div class="section" title="12.12.2.&nbsp;Instability on Amazon EC2"><div class="titlepage"><div><div>
               <h3 class="title"><a name="trouble.ec2.instability"></a>12.12.2.&nbsp; Amazon EC2 上不稳定？</h3></div></div></div>
             <p>关于 HBase 和Amazon EC2 的问题，经常在HBase 讨论列表上被问起。搜索旧线索，使用 <a class="link" href="http://search-hadoop.com/" target="_top">Search Hadoop</a>
             </p></div><div class="section" title="12.12.3.&nbsp;Remote Java Connection into EC2 Cluster Not Working"><div class="titlepage"><div><div>
               <h3 class="title"><a name="trouble.ec2.connection"></a>12.12.3.&nbsp;远程Java连接到EC2集群不工作</h3></div></div></div>
             <p>
             参考 Andrew回复，更新在用户列表：<a class="link" href="http://search-hadoop.com/m/sPdqNFAwyg2" target="_top">Remote Java client connection into EC2 instance</a>.
             </p></div></div>
             <div class="section" title="12.13.&nbsp;HBase and Hadoop version issues"><div class="titlepage"><div><div>
               <h2 class="title" style="clear: both"><a name="trouble.versions"></a>12.13.&nbsp;HBase 和 Hadoop 版本问题</h2></div></div></div><div class="section" title="12.13.1.&nbsp;NoClassDefFoundError when trying to run 0.90.x on hadoop-0.20.205.x (or hadoop-1.0.x)"><div class="titlepage"><div>
                 <div>
                 <h3 class="title"><a name="trouble.versions.205"></a>12.13.1.&nbsp;当想在adoop-0.20.205.x (或 hadoop-1.0.x)运行 0.90.x 时报<code class="code">NoClassDefFoundError</code></h3>
                 </div></div></div><p>HBase 0.90.x does not ship with hadoop-0.20.205.x, etc.  To make it run, you need to replace the hadoop
             jars that HBase shipped with in its <code class="filename">lib</code> directory with those of the Hadoop you want to
             run HBase on.  If even after replacing Hadoop jars you get the below exception:
</p><pre class="programlisting">sv4r6s38: Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/commons/configuration/Configuration
sv4r6s38:       at org.apache.hadoop.metrics2.lib.DefaultMetricsSystem.&lt;init&gt;(DefaultMetricsSystem.java:37)
sv4r6s38:       at org.apache.hadoop.metrics2.lib.DefaultMetricsSystem.&lt;clinit&gt;(DefaultMetricsSystem.java:34)
sv4r6s38:       at org.apache.hadoop.security.UgiInstrumentation.create(UgiInstrumentation.java:51)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.initialize(UserGroupInformation.java:209)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.ensureInitialized(UserGroupInformation.java:177)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.isSecurityEnabled(UserGroupInformation.java:229)
sv4r6s38:       at org.apache.hadoop.security.KerberosName.&lt;clinit&gt;(KerberosName.java:83)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.initialize(UserGroupInformation.java:202)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.ensureInitialized(UserGroupInformation.java:177)
</pre><p>
you need to copy under <code class="filename">hbase/lib</code>, the <code class="filename">commons-configuration-X.jar</code> you find
in your Hadoop's <code class="filename">lib</code> directory.  That should fix the above complaint.
</p></div></div>
<div class="section" title="12.14.&nbsp;Case Studies"><div class="titlepage"><div><div>
  <h2 class="title" style="clear: both"><a name="trouble.casestudy"></a>12.14.&nbsp;用例研究</h2></div></div></div>
<p>性能和故障诊断用例，参考 <a class="xref" href="#casestudies" title="Chapter&nbsp;13.&nbsp;Case Studies">Chapter&nbsp;13, <i>Case Studies</i></a>.
        </p>
  <hr width="100" align="left">
  <div>
    <p>[<a id="ftn.d352e7542" href="#d352e7542">31</a>]参考获取答案</p>
  </div>
</div>
      
      <div class="chapter" title="Chapter&nbsp;13.&nbsp;Case Studies"><div class="titlepage"><div><div>
        <h2 class="title"><a name="casestudies"></a>Chapter&nbsp;13.&nbsp;用例研究</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#casestudies.overview">13.1. 概述</a></span></dt><dt><span class="section"><a href="#casestudies.schema">13.2. Schema Design</a></span></dt><dd><dl><dt><span class="section"><a href="#casestudies.schema.listdata">13.2.1. List Data</a></span></dt></dl></dd><dt><span class="section"><a href="#casestudies.perftroub">13.3. Performance/Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#casestudies.slownode">13.3.1. Case Study #1 (Performance Issue On A Single Node)</a></span></dt><dt><span class="section"><a href="#casestudies.perf.1">13.3.2. Case Study #2 (Performance Research 2012)</a></span></dt><dt><span class="section"><a href="#casestudies.perf.2">13.3.3. Case Study #3 (Performance Research 2010))</a></span></dt><dt><span class="section"><a href="#casestudies.xceivers">13.3.4. Case Study #4 (xcievers Config)</a></span></dt></dl></dd></dl></div><div class="section" title="13.1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="casestudies.overview"></a>13.1.&nbsp;概述</h2></div></div></div><p>This chapter will describe a variety of performance and troubleshooting case studies that can 
      provide a useful blueprint on diagnosing cluster issues.</p><p>For more information on Performance and Troubleshooting, see <a class="xref" href="#performance" title="Chapter&nbsp;11.&nbsp;Performance Tuning">Chapter&nbsp;11, <i>Performance Tuning</i></a> and <a class="xref" href="#trouble" title="Chapter&nbsp;12.&nbsp;Troubleshooting and Debugging HBase">Chapter&nbsp;12, <i>Troubleshooting and Debugging HBase</i></a>.
      </p></div></div>
      <div class="section" title="13.2.&nbsp;Schema Design"><div class="titlepage"><div><div>
        <h2 class="title" style="clear: both"><a name="casestudies.schema"></a>13.2.&nbsp;模式设计</h2></div></div></div><div class="section" title="13.2.1.&nbsp;List Data"><div class="titlepage"><div><div>
          <h3 class="title"><a name="casestudies.schema.listdata"></a>13.2.1.&nbsp;数据列表</h3></div></div></div><p>The following is an exchange from the user dist-list regarding a fairly common question:  
    		how to handle per-user list data in HBase. 
    		</p><p>*** QUESTION ***</p><p>
    		We're looking at how to store a large amount of (per-user) list data in
HBase, and we were trying to figure out what kind of access pattern made
the most sense.  One option is store the majority of the data in a key, so
we could have something like:
    		</p><pre class="programlisting">&lt;FixedWidthUserName&gt;&lt;FixedWidthValueId1&gt;:"" (no value)
&lt;FixedWidthUserName&gt;&lt;FixedWidthValueId2&gt;:"" (no value)
&lt;FixedWidthUserName&gt;&lt;FixedWidthValueId3&gt;:"" (no value)
			</pre>

The other option we had was to do this entirely using:
    		<pre class="programlisting">&lt;FixedWidthUserName&gt;&lt;FixedWidthPageNum0&gt;:&lt;FixedWidthLength&gt;&lt;FixedIdNextPageNum&gt;&lt;ValueId1&gt;&lt;ValueId2&gt;&lt;ValueId3&gt;...
&lt;FixedWidthUserName&gt;&lt;FixedWidthPageNum1&gt;:&lt;FixedWidthLength&gt;&lt;FixedIdNextPageNum&gt;&lt;ValueId1&gt;&lt;ValueId2&gt;&lt;ValueId3&gt;...
    		</pre><p>
where each row would contain multiple values.
So in one case reading the first thirty values would be:
			</p><pre class="programlisting">scan { STARTROW =&gt; 'FixedWidthUsername' LIMIT =&gt; 30}
    		</pre>
And in the second case it would be
    		<pre class="programlisting">get 'FixedWidthUserName\x00\x00\x00\x00'
    		</pre><p>
The general usage pattern would be to read only the first 30 values of
these lists, with infrequent access reading deeper into the lists.  Some
users would have &lt;= 30 total values in these lists, and some users would
have millions (i.e. power-law distribution)
			</p><p>
 The single-value format seems like it would take up more space on HBase,
but would offer some improved retrieval / pagination flexibility.  Would
there be any significant performance advantages to be able to paginate via
gets vs paginating with scans?
			</p><p>
  My initial understanding was that doing a scan should be faster if our
paging size is unknown (and caching is set appropriately), but that gets
should be faster if we'll always need the same page size.  I've ended up
hearing different people tell me opposite things about performance.  I
assume the page sizes would be relatively consistent, so for most use cases
we could guarantee that we only wanted one page of data in the
fixed-page-length case.  I would also assume that we would have infrequent
updates, but may have inserts into the middle of these lists (meaning we'd
need to update all subsequent rows).
			</p><p>
Thanks for help / suggestions / follow-up questions.
			</p><p>*** ANSWER ***</p><p>
If I understand you correctly, you're ultimately trying to store
triples in the form "user, valueid, value", right? E.g., something
like:
			</p><pre class="programlisting">"user123, firstname, Paul",
"user234, lastname, Smith"
			</pre><p>
(But the usernames are fixed width, and the valueids are fixed width).
			</p><p>
And, your access pattern is along the lines of: "for user X, list the
next 30 values, starting with valueid Y". Is that right? And these
values should be returned sorted by valueid?
			</p><p>
The tl;dr version is that you should probably go with one row per
user+value, and not build a complicated intra-row pagination scheme on
your own unless you're really sure it is needed.
			</p><p>
Your two options mirror a common question people have when designing
HBase schemas: should I go "tall" or "wide"? Your first schema is
"tall": each row represents one value for one user, and so there are
many rows in the table for each user; the row key is user + valueid,
and there would be (presumably) a single column qualifier that means
"the value". This is great if you want to scan over rows in sorted
order by row key (thus my question above, about whether these ids are
sorted correctly). You can start a scan at any user+valueid, read the
next 30, and be done. What you're giving up is the ability to have
transactional guarantees around all the rows for one user, but it
doesn't sound like you need that. Doing it this way is generally
recommended (see
here <a class="link" href="#schema.smackdown" target="_top">#schema.smackdown</a>).
			</p><p>
Your second option is "wide": you store a bunch of values in one row,
using different qualifiers (where the qualifier is the valueid). The
simple way to do that would be to just store ALL values for one user
in a single row. I'm guessing you jumped to the "paginated" version
because you're assuming that storing millions of columns in a single
row would be bad for performance, which may or may not be true; as
long as you're not trying to do too much in a single request, or do
things like scanning over and returning all of the cells in the row,
it shouldn't be fundamentally worse. The client has methods that allow
you to get specific slices of columns.
			</p><p>
Note that neither case fundamentally uses more disk space than the
other; you're just "shifting" part of the identifying information for
a value either to the left (into the row key, in option one) or to the
right (into the column qualifiers in option 2). Under the covers,
every key/value still stores the whole row key, and column family
name. (If this is a bit confusing, take an hour and watch Lars
George's excellent video about understanding HBase schema design:
<a class="link" href="http://www.youtube.com/watch?v=_HLoH_PgrLk)" target="_top">http://www.youtube.com/watch?v=_HLoH_PgrLk)</a>.
			</p><p>
A manually paginated version has lots more complexities, as you note,
like having to keep track of how many things are in each page,
re-shuffling if new values are inserted, etc. That seems significantly
more complex. It might have some slight speed advantages (or
disadvantages!) at extremely high throughput, and the only way to
really know that would be to try it out. If you don't have time to
build it both ways and compare, my advice would be to start with the
simplest option (one row per user+value). Start simple and iterate! :)
			</p></div></div>
            <div class="section" title="13.3.&nbsp;Performance/Troubleshooting"><div class="titlepage"><div><div>
              <h2 class="title" style="clear: both"><a name="casestudies.perftroub"></a>13.3.&nbsp;性能/故障诊断</h2></div></div></div><div class="section" title="13.3.1.&nbsp;Case Study #1 (Performance Issue On A Single Node)"><div class="titlepage"><div><div>
                <h3 class="title"><a name="casestudies.slownode"></a>13.3.1.&nbsp;用例 #1 (单节点性能问题)</h3></div></div></div><div class="section" title="13.3.1.1.&nbsp;Scenario"><div class="titlepage"><div><div>
                  <h4 class="title"><a name="d1934e8563"></a>13.3.1.1.场景</h4></div></div></div><p>Following a scheduled reboot, one data node began exhibiting unusual behavior.  Routine MapReduce 
         jobs run against HBase tables which regularly completed in five or six minutes began taking 30 or 40 minutes 
         to finish. These jobs were consistently found to be waiting on map and reduce tasks assigned to the troubled data node 
         (e.g., the slow map tasks all had the same Input Split).           
         The situation came to a head during a distributed copy, when the copy was severely prolonged by the lagging node.
		</p></div><div class="section" title="13.3.1.2.&nbsp;Hardware"><div class="titlepage"><div><div>
		  <h4 class="title"><a name="d1934e8568"></a>13.3.1.2.&nbsp;硬件</h4></div></div></div><p>Datanodes:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Two 12-core processors</li><li class="listitem">Six Enerprise SATA disks</li><li class="listitem">24GB of RAM</li><li class="listitem">Two bonded gigabit NICs</li></ul></div><p>
        </p><p>Network:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">10 Gigabit top-of-rack switches</li><li class="listitem">20 Gigabit bonded interconnects between racks.</li></ul></div><p>
        </p></div><div class="section" title="13.3.1.3.&nbsp;Hypotheses"><div class="titlepage"><div><div>
          <h4 class="title"><a name="d1934e8591"></a>13.3.1.3.&nbsp;假设</h4></div></div></div><div class="section" title="13.3.1.3.1.&nbsp;HBase &quot;Hot Spot&quot; Region"><div class="titlepage"><div><div>
            <h5 class="title"><a name="d1934e8594"></a>13.3.1.3.1.&nbsp;HBase "热点" 区域</h5></div></div></div><p>We hypothesized that we were experiencing a familiar point of pain: a "hot spot" region in an HBase table, 
		  where uneven key-space distribution can funnel a huge number of requests to a single HBase region, bombarding the RegionServer 
		  process and cause slow response time. Examination of the HBase Master status page showed that the number of HBase requests to the 
		  troubled node was almost zero.  Further, examination of the HBase logs showed that there were no region splits, compactions, or other region transitions 
		  in progress.  This effectively ruled out a "hot spot" as the root cause of the observed slowness.
          </p></div><div class="section" title="13.3.1.3.2.&nbsp;HBase Region With Non-Local Data"><div class="titlepage"><div><div>
            <h5 class="title"><a name="d1934e8599"></a>13.3.1.3.2.&nbsp;HBase 分区具有非本地数据</h5></div></div></div><p>Our next hypothesis was that one of the MapReduce tasks was requesting data from HBase that was not local to the datanode, thus 
		  forcing HDFS to request data blocks from other servers over the network.  Examination of the datanode logs showed that there were very 
		  few blocks being requested over the network, indicating that the HBase region was correctly assigned, and that the majority of the necessary 
		  data was located on the node. This ruled out the possibility of non-local data causing a slowdown.
          </p></div><div class="section" title="13.3.1.3.3.&nbsp;Excessive I/O Wait Due To Swapping Or An Over-Worked Or Failing Hard Disk"><div class="titlepage"><div><div><h5 class="title"><a name="d1934e8604"></a>13.3.1.3.3.&nbsp;Excessive I/O Wait Due To Swapping Or An Over-Worked Or Failing Hard Disk</h5></div></div></div><p>After concluding that the Hadoop and HBase were not likely to be the culprits, we moved on to troubleshooting the datanode's hardware. 
          Java, by design, will periodically scan its entire memory space to do garbage collection.  If system memory is heavily overcommitted, the Linux 
          kernel may enter a vicious cycle, using up all of its resources swapping Java heap back and forth from disk to RAM as Java tries to run garbage 
          collection.  Further, a failing hard disk will often retry reads and/or writes many times before giving up and returning an error. This can manifest 
          as high iowait, as running processes wait for reads and writes to complete.  Finally, a disk nearing the upper edge of its performance envelope will 
          begin to cause iowait as it informs the kernel that it cannot accept any more data, and the kernel queues incoming data into the dirty write pool in memory.  
          However, using <code class="code">vmstat(1)</code> and <code class="code">free(1)</code>, we could see that no swap was being used, and the amount of disk IO was only a few kilobytes per second.
          </p></div><div class="section" title="13.3.1.3.4.&nbsp;Slowness Due To High Processor Usage"><div class="titlepage"><div><div><h5 class="title"><a name="d1934e8615"></a>13.3.1.3.4.&nbsp;Slowness Due To High Processor Usage</h5></div></div></div><p>Next, we checked to see whether the system was performing slowly simply due to very high computational load.  <code class="code">top(1)</code> showed that the system load 
          was higher than normal, but <code class="code">vmstat(1)</code> and <code class="code">mpstat(1)</code> showed that the amount of processor being used for actual computation was low.
          </p></div><div class="section" title="13.3.1.3.5.&nbsp;Network Saturation (The Winner)"><div class="titlepage"><div><div><h5 class="title"><a name="d1934e8629"></a>13.3.1.3.5.&nbsp;Network Saturation (The Winner)</h5></div></div></div><p>Since neither the disks nor the processors were being utilized heavily, we moved on to the performance of the network interfaces.  The datanode had two 
          gigabit ethernet adapters, bonded to form an active-standby interface.  <code class="code">ifconfig(8)</code> showed some unusual anomalies, namely interface errors, overruns, framing errors. 
          While not unheard of, these kinds of errors are exceedingly rare on modern hardware which is operating as it should:
</p><pre class="programlisting">		
$ /sbin/ifconfig bond0
bond0  Link encap:Ethernet  HWaddr 00:00:00:00:00:00  
inet addr:10.x.x.x  Bcast:10.x.x.255  Mask:255.255.255.0
UP BROADCAST RUNNING MASTER MULTICAST  MTU:1500  Metric:1
RX packets:2990700159 errors:12 dropped:0 overruns:1 frame:6          &lt;--- Look Here! Errors!
TX packets:3443518196 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0 
RX bytes:2416328868676 (2.4 TB)  TX bytes:3464991094001 (3.4 TB)
</pre><p>
          </p><p>These errors immediately lead us to suspect that one or more of the ethernet interfaces might have negotiated the wrong line speed.  This was confirmed both by running an ICMP ping 
          from an external host and observing round-trip-time in excess of 700ms, and by running <code class="code">ethtool(8)</code> on the members of the bond interface and discovering that the active interface 
          was operating at 100Mbs/, full duplex.
</p><pre class="programlisting">		
$ sudo ethtool eth0
Settings for eth0:
Supported ports: [ TP ]
Supported link modes:   10baseT/Half 10baseT/Full 
                       100baseT/Half 100baseT/Full 
                       1000baseT/Full 
Supports auto-negotiation: Yes
Advertised link modes:  10baseT/Half 10baseT/Full 
                       100baseT/Half 100baseT/Full 
                       1000baseT/Full 
Advertised pause frame use: No
Advertised auto-negotiation: Yes
Link partner advertised link modes:  Not reported
Link partner advertised pause frame use: No
Link partner advertised auto-negotiation: No
Speed: 100Mb/s                                     &lt;--- Look Here!  Should say 1000Mb/s!
Duplex: Full
Port: Twisted Pair
PHYAD: 1
Transceiver: internal
Auto-negotiation: on
MDI-X: Unknown
Supports Wake-on: umbg
Wake-on: g
Current message level: 0x00000003 (3)
Link detected: yes
</pre><p>		
		  </p><p>In normal operation, the ICMP ping round trip time should be around 20ms, and the interface speed and duplex should read, "1000MB/s", and, "Full", respectively.  
		  </p></div></div><div class="section" title="13.3.1.4.&nbsp;Resolution"><div class="titlepage"><div><div>
		    <h4 class="title"><a name="d1934e8650"></a>13.3.1.4.&nbsp;结论</h4></div></div></div><p>After determining that the active ethernet adapter was at the incorrect speed, we used the <code class="code">ifenslave(8)</code> command to make the standby interface 
   	  the active interface, which yielded an immediate improvement in MapReduce performance, and a 10 times improvement in network throughput:
	  </p><p>On the next trip to the datacenter, we determined that the line speed issue was ultimately caused by a bad network cable, which was replaced.
	  </p></div></div><div class="section" title="13.3.2.&nbsp;Case Study #2 (Performance Research 2012)"><div class="titlepage"><div><div>
	    <h3 class="title"><a name="casestudies.perf.1"></a>13.3.2.&nbsp;用例 #2 (性能研究 2012)</h3></div></div></div><p>Investigation results of a self-described "we're not sure what's wrong, but it seems slow" problem. 
      <a class="link" href="http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html" target="_top">http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html</a>
      </p></div><div class="section" title="13.3.3.&nbsp;Case Study #3 (Performance Research 2010))"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.perf.2"></a>13.3.3.&nbsp;Case Study #3 (Performance Research 2010))</h3></div></div></div><p>
      Investigation results of general cluster performance from 2010.  Although this research is on an older version of the codebase, this writeup
      is still very useful in terms of approach.
      <a class="link" href="http://hstack.org/hbase-performance-testing/" target="_top">http://hstack.org/hbase-performance-testing/</a>
      </p></div><div class="section" title="13.3.4.&nbsp;Case Study #4 (xcievers Config)"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.xceivers"></a>13.3.4.&nbsp;Case Study #4 (xcievers Config)</h3></div></div></div><p>Case study of configuring <code class="code">xceivers</code>, and diagnosing errors from mis-configurations.
      <a class="link" href="http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html" target="_top">http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html</a>
      </p><p>参考 also <a class="xref" href="#dfs.datanode.max.xcievers" title="2.3.2.&nbsp;dfs.datanode.max.xcievers">Section&nbsp;2.3.2, “<code class="varname">dfs.datanode.max.xcievers</code>”</a>.
      </p></div></div>
      
      <div class="chapter" title="Chapter&nbsp;14.&nbsp;HBase Operational Management"><div class="titlepage"><div><div>
        <h2 class="title"><a name="ops_mgt"></a>Chapter&nbsp;14.&nbsp;HBase 运维管理</h2></div></div></div>
      <div class="toc"><p><b>Table of Contents</b></p>
        <p><b> </b><span class="section"><a href="#tools">14.1. HBase <span class="title" style="clear: both">工具和实用程序</span></a></span></p>
        <p><span class="section"><a href="#ops.regionmgt">14.2. 区域管理</a></span></p>
        <p><span class="section"><a href="#node.management">14.3. 节点管理</a></span></p>
        <dl>
          <dt><span class="section"><a href="#hbase_metrics">14.4. HBase 度量</a></span></dt><dd>&nbsp;</dd>
          <dt><span class="section"><a href="#ops.monitoring">14.5. HBase 监控</a></span></dt><dd>&nbsp;</dd>
          <dt><span class="section"><a href="#cluster_replication">14.6. 集群复制</a></span></dt>
          <dd>&nbsp;</dd>
          <dt><span class="section"><a href="#ops.backup">14.7. HBase 备份</a></span></dt>
          <dd>&nbsp;</dd>
          <dd><span class="section"><a href="#ops.backup"></a></span><span class="section"><a href="#ops.backup"></a></span><span class="section"><a href="#ops.backup"></a></span></dd>
          <dt><span class="section"><a href="#ops.capacity">14.8. 容量计划</a></span></dt>
          <dd><dl><dt>&nbsp;</dt></dl></dd></dl></div>
      
  This chapter will cover operational tools and practices required of a running HBase cluster.
  The subject of operations is related to the topics of <a class="xref" href="#trouble" title="Chapter&nbsp;12.&nbsp;Troubleshooting and Debugging HBase">Chapter&nbsp;12, <i>Troubleshooting and Debugging HBase</i></a>, <a class="xref" href="#performance" title="Chapter&nbsp;11.&nbsp;Performance Tuning">Chapter&nbsp;11, <i>Performance Tuning</i></a>,
  and <a class="xref" href="#configuration" title="Chapter&nbsp;2.&nbsp;Configuration">Chapter&nbsp;2, <i>Configuration</i></a> but is a distinct topic in itself.  
  
  <div class="section" title="14.1.&nbsp;HBase Tools and Utilities"><div class="titlepage"><div><div>
    <h2 class="title" style="clear: both"><a name="tools"></a>14.1.&nbsp;HBase 工具和实用程序</h2></div></div></div>
  <p>这里我们给出HBase工具列表，可用于管理，分析，修复和调试。</p><div class="section" title="14.1.1.&nbsp;Driver"><div class="titlepage"><div><div>
    <h3 class="title"><a name="driver"></a>14.1.1.&nbsp;驱动</h3></div></div></div><p>There is a <code class="code">Driver</code> class that is executed by the HBase jar can be used to invoke frequently accessed utilities.  For example, 
</p><pre class="programlisting">HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-VERSION.jar 
</pre><p>
... will return...
</p><pre class="programlisting">An example program must be given as the first argument.
Valid program names are:
  completebulkload: Complete a bulk data load.
  copytable: Export a table from local cluster to peer cluster
  export: Write table data to HDFS.
  import: Import data written by Export.
  importtsv: Import data in TSV format.
  rowcounter: Count rows in HBase table
  verifyrep: Compare the data from tables in two different clusters. WARNING: It doesn't work for incrementColumnValues'd cells since the timestamp is chan
</pre><p>
... for allowable program names.
      </p></div><div class="section" title="14.1.2.&nbsp;HBase hbck"><div class="titlepage"><div><div><h3 class="title"><a name="hbck"></a>14.1.2.&nbsp;HBase <span class="application">hbck</span></h3></div><div><h4 class="subtitle">An <span class="emphasis"><em>fsck</em></span> for your HBase install</h4></div></div></div><p>To run <span class="application">hbck</span> against your HBase cluster run
        </p><pre class="programlisting">$ ./bin/hbase hbck</pre><p>
        At the end of the commands output it prints <span class="emphasis"><em>OK</em></span>
        or <span class="emphasis"><em>INCONSISTENCY</em></span>. If your cluster reports
        inconsistencies, pass <span class="command"><strong>-details</strong></span> to see more detail emitted.
        If inconsistencies, run <span class="command"><strong>hbck</strong></span> a few times because the
        inconsistency may be transient (e.g. cluster is starting up or a region is
        splitting).
        Passing <span class="command"><strong>-fix</strong></span> may correct the inconsistency (This latter
        is an experimental feature).
        </p><p>For more information, see <a class="xref" href="#hbck.in.depth" title="Appendix&nbsp;B.&nbsp;hbck In Depth">Appendix&nbsp;B, <i>hbck In Depth</i></a>.
        </p></div><div class="section" title="14.1.3.&nbsp;HFile Tool"><div class="titlepage"><div><div>
          <h3 class="title"><a name="hfile_tool2"></a>14.1.3.&nbsp;HFile 工具</h3></div></div></div>
        <p>参考 <a class="xref" href="#hfile_tool" title="9.7.5.2.2.&nbsp;HFile Tool">Section&nbsp;9.7.5.2.2, “HFile Tool”</a>.</p></div><div class="section" title="14.1.4.&nbsp;WAL Tools"><div class="titlepage"><div><div>
          <h3 class="title"><a name="wal_tools"></a>14.1.4.&nbsp;WAL 工具</h3></div></div></div><div class="section" title="14.1.4.1.&nbsp;HLog tool"><div class="titlepage"><div><div><h4 class="title"><a name="hlog_tool"></a>14.1.4.1.&nbsp;<code class="classname">HLog</code> tool</h4></div></div></div><p>The main method on <code class="classname">HLog</code> offers manual
        split and dump facilities. Pass it WALs or the product of a split, the
        content of the <code class="filename">recovered.edits</code>. directory.</p><p>You can get a textual dump of a WAL file content by doing the
        following:</p><pre class="programlisting"> <code class="code">$ ./bin/hbase org.apache.hadoop.hbase.regionserver.wal.HLog --dump hdfs://example.org:8020/hbase/.logs/example.org,60020,1283516293161/10.10.21.10%3A60020.1283973724012</code> </pre><p>The
        return code will be non-zero if issues with the file so you can test
        wholesomeness of file by redirecting <code class="varname">STDOUT</code> to
        <code class="code">/dev/null</code> and testing the program return.</p><p>Similarly you can force a split of a log file directory by
        doing:</p><pre class="programlisting"> $ ./<code class="code">bin/hbase org.apache.hadoop.hbase.regionserver.wal.HLog --split hdfs://example.org:8020/hbase/.logs/example.org,60020,1283516293161/</code></pre><div class="section" title="14.1.4.1.1.&nbsp;HLogPrettyPrinter"><div class="titlepage"><div><div><h5 class="title"><a name="hlog_tool.prettyprint"></a>14.1.4.1.1.&nbsp;<code class="classname">HLogPrettyPrinter</code></h5></div></div></div><p><code class="classname">HLogPrettyPrinter</code> is a tool with configurable options to print the contents of an HLog.
          </p></div></div></div><div class="section" title="14.1.5.&nbsp;Compression Tool"><div class="titlepage"><div><div><h3 class="title"><a name="compression.tool"></a>14.1.5.&nbsp;Compression Tool</h3></div></div></div><p>参考 <a class="xref" href="#compression.test" title="C.1.&nbsp;CompressionTest Tool">Section&nbsp;C.1, “CompressionTest Tool”</a>.</p></div><div class="section" title="14.1.6.&nbsp;CopyTable"><div class="titlepage"><div><div><h3 class="title"><a name="copytable"></a>14.1.6.&nbsp;CopyTable</h3></div></div></div><p>
            CopyTable is a utility that can copy part or of all of a table, either to the same cluster or another cluster. The usage is as follows:
</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable [--starttime=X] [--endtime=Y] [--new.name=NEW] [--peer.adr=ADR] tablename
</pre><p>
        </p><p>
        Options:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="varname">starttime</code>  Beginning of the time range.  Without endtime means starttime to forever.</li><li class="listitem"><code class="varname">endtime</code>  End of the time range.  Without endtime means starttime to forever.</li><li class="listitem"><code class="varname">versions</code>  Number of cell versions to copy.</li><li class="listitem"><code class="varname">new.name</code>  New table's name.</li><li class="listitem"><code class="varname">peer.adr</code>  Address of the peer cluster given in the format hbase.zookeeper.quorum:hbase.zookeeper.client.port:zookeeper.znode.parent</li><li class="listitem"><code class="varname">families</code>  Comma-separated list of ColumnFamilies to copy.</li><li class="listitem"><code class="varname">all.cells</code>  Also copy delete markers and uncollected deleted cells (advanced option).</li></ul></div><p>
         Args:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">tablename  Name of table to copy.</li></ul></div><p>
        </p><p>Example of copying 'TestTable' to a cluster that uses replication for a 1 hour window:
</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable
--starttime=1265875194289 --endtime=1265878794289
--peer.adr=server1,server2,server3:2181:/hbase TestTable</pre><p>
        </p><div class="note" title="Scanner Caching" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Scanner Caching</h3><p>Caching for the input Scan is configured via <code class="code">hbase.client.scanner.caching</code> in the job configuration.
        </p></div><p>
        参考 Jonathan Hsieh's <a class="link" href="http://www.cloudera.com/blog/2012/06/online-hbase-backups-with-copytable-2/" target="_top">Online HBase Backups with CopyTable</a> blog post for more on <span class="command"><strong>CopyTable</strong></span>.
        </p></div><div class="section" title="14.1.7.&nbsp;Export"><div class="titlepage"><div><div>
          <h3 class="title"><a name="export"></a>14.1.7.&nbsp;导出</h3></div></div></div>
        <p>导出实用工具可以将表的内容输出成HDFS的序列化文件，如下调用：</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.Export &lt;tablename&gt; &lt;outputdir&gt; [&lt;versions&gt; [&lt;starttime&gt; [&lt;endtime&gt;]]]
</pre><p>
       </p><p>Note:  caching for the input Scan is configured via <code class="code">hbase.client.scanner.caching</code> in the job configuration.
        </p></div><div class="section" title="14.1.8.&nbsp;Import"><div class="titlepage"><div><div>
          <h3 class="title"><a name="import"></a>14.1.8.&nbsp;导入</h3></div></div></div>
        <p>导入实用工具可以加载导出的数据回到HBase，如下调用：</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.Import &lt;tablename&gt; &lt;inputdir&gt;
</pre><p>
       </p></div><div class="section" title="14.1.9.&nbsp;ImportTsv"><div class="titlepage"><div><div><h3 class="title"><a name="importtsv"></a>14.1.9.&nbsp;ImportTsv</h3></div></div></div><p>ImportTsv is a utility that will load data in TSV format into HBase.  It has two distinct usages:  loading data from TSV format in HDFS 
       into HBase via Puts, and preparing StoreFiles to be loaded via the <code class="code">completebulkload</code>.
       </p><p>To load data via Puts (i.e., non-bulk loading):
</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c &lt;tablename&gt; &lt;hdfs-inputdir&gt;
</pre><p>
       </p><p>To generate StoreFiles for bulk-loading:
</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c -Dimporttsv.bulk.output=hdfs://storefile-outputdir &lt;tablename&gt; &lt;hdfs-data-inputdir&gt;
</pre><p>
       </p><p>These generated StoreFiles can be loaded into HBase via <a class="xref" href="#completebulkload" title="14.1.10.&nbsp;CompleteBulkLoad">Section&nbsp;14.1.10, “CompleteBulkLoad”</a>. 
       </p><div class="section" title="14.1.9.1.&nbsp;ImportTsv Options"><div class="titlepage"><div><div>
         <h4 class="title"><a name="importtsv.options"></a>14.1.9.1.&nbsp;ImportTsv 选项</h4></div></div></div>
       Running ImportTsv with no arguments prints brief usage information:
<pre class="programlisting">Usage: importtsv -Dimporttsv.columns=a,b,c &lt;tablename&gt; &lt;inputdir&gt;

Imports the given input directory of TSV data into the specified table.

The column names of the TSV data must be specified using the -Dimporttsv.columns
option. This option takes the form of comma-separated column names, where each
column name is either a simple column family, or a columnfamily:qualifier. The special
column name HBASE_ROW_KEY is used to designate that this column should be used
as the row key for each imported record. You must specify exactly one column
to be the row key, and you must specify a column name for every column that exists in the
input data.

By default importtsv will load data directly into HBase. To instead generate
HFiles of data to prepare for a bulk data load, pass the option:
  -Dimporttsv.bulk.output=/path/for/output
  Note: if you do not use this option, then the target table must already exist in HBase

Other options that may be specified with -D include:
  -Dimporttsv.skip.bad.lines=false - fail if encountering an invalid line
  '-Dimporttsv.separator=|' - eg separate on pipes instead of tabs
  -Dimporttsv.timestamp=currentTimeAsLong - use the specified timestamp for the import
  -Dimporttsv.mapper.class=my.Mapper - A user-defined Mapper to use instead of org.apache.hadoop.hbase.mapreduce.TsvImporterMapper
</pre></div><div class="section" title="14.1.9.2.&nbsp;ImportTsv Example"><div class="titlepage"><div><div>
  <h4 class="title"><a name="importtsv.example"></a>14.1.9.2.&nbsp;ImportTsv 示例</h4></div></div></div><p>For example, assume that we are loading data into a table called 'datatsv' with a ColumnFamily called 'd' with two columns "c1" and "c2".
         </p><p>Assume that an input file exists as follows:
</p><pre class="programlisting">row1	c1	c2
row2	c1	c2
row3	c1	c2
row4	c1	c2
row5	c1	c2
row6	c1	c2
row7	c1	c2
row8	c1	c2
row9	c1	c2
row10	c1	c2
</pre><p>
         </p><p>For ImportTsv to use this imput file, the command line needs to look like this:
 </p><pre class="programlisting"> HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-VERSION.jar importtsv -Dimporttsv.columns=HBASE_ROW_KEY,d:c1,d:c2 -Dimporttsv.bulk.output=hdfs://storefileoutput  datatsv hdfs://inputfile
 </pre><p>
         ... and in this example the first column is the rowkey, which is why the HBASE_ROW_KEY is used.  The second and third columns in the file will be imported as "d:c1" and "d:c2", respectively.
         </p></div><div class="section" title="14.1.9.3.&nbsp;ImportTsv Warning"><div class="titlepage"><div><div><h4 class="title"><a name="importtsv.warning"></a>14.1.9.3.&nbsp;ImportTsv Warning</h4></div></div></div><p>If you have preparing a lot of data for bulk loading, make sure the target HBase table is pre-split appropriately.
         </p></div><div class="section" title="14.1.9.4.&nbsp;See Also"><div class="titlepage"><div><div>
           <h4 class="title"><a name="importtsv.also"></a>14.1.9.4.&nbsp;参考</h4></div></div></div>
       For more information about bulk-loading HFiles into HBase, see <a class="xref" href="#arch.bulk.load" title="9.8.&nbsp;Bulk Loading">Section&nbsp;9.8, “Bulk Loading”</a></div></div><div class="section" title="14.1.10.&nbsp;CompleteBulkLoad"><div class="titlepage"><div><div><h3 class="title"><a name="completebulkload"></a>14.1.10.&nbsp;CompleteBulkLoad</h3></div></div></div>
       <p><code class="code">completebulkload</code> 实用工具可以将产生的存储文件移动到HBase表。该工具经常和<a class="xref" href="#importtsv" title="14.1.9.&nbsp;ImportTsv">Section&nbsp;14.1.9, “ImportTsv”</a> 的输出联合使用。  
	   </p>
       <p>两种方法调用该工具，带显式类名或通过驱动：</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles &lt;hdfs://storefileoutput&gt; &lt;tablename&gt;
</pre>
       <p>
.. 通过驱动..
</p><pre class="programlisting">HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-VERSION.jar completebulkload &lt;hdfs://storefileoutput&gt; &lt;tablename&gt;
</pre><p>
	  </p>
<p> 批量导入 HFiles 到 HBase的更多信息 ，参考 <a class="xref" href="#arch.bulk.load" title="9.8.&nbsp;Bulk Loading">Section&nbsp;9.8, “Bulk Loading”</a>.
       </p></div><div class="section" title="14.1.11.&nbsp;WALPlayer"><div class="titlepage"><div><div><h3 class="title"><a name="walplayer"></a>14.1.11.&nbsp;WALPlayer</h3></div></div></div>
       <p>WALPlayer 实用工具可以重放 WAL 文件到 HBase.
       </p><p>The WAL can be replayed for a set of tables or all tables, and a timerange can be provided (in milliseconds). The WAL is filtered to this set of tables. The output can optionally be mapped to another set of tables.
       </p><p>WALPlayer can also generate HFiles for later bulk importing, in that case only a single table and no mapping can be specified.
       </p><p>Invoke via:
</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer [options] &lt;wal inputdir&gt; &lt;tables&gt; [&lt;tableMappings&gt;]&gt;
</pre><p>
       </p><p>For example:
</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer /backuplogdir oldTable1,oldTable2 newTable1,newTable2
</pre><p>
       </p></div><div class="section" title="14.1.12.&nbsp;RowCounter"><div class="titlepage"><div><div><h3 class="title"><a name="rowcounter"></a>14.1.12.&nbsp;RowCounter</h3></div></div></div>
       <p>RowCounter 实用工具可以统计表的行数。这是一个好工具，如果担心元数据可能存在不一致，可以用于确认HBase可以读取表的所有分块。</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.RowCounter &lt;tablename&gt; [&lt;column1&gt; &lt;column2&gt;...]
</pre><p>
       </p><p>Note:  caching for the input Scan is configured via <code class="code">hbase.client.scanner.caching</code> in the job configuration.
       </p></div></div></div>
       
       <div class="section" title="14.2.&nbsp;Region Management"><div class="titlepage"><div><div>
         <h2 class="title" style="clear: both"><a name="ops.regionmgt"></a>14.2.&nbsp;区域管理</h2></div></div></div><div class="section" title="14.2.1.&nbsp;Major Compaction"><div class="titlepage"><div><div>
           <h3 class="title"><a name="ops.regionmgt.majorcompact"></a>14.2.1.&nbsp;主紧缩</h3></div></div></div>
         <p>主紧缩可以通过HBase shell 或 <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact%28java.lang.String%29" target="_top">HBaseAdmin.majorCompact</a> 进行。</p>
           <p>注意：主紧缩<strong><em>不</em></strong>进行区域合并。更多关于紧缩的信息，参考 <a class="xref" href="#compaction" title="9.7.5.5.&nbsp;Compaction">Section&nbsp;9.7.5.5, “Compaction”</a></p></div><div class="section" title="14.2.2.&nbsp;Merge"><div class="titlepage"><div><div>
             <h3 class="title"><a name="ops.regionmgt.merge"></a>14.2.2.&nbsp;合并</h3></div></div></div><p>Merge is a utility that can merge adjoining regions in the same table (see org.apache.hadoop.hbase.util.Merge).</p><pre class="programlisting">$ bin/hbase org.apache.hbase.util.Merge &lt;tablename&gt; &lt;region1&gt; &lt;region2&gt;
</pre><p>If you feel you have too many regions and want to consolidate them, Merge is the utility you need.  Merge must
      run be done when the cluster is down.  
      参考 the <a class="link" href="http://ofps.oreilly.com/titles/9781449396107/performance.html" target="_top">O'Reilly HBase Book</a> for
      an example of usage.
      </p><p>Additionally, there is a Ruby script attached to <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1621" target="_top">HBASE-1621</a> 
      for region merging.
      </p></div></div>
      
      <div class="section" title="14.3.&nbsp;Node Management"><div class="titlepage"><div><div>
        <h2 class="title" style="clear: both"><a name="node.management"></a>14.3.&nbsp;节点管理</h2></div></div></div><div class="section" title="14.3.1.&nbsp;Node Decommission"><div class="titlepage"><div><div>
          <h3 class="title"><a name="decommission"></a>14.3.1.&nbsp;节点下线</h3></div></div></div><p>你可以在HBase的特定的节点上运行下面的脚本来停止RegionServer: </p>
          <pre class="programlisting">$ ./bin/hbase-daemon.sh stop regionserver</pre>
          <p> RegionServer会首先关闭所有的region然后把它自己关闭，在停止的过程中，RegionServer的会向Zookeeper报告说他已经过期了。master会发现RegionServer已经死了，会把它当作崩溃的server来处理。他会将region分配到其他的节点上去。 </p>
          <div class="note" title="在下线节点之前要停止Load Balancer" style="margin-left: 0.5in; margin-right: 0.5in;">
            <h3 class="title">在下线节点之前要停止Load Balancer</h3>
            <p>如果在运行load balancer的时候，一个节点要关闭， 则Load Balancer和Master的recovery可能会争夺这个要下线的Regionserver。为了避免这个问题，先将load balancer停止，参见下面的 <a class="xref" href="#lb" title="Load Balancer">Load Balancer</a>. </p>
          </div>
          <p></p>
          <p> RegionServer下线有一个缺点就是其中的Region会有好一会离线。Regions是被按顺序关闭的。如果一个server上有很多region,从第一个region会被下线，到最后一个region被关闭，并且Master确认他已经死了，该region才可以上线，整个过程要花很长时间。在HBase 0.90.2中，我们加入了一个功能，可以让节点逐渐的摆脱他的负载，最后关闭。HBase 0.90.2加入了 <code class="filename">graceful_stop.sh</code>脚本，可以这样用， </p>
          <pre class="programlisting">$ ./bin/graceful_stop.sh 
Usage: graceful_stop.sh [--config &amp;conf-dir&gt;] [--restart] [--reload] [--thrift] [--rest] &amp;hostname&gt;
 thrift      If we should stop/start thrift before/after the hbase stop/start
 rest        If we should stop/start rest before/after the hbase stop/start
 restart     If we should restart after graceful stop
 reload      Move offloaded regions back on to the stopped server
 debug       Move offloaded regions back on to the stopped server
 hostname    Hostname of server we are to stop</pre>
          <p></p>
          <p> 要下线一台RegionServer可以这样做 </p>
          <pre class="programlisting">$ ./bin/graceful_stop.sh HOSTNAME</pre>
          <p> 这里的<code class="varname">HOSTNAME</code>是RegionServer的host
            you would decommission. </p>
          <div class="note" title="On HOSTNAME" style="margin-left: 0.5in; margin-right: 0.5in;">
            <h3 class="title">On <code class="varname">HOSTNAME</code></h3>
            <p>传递到<code class="filename">graceful_stop.sh</code>的<code class="varname">HOSTNAME</code>必须和hbase使用的hostname一致，hbase用它来区分RegionServers。可以用master的UI来检查RegionServers的id。通常是hostname,也可能是FQDN。不管HBase使用的哪一个，你可以将它传到 <code class="filename">graceful_stop.sh</code>脚本中去，目前他还不支持使用IP地址来推断hostname。所以使用IP就会发现server不在运行，也没有办法下线了。 </p>
          </div>
          <p> <code class="filename">graceful_stop.sh</code> 脚本会一个一个将region从RegionServer中移除出去，以减少改RegionServer的负载。他会先移除一个region,然后再将这个region安置到一个新的地方，再移除下一个，直到全部移除。最后<code class="filename">graceful_stop.sh</code>脚本会让RegionServer <span class="command"><strong>stop</strong></span>.,Master会注意到RegionServer已经下线了，这个时候所有的region已经重新部署好。RegionServer就可以干干净净的结束，没有WAL日志需要分割。 </p>
          <div class="note" title="Load Balancer" style="margin-left: 0.5in; margin-right: 0.5in;">
            <h3 class="title"><a name="lb"></a>Load Balancer</h3>
            <p> 当执行<span class="command"><strong>graceful_stop</strong></span>脚本的时候，要将Region Load Balancer关掉(否则balancer和下线脚本会在region部署的问题上存在冲突): </p>
            <pre class="programlisting">hbase(main):001:0&gt; balance_switch false
true
0 row(s) in 0.3590 seconds</pre>
            <p> 上面是将balancer关掉，要想开启： </p>
            <pre class="programlisting">hbase(main):001:0&gt; balance_switch true
false
0 row(s) in 0.3590 seconds</pre>
            <p></p>
          </div>
          <p></p>
          <div class="note" title="Load Balancer" style="margin-left: 0.5in; margin-right: 0.5in;"><p>
            </p></div><p>
        </p></div><div class="section" title="14.3.2.&nbsp;Rolling Restart"><div class="titlepage"><div>
          <div><h3 class="title"><a name="rolling"></a>14.3.2.&nbsp;依次重启</h3>
          </div></div></div><p>你还可以让这个脚本重启一个RegionServer,不改变上面的Region的位置。要想保留数据的位置，你可以依次重启(Rolling Restart),就像这样: </p>
          <pre class="programlisting">$ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &amp;&gt; /tmp/log.txt &amp;
            </pre>
          <p> Tail <code class="filename">/tmp/log.txt</code>来看脚本的运行过程.上面的脚本只对RegionServer进行操作。要确认load balancer已经关掉。还需要在之前更新master。下面是一段依次重启的伪脚本,你可以借鉴它： </p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
                <p>确认你的版本，保证配置已经rsync到整个集群中。如果版本是0.90.2，需要打上HBASE-3744 和 HBASE-3756两个补丁。 </p>
              </li>
              <li class="listitem">
                <p>运行hbck确保你的集群是一致的 </p>
                <pre class="programlisting">$ ./bin/hbase hbck</pre>
                <p> 当发现不一致的时候，可以修复他。 </p>
              </li>
              <li class="listitem">
                <p>重启Master: </p>
                <pre class="programlisting">$ ./bin/hbase-daemon.sh stop master; ./bin/hbase-daemon.sh start master</pre>
                <p></p>
              </li>
              <li class="listitem">
                <p> 关闭region balancer:</p>
                <pre class="programlisting">$ echo "balance_switch false" | ./bin/hbase</pre>
                <p></p>
              </li>
              <li class="listitem">
                <p>在每个RegionServer上运行<code class="filename">graceful_stop.sh</code>： </p>
                <pre class="programlisting">$ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &amp;&gt; /tmp/log.txt &amp;
            </pre>
                <p> 如果你在RegionServer还开起来thrift和rest server。还需要加上--thrift or --rest 选项 (参见 <code class="filename">graceful_stop.sh</code> 脚本的用法). </p>
              </li>
              <li class="listitem">
                <p>再次重启Master.这会把已经死亡的server列表清空，重新开启balancer. </p>
              </li>
              <li class="listitem">
                <p>运行 hbck 保证集群是一直的 </p>
              </li>
            </ol>
          </div>
          <div class="orderedlist"></div><p>
        </p></div></div>
        <div class="section" title="14.4.&nbsp;HBase Metrics"><div class="titlepage"><div><div>
          <h2 class="title" style="clear: both"><a name="hbase_metrics"></a>14.4.&nbsp;HBase 度量</h2></div></div></div><div class="section" title="14.4.1.&nbsp;Metric Setup"><div class="titlepage"><div>
          <div>
            <h3 class="title"><a name="metric_setup"></a>14.4.1.&nbsp;度量<span class="title" style="clear: both">安装</span></h3>
          </div></div></div><p>参见 <a class="link" href="http://hbase.apache.org/metrics.html" target="_top">Metrics</a> 可以获得一个enable Metrics emission的指导。</p>
        </div><div class="section" title="14.4.2.&nbsp;RegionServer Metrics"><div class="titlepage"><div><div>
          <h3 class="title"><a name="rs_metrics"></a>14.4.2.&nbsp;区域服务器度量</h3></div></div></div><div class="section" title="14.4.2.1.&nbsp;hbase.regionserver.blockCacheCount"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheCount"></a>14.4.2.1.&nbsp;<code class="varname">hbase.regionserver.blockCacheCount</code></h4></div></div></div><p>内存中的Block cache item数量。这个是存储文件(HFiles)的缓存中的数量。</p>
        </div><div class="section" title="14.4.2.2.&nbsp;hbase.regionserver.blockCacheEvictedCount"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheEvictedCount"></a>14.4.2.2.&nbsp;<code class="varname">hbase.regionserver.blockCacheEvictedCount</code></h4></div></div></div><p>Number of blocks that had to be evicted from the block cache due to heap size constraints.</p></div><div class="section" title="14.4.2.3.&nbsp;hbase.regionserver.blockCacheFree"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheFree"></a>14.4.2.3.&nbsp;<code class="varname">hbase.regionserver.blockCacheFree</code></h4></div></div></div><p>内存中的Block cache memory 剩余 (单位 bytes).</p>
        </div><div class="section" title="14.4.2.4.&nbsp;hbase.regionserver.blockCacheHitCachingRatio"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheHitCachingRatio"></a>14.4.2.4.&nbsp;<code class="varname">hbase.regionserver.blockCacheHitCachingRatio</code></h4></div></div></div><p>Block cache hit caching ratio (0 to 100).  The cache-hit ratio for reads configured to look in the cache (i.e., cacheBlocks=true). </p></div><div class="section" title="14.4.2.5.&nbsp;hbase.regionserver.blockCacheHitCount"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheHitCount"></a>14.4.2.5.&nbsp;<code class="varname">hbase.regionserver.blockCacheHitCount</code></h4></div></div></div><p>Number of blocks of StoreFiles (HFiles) read from the cache.</p></div><div class="section" title="14.4.2.6.&nbsp;hbase.regionserver.blockCacheHitRatio"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheHitRatio"></a>14.4.2.6.&nbsp;<code class="varname">hbase.regionserver.blockCacheHitRatio</code></h4></div></div></div><p>Block cache 命中率(0 到 100).  Includes all read requests, although those with cacheBlocks=false
            will always read from disk and be counted as a "cache miss"</p>
          <p>&nbsp;</p>
        </div><div class="section" title="14.4.2.7.&nbsp;hbase.regionserver.blockCacheMissCount"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheMissCount"></a>14.4.2.7.&nbsp;<code class="varname">hbase.regionserver.blockCacheMissCount</code></h4></div></div></div>
        <p>StoreFiles (HFiles)请求的未在缓存中的分块数量。</p></div><div class="section" title="14.4.2.8.&nbsp;hbase.regionserver.blockCacheSize"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.blockCacheSize"></a>14.4.2.8.&nbsp;<code class="varname">hbase.regionserver.blockCacheSize</code></h4></div></div></div><p>内存中的Block cache 大小 (单位 bytes).  i.e., memory in use by the BlockCache</p></div><div class="section" title="14.4.2.9.&nbsp;hbase.regionserver.compactionQueueSize"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.compactionQueueSize"></a>14.4.2.9.&nbsp;<code class="varname">hbase.regionserver.compactionQueueSize</code></h4></div></div></div><p>compaction队列的大小. 这个值是需要进行compaction的region数目</p>
        </div><div class="section" title="14.4.2.10.&nbsp;hbase.regionserver.flushQueueSize"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.flushQueueSize"></a>14.4.2.10.&nbsp;<code class="varname">hbase.regionserver.flushQueueSize</code></h4></div></div></div><p>Number of enqueued regions in the MemStore awaiting flush.</p></div><div class="section" title="14.4.2.11.&nbsp;hbase.regionserver.fsReadLatency_avg_time"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.fsReadLatency_avg_time"></a>14.4.2.11.&nbsp;<code class="varname">hbase.regionserver.fsReadLatency_avg_time</code></h4></div></div></div><p>文件系统延迟 (ms). 这个值是平均读HDFS的延迟时间</p>
        </div><div class="section" title="14.4.2.12.&nbsp;hbase.regionserver.fsReadLatency_num_ops"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.fsReadLatency_num_ops"></a>14.4.2.12.&nbsp;<code class="varname">hbase.regionserver.fsReadLatency_num_ops</code></h4></div></div></div>
        <p>文件系统读操作。</p></div><div class="section" title="14.4.2.13.&nbsp;hbase.regionserver.fsSyncLatency_avg_time"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.fsSyncLatency_avg_time"></a>14.4.2.13.&nbsp;<code class="varname">hbase.regionserver.fsSyncLatency_avg_time</code></h4></div></div></div><p>文件系统同步延迟(ms).  Latency to sync the write-ahead log records to the filesystem.</p></div><div class="section" title="14.4.2.14.&nbsp;hbase.regionserver.fsSyncLatency_num_ops"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.fsSyncLatency_num_ops"></a>14.4.2.14.&nbsp;<code class="varname">hbase.regionserver.fsSyncLatency_num_ops</code></h4></div></div></div><p>Number of operations to sync the write-ahead log records to the filesystem.</p></div><div class="section" title="14.4.2.15.&nbsp;hbase.regionserver.fsWriteLatency_avg_time"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.fsWriteLatency_avg_time"></a>14.4.2.15.&nbsp;<code class="varname">hbase.regionserver.fsWriteLatency_avg_time</code></h4></div></div></div><p>文件系统写延迟(ms).  Total latency for all writers, including StoreFiles and write-head log.</p></div><div class="section" title="14.4.2.16.&nbsp;hbase.regionserver.fsWriteLatency_num_ops"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.fsWriteLatency_num_ops"></a>14.4.2.16.&nbsp;<code class="varname">hbase.regionserver.fsWriteLatency_num_ops</code></h4></div></div></div><p>Number of filesystem write operations, including StoreFiles and write-ahead log.</p></div><div class="section" title="14.4.2.17.&nbsp;hbase.regionserver.memstoreSizeMB"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.memstoreSizeMB"></a>14.4.2.17.&nbsp;<code class="varname">hbase.regionserver.memstoreSizeMB</code></h4></div></div></div><p>所有的RegionServer的memstore大小 (MB)</p>
        </div><div class="section" title="14.4.2.18.&nbsp;hbase.regionserver.regions"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.regions"></a>14.4.2.18.&nbsp;<code class="varname">hbase.regionserver.regions</code></h4></div></div></div><p>RegionServer服务的regions数量</p>
        </div><div class="section" title="14.4.2.19.&nbsp;hbase.regionserver.requests"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.requests"></a>14.4.2.19.&nbsp;<code class="varname">hbase.regionserver.requests</code></h4></div></div></div>
          <p>读写请求的全部数量。请求是指RegionServer的RPC数量，因此一次Get一个请求，但一个缓存设为1000的Scan也会在每次调用'next'时导致一个请求。一个批量load是一个Hfile一个请求。</p></div><div class="section" title="14.4.2.20.&nbsp;hbase.regionserver.storeFileIndexSizeMB"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.storeFileIndexSizeMB"></a>14.4.2.20.&nbsp;<code class="varname">hbase.regionserver.storeFileIndexSizeMB</code></h4></div></div></div><p>当前RegionServer的storefile索引的总大小(MB)</p>
          </div><div class="section" title="14.4.2.21.&nbsp;hbase.regionserver.stores"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.stores"></a>14.4.2.21.&nbsp;<code class="varname">hbase.regionserver.stores</code></h4></div></div></div>
            <p>RegionServer打开的stores数量。一个stores对应一个列族。例如，一个包含列族的表有3个region在这个RegionServer上，对应一个 列族就会有3个store.</p></div><div class="section" title="14.4.2.22.&nbsp;hbase.regionserver.storeFiles"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.storeFiles"></a>14.4.2.22.&nbsp;<code class="varname">hbase.regionserver.storeFiles</code></h4></div></div></div><p>RegionServer打开的存储文件(HFile)数量。这个值一定大于等于store的数量。</p>
            </div></div></div>
           
           <div class="section" title="14.5.&nbsp;HBase Monitoring"><div class="titlepage"><div><div>
             <h2 class="title" style="clear: both"><a name="ops.monitoring"></a>14.5.&nbsp;HBase 监控</h2></div></div></div><div class="section" title="14.5.1.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="ops.monitoring.overview"></a>14.5.1.&nbsp;概述</h3></div></div></div>
             <p>下面的度量方法对每个区域服务器的宏观监控被证明是是最重要的，特别是在像 <a class="link" href="http://opentsdb.net/" target="_top">OpenTSDB</a>这样的系统中。如果你的集群具有性能问题，你可能得参考本组信息。</p><p>HBase: 
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Requests</li><li class="listitem">Compactions queue</li></ul></div><p>
      </p><p>OS: 
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">IO Wait</li><li class="listitem">User CPU</li></ul></div><p>
      </p><p>Java: 
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">GC</li></ul></div><p>
      </p><p>
      </p>
      <p>
      HBase度量的更多信息，参考 <a class="xref" href="#hbase_metrics" title="14.4.&nbsp;HBase Metrics">Section&nbsp;14.4, “HBase Metrics”</a>.
      </p></div><div class="section" title="14.5.2.&nbsp;Slow Query Log"><div class="titlepage"><div><div>
        <h3 class="title"><a name="ops.slow.query"></a>14.5.2.&nbsp;查询太慢的日志</h3></div></div></div>
      <p>HBase查询太慢的日志由可分析的 JSON结构描述。客户端操作 (Gets, Puts, Deletes, 等)的属性， 要么运行太久，或产生输出太多。“运行太久”和“输出太多”的门限可配置，如后面所述。输出产生在主区域服务器日志中，以便和其他日志事件一起发现更多细节。它也前置区分标签<code class="constant">(responseTooSlow)</code>, <code class="constant">(responseTooLarge)</code>, <code class="constant">(operationTooSlow)</code>和<code class="constant">(operationTooLarge)</code>，以便当用户只希望看到慢查询时，用grep过滤。</p><div class="section" title="14.5.2.1.&nbsp;Configuration"><div class="titlepage"><div><div>
        <h4 class="title"><a name="d1952e9354"></a>14.5.2.1.&nbsp;配置</h4></div></div></div>
        <p>有两个配置节可用于调整查询太慢日志的门限。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><code class="varname">hbase.ipc.warn.response.time</code> 不被记录太慢日志的查询执行的最大毫秒数(millisecond) 。缺省10000, 即 10 秒。可设 -1 禁止通过时间长短记入日志。
</li>
<li class="listitem"><code class="varname">hbase.ipc.warn.response.size</code> 不被记录日志的查询可返回的最大字节数。缺省 100 MB，可设为 -1 禁止通过大小记入日志。</li></ul></div></div><div class="section" title="14.5.2.2.&nbsp;Metrics"><div class="titlepage"><div><div>
  <h4 class="title"><a name="d1952e9368"></a>14.5.2.2.&nbsp;度量</h4></div></div></div>
<p>查询太慢日志暴露给了JMX 度量。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc">
    <li class="listitem"><code class="varname">hadoop.regionserver_rpc_slowResponse</code> 是一个全局度量，反射所有超时记入日志的响应。</li>
    <li class="listitem"><code class="varname">hadoop.regionserver_rpc_methodName.aboveOneSec</code> 一个度量，反射所有超过一秒时间的响应。</li></ul></div><p>
</p></div><div class="section" title="14.5.2.3.&nbsp;Output"><div class="titlepage"><div><div>
  <h4 class="title"><a name="d1952e9383"></a>14.5.2.3.&nbsp;输出</h4></div></div></div>
<p>输出以操作做标签，如 <code class="constant">(operationTooSlow)</code> 。如果调用是客户端操作，如 Put, Get, 或 Delete，会暴露详细指纹信息。否则，标签为 <code class="constant">(responseTooSlow)</code> ，也同样提供可分析的JSON 输出，但具有较少细节信息，完全依赖于RPC自身的超时和超量设置。 <code class="constant">TooLarge</code> 代替 <code class="constant">TooSlow</code> 如果响应大小引起日志记录。在大小和时长都引起日志记录时，也是 <code class="constant">TooLarge</code> 后置。</p></div><div class="section" title="14.5.2.4.&nbsp;Example"><div class="titlepage"><div><div>
  <h4 class="title"><a name="d1952e9403"></a>14.5.2.4.&nbsp;示例</h4></div></div></div><p>
</p><pre class="programlisting">2011-09-08 10:01:25,824 WARN org.apache.hadoop.ipc.HBaseServer: (operationTooSlow): {"tables":{"riley2":{"puts":[{"totalColumns":11,"families":{"actions":[{"timestamp":1315501284459,"qualifier":"0","vlen":9667580},{"timestamp":1315501284459,"qualifier":"1","vlen":10122412},{"timestamp":1315501284459,"qualifier":"2","vlen":11104617},{"timestamp":1315501284459,"qualifier":"3","vlen":13430635}]},"row":"cfcd208495d565ef66e7dff9f98764da:0"}],"families":["actions"]}},"processingtimems":956,"client":"10.47.34.63:33623","starttimems":1315501284456,"queuetimems":0,"totalPuts":1,"class":"HRegionServer","responsesize":0,"method":"multiPut"}</pre><p>
</p>
<p>注意，在"tables"结构里的所有东西，是MultiPut的指纹打印的输出。其余的信息是RPC相关的，如处理时间和客户端IP/port。 客户端的其他操作的模式和通用结构与此相同，但根据单个操作的类型会有一定的不同。如果调用不是客户端操作，则指纹细节信息将完全没有。</p>
<p>对本示例而言，指出了缓慢的原因可能是简单的超大 ( 100MB) multiput，通过 "vlen" 即 value length告知，multiPut中的每个put的域有该信息。
</p></div></div></div>
<div class="section" title="14.6.&nbsp;Cluster Replication"><div class="titlepage"><div><div>
  <h2 class="title" style="clear: both"><a name="cluster_replication"></a>14.6.&nbsp;集群复制</h2></div></div></div>
<p>参见 <a class="link" href="http://hbase.apache.org/replication.html" target="_top">集群复制</a>.
    </p></div>
    <div class="section" title="14.7.&nbsp;HBase Backup"><div class="titlepage"><div><div>
      <h2 class="title" style="clear: both"><a name="ops.backup"></a>14.7.&nbsp;HBase 备份</h2></div></div></div>
    <p>有两种通常策略进行 HBase 备份：停止整个集群再备份，和在正在使用的集群上备份。 
    每一种途径都有优缺点。   
    </p>
    <p>更多信息，参考Sematext的Blog <a class="link" href="http://blog.sematext.com/2011/03/11/hbase-backup-options/" target="_top">HBase Backup Options</a>. </p><div class="section" title="14.7.1.&nbsp;Full Shutdown Backup"><div class="titlepage"><div><div>
      <h3 class="title"><a name="ops.backup.fullshutdown"></a>14.7.1.&nbsp;全停止备份</h3></div></div></div>
      <p>一些环境可以容忍暂时停止 HBase 集群，如用于后台容量分析，并不提供前台页面。  好处是 NameNode/Master 和 RegionServers是停止的， 不会有任何机会丢失正在处理改变的保存文件或元数据。明显的坏处是集群被 关闭。步骤包括：
      </p><div class="section" title="14.7.1.1.&nbsp;Stop HBase"><div class="titlepage"><div><div>
        <h4 class="title"><a name="ops.backup.fullshutdown.stop"></a>14.7.1.1.&nbsp;停止 HBase</h4></div></div></div><p>
        </p></div><div class="section" title="14.7.1.2.&nbsp;Distcp"><div class="titlepage"><div><div><h4 class="title"><a name="ops.backup.fullshutdown.distcp"></a>14.7.1.2.&nbsp;Distcp</h4></div></div></div>
        <p>Distcp 既用于将HDFS里面的HBase 目录下的内容拷贝到当前集群的另一个目录，也可以拷贝到另一个集群。</p>
        <p>注意：  Distcp 工作的情形是集群关闭，没有正在改变的文件。Distcp 不推荐用于正工作着的集群。</p></div><div class="section" title="14.7.1.3.&nbsp;Restore (if needed)"><div class="titlepage"><div><div>
          <h4 class="title"><a name="ops.backup.fullshutdown.restore"></a>14.7.1.3.&nbsp;恢复 (如有必要)</h4></div></div></div>
        <p>通过distcp，从 HDFS备份的数据被拷贝到 '真实' 的hbase 目录。 复制动作产生新的 HDFS 元数据， 所以并不需要从备份的NameNode 元数据恢复, 因为是通过distcp从一个特定的 HDFS 目录 (如, HBase 部分)复制， 不是整个HDFS 文件系统。 </p></div></div><div class="section" title="14.7.2.&nbsp;Live Cluster Backup - Replication"><div class="titlepage"><div><div>
          <h3 class="title"><a name="ops.backup.live.replication"></a>14.7.2.&nbsp;工作集群备份 - Replication</h3></div></div></div>
        <p>这种方法假设有另一个集群。参考HBase的 <a class="link" href="http://hbase.apache.org/replication.html" target="_top">replication</a> 。
      </p></div><div class="section" title="14.7.3.&nbsp;Live Cluster Backup - CopyTable"><div class="titlepage"><div><div><h3 class="title"><a name="ops.backup.live.copytable"></a>14.7.3.&nbsp;工作集群备份 - CopyTable</h3></div></div></div>
      <p><a class="xref" href="#copytable" title="14.1.6.&nbsp;CopyTable">&nbsp;14.1.6节, “CopyTable”</a> 工具，即可用于将一个表复制到同集群的另一个表，也可将表复制到另一个集群的另一个表。
      </p>
      <p>由于集群在工作，有丢失正在改变的数据的风险。
      </p></div><div class="section" title="14.7.4.&nbsp;Live Cluster Backup - Export"><div class="titlepage"><div><div><h3 class="title"><a name="ops.backup.live.export"></a>14.7.4.&nbsp;工作集群备份 - Export</h3></div></div></div>
      <p><a class="xref" href="#export" title="14.1.7.&nbsp;Export">&nbsp;14.1.7节, “Export”</a> 是一种将 HDFS 内容导出到同一集群的方法。  恢复数据，
      <a class="xref" href="#import" title="14.1.8.&nbsp;Import">14.1.8节, “Import”</a> 工具可以使用。</p><p>由于集群在工作，有丢失正在改变的数据的风险。</p>
      </div></div>
      
      <div class="section" title="14.8.&nbsp;Capacity Planning"><div class="titlepage"><div><div>
        <h2 class="title" style="clear: both"><a name="ops.capacity"></a>14.8.&nbsp;容量计划</h2></div></div></div><div class="section" title="14.8.1.&nbsp;Storage"><div class="titlepage"><div><div>
          <h3 class="title"><a name="ops.capacity.storage"></a>14.8.1.存储</h3></div></div></div>
        <p>一个常见问题是HBase管理员需要估算一个HBase集群要用多大存储量。可以通过几个方面去考虑，最重要的是集群要加载什么数据。  开始于对HBase内部处理数据(KeyValue)的可靠了解。</p><div class="section" title="14.8.1.1.&nbsp;KeyValue"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.storage.kv"></a>14.8.1.1.&nbsp;KeyValue</h4></div></div></div><p>HBase storage will be dominated by KeyValues.  参考 <a class="xref" href="#keyvalue" title="9.7.5.4.&nbsp;KeyValue">Section&nbsp;9.7.5.4, “KeyValue”</a> and <a class="xref" href="#keysize" title="6.3.2.&nbsp;Try to minimize row and column sizes">Section&nbsp;6.3.2, “Try to minimize row and column sizes”</a> for 
        how HBase stores data internally.  
        </p><p>It is critical to understand that there is a KeyValue instance for every attribute stored in a row, and the 
        rowkey-length, ColumnFamily name-length and attribute lengths will drive the size of the database more than any other
        factor.
        </p></div><div class="section" title="14.8.1.2.&nbsp;StoreFiles and Blocks"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.storage.sf"></a>14.8.1.2.&nbsp;StoreFiles and Blocks</h4></div></div></div><p>KeyValue instances are aggregated into blocks, and the blocksize is configurable on a per-ColumnFamily basis.
        Blocks are aggregated into StoreFile's.  参考 <a class="xref" href="#regions.arch" title="9.7.&nbsp;Regions">Section&nbsp;9.7, “Regions”</a>.
        </p></div><div class="section" title="14.8.1.3.&nbsp;HDFS Block Replication"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.storage.hdfs"></a>14.8.1.3.&nbsp;HDFS Block Replication</h4></div></div></div><p>Because HBase runs on top of HDFS, factor in HDFS block replication into storage calculations.
        </p></div></div><div class="section" title="14.8.2.&nbsp;Regions"><div class="titlepage"><div><div>
          <h3 class="title"><a name="ops.capacity.regions"></a>14.8.2.&nbsp;区域</h3></div></div></div><p>Another common question for HBase administrators is determining the right number of regions per
      RegionServer.  This affects both storage and hardware planning. 参考 <a class="xref" href="#perf.number.of.regions" title="11.4.1.&nbsp;Number of Regions">Section&nbsp;11.4.1, “Number of Regions”</a>.
      </p></div></div>
      
      <div class="chapter" title="Chapter&nbsp;15.&nbsp;Building and Developing HBase"><div class="titlepage"><div><div>
        <h2 class="title"><a name="developer"></a>Chapter&nbsp;15.&nbsp;创建和部署HBase</h2></div></div></div><div class="toc"><p>&nbsp;</p></div>
      <p>This chapter will be of interest only to those building and developing HBase (i.e., as opposed to
    just downloading the latest distribution).
    </p><div class="section" title="15.1.&nbsp;HBase Repositories"><div class="titlepage"><div><div>
      <h2 class="title" style="clear: both"><a name="repos"></a>15.1.&nbsp;HBase 版本库</h2></div></div></div><div class="section" title="15.1.1.&nbsp;SVN"><div class="titlepage"><div><div><h3 class="title"><a name="svn"></a>15.1.1.&nbsp;SVN</h3></div></div></div><pre class="programlisting">svn co http://svn.apache.org/repos/asf/hbase/trunk hbase-core-trunk 
        </pre></div><div class="section" title="15.1.2.&nbsp;Git"><div class="titlepage"><div><div><h3 class="title"><a name="git"></a>15.1.2.&nbsp;Git</h3></div></div></div><pre class="programlisting">git clone git://git.apache.org/hbase.git
        </pre></div></div></div>
        
        <div class="section" title="15.2.&nbsp;IDEs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ides"></a>15.2.&nbsp;IDEs</h2></div></div></div><div class="section" title="15.2.1.&nbsp;Eclipse"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse"></a>15.2.1.&nbsp;Eclipse</h3></div></div></div><div class="section" title="15.2.1.1.&nbsp;Code Formatting"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.code.formatting"></a>15.2.1.1.&nbsp;Code Formatting</h4></div></div></div><p>参考 <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3678" target="_top">HBASE-3678 Add Eclipse-based Apache Formatter to HBase Wiki</a>
              for an Eclipse formatter to help ensure your code conforms to HBase'y coding convention.
            The issue includes instructions for loading the attached formatter.</p><p>In addition to the automatic formatting, make sure you follow the style guidelines explained in <a class="xref" href="#common.patch.feedback" title="15.9.5.&nbsp;Common Patch Feedback">Section&nbsp;15.10.5, “Common Patch Feedback”</a></p><p>Also, no @author tags - that's a rule.  Quality Javadoc comments are appreciated.  And include the Apache license.</p></div><div class="section" title="15.2.1.2.&nbsp;Subversive Plugin"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.svn"></a>15.2.1.2.&nbsp;Subversive Plugin</h4></div></div></div><p>Download and install the Subversive plugin.</p><p>Set up an SVN Repository target from <a class="xref" href="#svn" title="15.1.1.&nbsp;SVN">Section&nbsp;15.1.1, “SVN”</a>, then check out the code.</p></div><div class="section" title="15.2.1.3.&nbsp;Git Plugin"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.git.plugin"></a>15.2.1.3.&nbsp;Git Plugin</h4></div></div></div><p>If you cloned the project via git, download and install the Git plugin (EGit). Attach to your local git repo (via the Git Repositories window) and you'll be able to see file revision history, generate patches, etc.</p></div><div class="section" title="15.2.1.4.&nbsp;HBase Project Setup in Eclipse"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.maven.setup"></a>15.2.1.4.&nbsp;HBase Project Setup in Eclipse</h4></div></div></div><p>The easiest way is to use the m2eclipse plugin for Eclipse. Eclipse Indigo or newer has m2eclipse built-in, or it can be found here:http://www.eclipse.org/m2e/. M2Eclipse provides Maven integration for Eclipse - it even lets you use the direct Maven commands from within Eclipse to compile and test your project.</p><p>To import the project, you merely need to go to File-&gt;Import...Maven-&gt;Existing Maven Projects and then point Eclipse at the HBase root directory; m2eclipse will automatically find all the hbase modules for you.</p><p>If you install m2eclipse and import HBase in your workspace, you will have to fix your eclipse Build Path.
            Remove <code class="filename">target</code> folder, add <code class="filename">target/generated-jamon</code>
            and <code class="filename">target/generated-sources/java</code> folders. You may also remove from your Build Path
            the exclusions on the <code class="filename">src/main/resources</code> and <code class="filename">src/test/resources</code>
            to avoid error message in the console 'Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.6:run (default) on project hbase: 
            'An Ant BuildException has occured: Replace: source file .../target/classes/hbase-default.xml doesn't exist'. This will also
            reduce the eclipse build cycles and make your life easier when developing.</p></div><div class="section" title="15.2.1.5.&nbsp;Import into eclipse with the command line"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.commandline"></a>15.2.1.5.&nbsp;Import into eclipse with the command line</h4></div></div></div><p>For those not inclined to use m2eclipse, you can generate the Eclipse files from the command line. First, run (you should only have to do this once): 
            </p><pre class="programlisting">mvn clean install -DskipTests</pre><p>
            and then close Eclipse and execute...
            </p><pre class="programlisting">mvn eclipse:eclipse</pre><p>
            ... from your local HBase project directory in your workspace to generate some new <code class="filename">.project</code> 
            and <code class="filename">.classpath</code>files.  Then reopen Eclipse, and import the .project file in the HBase directory to a workspace.
            </p></div><div class="section" title="15.2.1.6.&nbsp;Maven Classpath Variable"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.maven.class"></a>15.2.1.6.&nbsp;Maven Classpath Variable</h4></div></div></div><p>The <code class="varname">M2_REPO</code> classpath variable needs to be set up for the project.  This needs to be set to 
            your local Maven repository, which is usually <code class="filename">~/.m2/repository</code></p>
            If this classpath variable is not configured, you will see compile errors in Eclipse like this...
            <pre class="programlisting">Description	Resource	Path	Location	Type
The project cannot be built until build path errors are resolved	hbase		Unknown	Java Problem 
Unbound classpath variable: 'M2_REPO/asm/asm/3.1/asm-3.1.jar' in project 'hbase'	hbase		Build path	Build Path Problem
Unbound classpath variable: 'M2_REPO/com/github/stephenc/high-scale-lib/high-scale-lib/1.1.1/high-scale-lib-1.1.1.jar' in project 'hbase'	hbase		Build path	Build Path Problem 
Unbound classpath variable: 'M2_REPO/com/google/guava/guava/r09/guava-r09.jar' in project 'hbase'	hbase		Build path	Build Path Problem
Unbound classpath variable: 'M2_REPO/com/google/protobuf/protobuf-java/2.3.0/protobuf-java-2.3.0.jar' in project 'hbase'	hbase		Build path	Build Path Problem Unbound classpath variable:
            </pre></div><div class="section" title="15.2.1.7.&nbsp;Eclipse Known Issues"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.issues"></a>15.2.1.7.&nbsp;Eclipse Known Issues</h4></div></div></div><p>Eclipse will currently complain about <code class="filename">Bytes.java</code>.  It is not possible to turn these errors off.</p><pre class="programlisting">            
Description	Resource	Path	Location	Type
Access restriction: The method arrayBaseOffset(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar	Bytes.java	/hbase/src/main/java/org/apache/hadoop/hbase/util	line 1061	Java Problem
Access restriction: The method arrayIndexScale(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar	Bytes.java	/hbase/src/main/java/org/apache/hadoop/hbase/util	line 1064	Java Problem
Access restriction: The method getLong(Object, long) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar	Bytes.java	/hbase/src/main/java/org/apache/hadoop/hbase/util	line 1111	Java Problem
             </pre></div><div class="section" title="15.2.1.8.&nbsp;Eclipse - More Information"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.more"></a>15.2.1.8.&nbsp;Eclipse - More Information</h4></div></div></div><p>For additional information on setting up Eclipse for HBase development on Windows, see 
             <a class="link" href="http://michaelmorello.blogspot.com/2011/09/hbase-subversion-eclipse-windows.html" target="_top">Michael Morello's blog</a> on the topic.
             </p></div></div></div>
             
             <div class="section" title="15.3.&nbsp;Building HBase"><div class="titlepage"><div><div>
               <h2 class="title" style="clear: both"><a name="build"></a>15.3.&nbsp;创建HBase</h2></div></div></div><p>This section will be of interest only to those building HBase from source.
      </p><div class="section" title="15.3.1.&nbsp;Building in snappy compression support"><div class="titlepage"><div><div><h3 class="title"><a name="build.snappy"></a>15.3.1.&nbsp;Building in snappy compression support</h3></div></div></div><p>Pass <code class="code">-Dsnappy</code> to trigger the snappy maven profile for building
            snappy native libs into hbase.</p></div><div class="section" title="15.3.2.&nbsp;Building the HBase tarball"><div class="titlepage"><div><div><h3 class="title"><a name="build.tgz"></a>15.3.2.&nbsp;Building the HBase tarball</h3></div></div></div><p>Do the following to build the HBase tarball.
        Passing the -Drelease will generate javadoc and run the RAT plugin to verify licenses on source.
        </p><pre class="programlisting">% MAVEN_OPTS="-Xmx2g" mvn clean site install assembly:single -Dmaven.test.skip -Prelease</pre><p>
</p></div><div class="section" title="15.3.3.&nbsp;Adding an HBase release to Apache's Maven Repository"><div class="titlepage"><div><div><h3 class="title"><a name="mvn_repo"></a>15.3.3.&nbsp;Adding an HBase release to Apache's Maven Repository</h3></div></div></div><p>Follow the instructions at
        <a class="link" href="http://www.apache.org/dev/publishing-maven-artifacts.html" target="_top">Publishing Maven Artifacts</a>.
            The 'trick' to making it all work is answering the questions put to you by the mvn release plugin properly,
            making sure it is using the actual branch AND before doing the <span class="command"><strong>mvn release:perform</strong></span> step,
            VERY IMPORTANT, check and if necessary hand edit the release.properties file that was put under <code class="varname">${HBASE_HOME}</code>
            by the previous step, <span class="command"><strong>release:perform</strong></span>. You need to edit it to make it point at
            right locations in SVN.
        </p><p>Use maven 3.0.x.
        </p><p>At the <span class="command"><strong>mvn release:perform</strong></span> step, before starting, if you are for example
        releasing hbase 0.92.0, you need to make sure the pom.xml version is 0.92.0-SNAPSHOT.  This needs
        to be checked in.  Since we do the maven release after actual release, I've been doing this
        checkin into a particular tag rather than into the actual release tag.  So, say we released
        hbase 0.92.0 and now we want to do the release to the maven repository, in svn, the 0.92.0
        release will be tagged 0.92.0.  Making the maven release, copy the 0.92.0 tag to 0.92.0mvn.
        Check out this tag and change the version therein and commit.
        </p><p>Here is how I'd answer the questions at <span class="command"><strong>release:prepare</strong></span> time:
        </p><pre class="programlisting">What is the release version for "HBase"? (org.apache.hbase:hbase) 0.92.0: : 
What is SCM release tag or label for "HBase"? (org.apache.hbase:hbase) hbase-0.92.0: : 0.92.0mvnrelease
What is the new development version for "HBase"? (org.apache.hbase:hbase) 0.92.1-SNAPSHOT: : 
[INFO] Transforming 'HBase'...</pre><p>
        </p><p>A strange issue I ran into was the one where the upload into the apache
        repository was being sprayed across multiple apache machines making it so I could
        not release.  参考 <a class="link" href="https://issues.apache.org/jira/browse/INFRA-4482" target="_top">INFRA-4482 Why is my upload to mvn spread across multiple repositories?</a>.</p><p><a name="mvn.settings.file"></a>Here is my <code class="filename">~/.m2/settings.xml</code>.
        </p><pre class="programlisting">&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                      http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;
  &lt;servers&gt;
    &lt;!- To publish a snapshot of some part of Maven --&gt;
    &lt;server&gt;
      &lt;id&gt;apache.snapshots.https&lt;/id&gt;
      &lt;username&gt;YOUR_APACHE_ID
      &lt;/username&gt;
      &lt;password&gt;YOUR_APACHE_PASSWORD
      &lt;/password&gt;
    &lt;/server&gt;
    &lt;!-- To publish a website using Maven --&gt;
    &lt;!-- To stage a release of some part of Maven --&gt;
    &lt;server&gt;
      &lt;id&gt;apache.releases.https&lt;/id&gt;
      &lt;username&gt;YOUR_APACHE_ID
      &lt;/username&gt;
      &lt;password&gt;YOUR_APACHE_PASSWORD
      &lt;/password&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;apache-release&lt;/id&gt;
      &lt;properties&gt;
    &lt;gpg.keyname&gt;YOUR_KEYNAME&lt;/gpg.keyname&gt;
    &lt;!--Keyname is something like this ... 00A5F21E... do gpg --list-keys to find it--&gt;
    &lt;gpg.passphrase&gt;YOUR_KEY_PASSWORD
    &lt;/gpg.passphrase&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
        </pre><p>
        </p><p>When you run <span class="command"><strong>release:perform</strong></span>, pass <span class="command"><strong>-Papache-release</strong></span>
        else it will not 'sign' the artifacts it uploads.
        </p><p>If you see run into the below, its because you need to edit version in the pom.xml and add
        <code class="code">-SNAPSHOT</code> to the version (and commit).
        </p><pre class="programlisting">[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'release'.
[INFO] ------------------------------------------------------------------------
[INFO] Building HBase
[INFO]    task-segment: [release:prepare] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [release:prepare {execution: default-cli}]
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] You don't have a SNAPSHOT project in the reactor projects list.
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3 seconds
[INFO] Finished at: Sat Mar 26 18:11:07 PDT 2011
[INFO] Final Memory: 35M/423M
[INFO] -----------------------------------------------------------------------</pre><p>
        </p></div><div class="section" title="15.3.4.&nbsp;Build Gotchas"><div class="titlepage"><div><div><h3 class="title"><a name="build.gotchas"></a>15.3.4.&nbsp;Build Gotchas</h3></div></div></div><p>If you see <code class="code">Unable to find resource 'VM_global_library.vm'</code>, ignore it.  
			Its not an error.  It is <a class="link" href="http://jira.codehaus.org/browse/MSITE-286" target="_top">officially ugly</a> though.
           </p>
          <div title="15.4. Adding an Apache HBase release to Apache's Maven Repository">
            <div>
              <div>
                <div>
                  <h2>15.4. Adding an Apache HBase release to Apache's Maven Repository</h2>
                </div>
              </div>
            </div>
            <p>Follow the instructions at <a href="http://www.apache.org/dev/publishing-maven-artifacts.html" target="_top">Publishing Maven Artifacts</a> after reading the below miscellaney.</p>
            <p>You must use maven 3.0.x (Check by running <strong>mvn -version</strong>).</p>
            <p>Let me list out the commands I used first. The sections that follow dig in more on what is going on. In this example, we are releasing the 0.92.2 jar to the apache maven repository.</p>
            <pre>  # First make a copy of the tag we want to release; presumes the release has been tagged already    # We do this because we need to make some commits for the mvn release plugin to work.    853  svn copy -m "Publishing 0.92.2 to mvn"  https://svn.apache.org/repos/asf/hbase/tags/0.92.2 https://svn.apache.org/repos/asf/hbase/tags/0.92.2mvn    857  svn checkout https://svn.apache.org/repos/asf/hbase/tags/0.92.2mvn    858  cd 0.92.2mvn/    # Edit the version making it release version with a '-SNAPSHOT' suffix (See below for more on this)    860  vi pom.xml    861  svn commit -m "Add SNAPSHOT to the version" pom.xml    862  ~/bin/mvn/bin/mvn release:clean    865  ~/bin/mvn/bin/mvn release:prepare    866  # Answer questions and then ^C to kill the build after the last question. See below for more on this.    867  vi release.properties         # Change the references to trunk svn to be 0.92.2mvn; the release plugin presumes trunk         # Then restart the release:prepare -- it won't ask questions         # because the properties file exists.    868  ~/bin/mvn/bin/mvn release:prepare    # The apache-release profile comes from the apache parent pom and does signing of artifacts published    869  ~/bin/mvn/bin/mvn release:perform  -Papache-release         # When done copying up to apache staging repository,         # browse to repository.apache.org, login and finish         # the release as according to the above         # "Publishing Maven Artifacts.          </pre>
            <p>Below is more detail on the commmands listed above.</p>
            <p>At the <strong>mvn release:perform</strong> step, before starting, if you are for example releasing hbase 0.92.2, you need to make sure the pom.xml version is 0.92.2-SNAPSHOT. This needs to be checked in. Since we do the maven release after actual release, I've been doing this checkin into a copy of the release tag rather than into the actual release tag itself (presumes the release has been properly tagged in svn). So, say we released hbase 0.92.2 and now we want to do the release to the maven repository, in svn, the 0.92.2 release will be tagged 0.92.2. Making the maven release, copy the 0.92.2 tag to 0.92.2mvn. Check out this tag and change the version therein and commit.</p>
            <p>Currently, the mvn release wants to go against trunk. I haven't figured how to tell it to do otherwise so I do the below hack. The hack comprises answering the questions put to you by the mvn release plugin properly, then immediately control-C'ing the build after the last question asked as the build release step starts to run. After control-C'ing it, You'll notice a release.properties in your build dir. Review it. Make sure it is using the proper branch -- it tends to use trunk rather than the 0.92.2mvn or whatever that you want it to use -- so hand edit the release.properties file that was put under ${HBASE_HOME} by the <strong>release:perform</strong> invocation. When done, resstart the <strong>release:perform</strong>.</p>
            <p>Here is how I'd answer the questions at <strong>release:prepare</strong> time:</p>
            <pre>What is the release version for "HBase"? (org.apache.hbase:hbase) 0.92.2: :  What is SCM release tag or label for "HBase"? (org.apache.hbase:hbase) hbase-0.92.2: : 0.92.2mvn  What is the new development version for "HBase"? (org.apache.hbase:hbase) 0.92.3-SNAPSHOT: :  [INFO] Transforming 'HBase'...</pre>
            <p>When you run <strong>release:perform</strong>, pass <strong>-Papache-release</strong> else it will not 'sign' the artifacts it uploads.</p>
            <p>A strange issue I ran into was the one where the upload into the apache repository was being sprayed across multiple apache machines making it so I could not release. See<a href="https://issues.apache.org/jira/browse/INFRA-4482" target="_top">INFRA-4482 Why is my upload to mvn spread across multiple repositories?</a>.</p>
            <p><a name="mvn.settings.file"></a>Here is my ~/.m2/settings.xml. This is read by the release plugin. The apache-release profile will pick up your gpg key setup from here if you've specified it into the file. The password can be maven encrypted as suggested in the "Publishing Maven Artifacts" but plain text password works too (just don't let anyone see your local settings.xml).</p>
            <pre>&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0                        http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;    &lt;servers&gt;      &lt;!- To publish a snapshot of some part of Maven --&gt;      &lt;server&gt;        &lt;id&gt;apache.snapshots.https&lt;/id&gt;        &lt;username&gt;YOUR_APACHE_ID        &lt;/username&gt;        &lt;password&gt;YOUR_APACHE_PASSWORD        &lt;/password&gt;      &lt;/server&gt;      &lt;!-- To publish a website using Maven --&gt;      &lt;!-- To stage a release of some part of Maven --&gt;      &lt;server&gt;        &lt;id&gt;apache.releases.https&lt;/id&gt;        &lt;username&gt;YOUR_APACHE_ID        &lt;/username&gt;        &lt;password&gt;YOUR_APACHE_PASSWORD        &lt;/password&gt;      &lt;/server&gt;    &lt;/servers&gt;    &lt;profiles&gt;      &lt;profile&gt;        &lt;id&gt;apache-release&lt;/id&gt;        &lt;properties&gt;      &lt;gpg.keyname&gt;YOUR_KEYNAME&lt;/gpg.keyname&gt;      &lt;!--Keyname is something like this ... 00A5F21E... do gpg --list-keys to find it--&gt;      &lt;gpg.passphrase&gt;YOUR_KEY_PASSWORD      &lt;/gpg.passphrase&gt;        &lt;/properties&gt;      &lt;/profile&gt;    &lt;/profiles&gt;  &lt;/settings&gt;          </pre>
            <p>If you see run into the below, its because you need to edit version in the pom.xml and add -SNAPSHOT to the version (and commit).</p>
            <pre>[INFO] Scanning for projects...  [INFO] Searching repository for plugin with prefix: 'release'.  [INFO] ------------------------------------------------------------------------  [INFO] Building HBase  [INFO]    task-segment: [release:prepare] (aggregator-style)  [INFO] ------------------------------------------------------------------------  [INFO] [release:prepare {execution: default-cli}]  [INFO] ------------------------------------------------------------------------  [ERROR] BUILD FAILURE  [INFO] ------------------------------------------------------------------------  [INFO] You don't have a SNAPSHOT project in the reactor projects list.  [INFO] ------------------------------------------------------------------------  [INFO] For more information, run Maven with the -e switch  [INFO] ------------------------------------------------------------------------  [INFO] Total time: 3 seconds  [INFO] Finished at: Sat Mar 26 18:11:07 PDT 2011  [INFO] Final Memory: 35M/423M  [INFO] -----------------------------------------------------------------------</pre>
          </div>
          <div title="15.5. Generating the HBase Reference Guide">
          <div>
          <div>
          <div>
          <br>
        </div></div>
           
           <div class="section" title="15.4.&nbsp;Publishing a new version of hbase.apache.org"><div class="titlepage"><div><div></div></div></div>
             <div>
               <div>
        <div>
          <h2>15.5. Generating the HBase Reference Guide</h2>
        </div>
      </div>
  </div>
    <p>The manual is marked up using <a href="http://www.docbook.org/" target="_top">docbook</a>. We then use the <a href="http://code.google.com/p/docbkx-tools/" target="_top">docbkx maven plugin</a> to transform the markup to html. This plugin is run when you specify the <strong>site</strong> goal as in when you run <strong>mvn site</strong> or you can call the plugin explicitly to just generate the manual by doing <strong>mvn docbkx:generate-html</strong> (TODO: It looks like you have to run <strong>mvn site</strong>first because docbkx wants to include a transformed hbase-default.xml. Fix). When you run mvn site, we do the document generation twice, once to generate the multipage manual and then again for the single page manual (the single page version is easier to search).</p>
    <div>
      <div>
        <div>
          <h2>15.6. Updating hbase.apache.org</h2>
        </div>
      </div>
    </div>
    <div title="15.6.1. Contributing to hbase.apache.org">
      <div>
        <div>
          <div>
            <h3><a name="hbase.org.site.contributing"></a>15.6.1. Contributing to hbase.apache.org</h3>
          </div>
        </div>
      </div>
      <p>The Apache HBase apache web site (including this reference guide) is maintained as part of the main Apache HBase source tree, under /src/main/docbkx and /src/main/site [<a name="d2520e10462" href="#ftn.d2520e10462">30</a>]. The former -- docbkx -- is this reference guide as a bunch of xml marked up using <a href="http://docbook.org/" target="_top">docbook</a>; the latter is the hbase site (the navbars, the header, the layout, etc.), and some of the documentation, legacy pages mostly that are in the process of being merged into the docbkx tree that is converted to html by a maven plugin by the site build.</p>
      <p>To contribute to the reference guide, edit these files under site or docbkx and submit them as a patch (see <a href="#submitting.patches" title="15.11. Submitting Patches">Section 15.11, &ldquo;Submitting Patches&rdquo;</a>). Your Jira should contain a summary of the changes in each section (see <a href="https://issues.apache.org/jira/browse/HBASE-6081" target="_top">HBASE-6081</a> for an example).</p>
      <p>To generate the site locally while you're working on it, run:</p>
      <pre>mvn site</pre>
      <p>Then you can load up the generated HTML files in your browser (file are under /target/site).</p>
    </div>
    <div title="15.6.2. Publishing hbase.apache.org">
      <div>
        <div>
          <div>
            <h3><a name="hbase.org.site.publishing"></a>15.6.2. Publishing hbase.apache.org</h3>
          </div>
        </div>
      </div>
      <p>As of <a href="https://issues.apache.org/jira/browse/INFRA-5680" target="_top">INFRA-5680 Migrate apache hbase website</a>, to publish the website, build it, and then deploy it over a checkout ofhttps://svn.apache.org/repos/asf/hbase/hbase.apache.org/trunk. Finally, check it in. For example, if trunk is checked out out at /Users/stack/checkouts/trunk and the hbase website, hbase.apache.org, is checked out at /Users/stack/checkouts/hbase.apache.org/trunk, to update the site, do the following:</p>
      <pre>              # Build the site and deploy it to the checked out directory                # Getting the javadoc into site is a little tricky.  You have to build it before you invoke 'site'.                $ MAVEN_OPTS=" -Xmx3g" mvn clean install -DskipTests javadoc:aggregate site  site:stage -DstagingDirectory=/Users/stack/checkouts/hbase.apache.org/trunk            </pre>
      <p>Now check the deployed site by viewing in a brower, browse to file:////Users/stack/checkouts/hbase.apache.org/trunk/index.html and check all is good. If all checks out, commit it and your new build will show up immediately at http://hbase.apache.org</p>
      <pre>              $ cd /Users/stack/checkouts/hbase.apache.org/trunk                $ svn status                # Do an svn add of any new content...                $ svn add ....                $ svn commit -m 'Committing latest version of website...'    </pre>
    </div>
           </div>
    
    <div class="section" title="15.5.&nbsp;Tests"><div class="titlepage"><div><div>
      <h2 class="title" style="clear: both"><a name="hbase.tests"></a>15.7.&nbsp;测试</h2></div></div></div><p> Developers, at a minimum, should familiarize themselves with the unit test detail; unit tests in
HBase have a character not usually seen in other projects.</p><div class="section" title="15.5.1.&nbsp;HBase Modules"><div class="titlepage"><div><div>
  <h3 class="title"><a name="hbase.moduletests"></a>15.7.1.&nbsp;HBase 模块</h3></div></div></div><p>As of 0.96, HBase is split into multiple modules which creates "interesting" rules for
how and where tests are written. If you are writting code for <code class="classname">hbase-server</code>, see
<a class="xref" href="#hbase.unittests" title="15.5.2.&nbsp;Unit Tests">Section&nbsp;15.7.2, “Unit Tests”</a> for how to write your tests; these tests can spin
up a minicluster and will need to be categorized. For any other module, for example
<code class="classname">hbase-common</code>, the tests must be strict unit tests and just test the class
under test - no use of the HBaseTestingUtility or minicluster is allowed (or even possible
given the dependency tree).</p><div class="section" title="15.5.1.1.&nbsp;Running Tests in other Modules"><div class="titlepage"><div><div>
  <h4 class="title"><a name="hbase.moduletest.run"></a>15.7.1.1.&nbsp;在其他模块中运行测试</h4></div></div></div>
  If the module you are developing in has no other dependencies on other HBase modules, then
  you can cd into that module and just run:
  <pre class="programlisting">mvn test</pre>
  which will just run the tests IN THAT MODULE. If there are other dependencies on other modules,
  then you will have run the command from the ROOT HBASE DIRECTORY. This will run the tests in the other
  modules, unless you specify to skip the tests in that module. For instance, to skip the tests in the hbase-server module,
  you would run:
  <pre class="programlisting">mvn clean test -Dskip-server-tests</pre>
  from the top level directory to run all the tests in modules other than hbase-server. Note that you
  can specify to skip tests in multiple modules as well as just for a single module. For example, to skip
  the tests in <code class="classname">hbase-server</code> and <code class="classname">hbase-common</code>, you would run:
  <pre class="programlisting">mvn clean test -Dskip-server-tests -Dskip-common-tests</pre><p>Also, keep in mind that if you are running tests in the <code class="classname">hbase-server</code> module you will need to 
  apply the maven profiles discussed in <a class="xref" href="#hbase.unittests.cmds" title="15.5.2.4.&nbsp;Running tests">Section&nbsp;15.7.2.4, “Running tests”</a> to get the tests to run properly.</p></div></div><div class="section" title="15.5.2.&nbsp;Unit Tests"><div class="titlepage"><div><div>
    <h3 class="title"><a name="hbase.unittests"></a>15.7.2.&nbsp;单元测试</h3></div></div></div>
    <div title="15.7. Tests">
      <div>
        <div>
          <div></div>
        </div>
      </div>
      <div title="15.7.1. Apache HBase Modules"> </div>
      <div title="15.7.2. Unit Tests">
        <div>
          <div>
            <div></div>
          </div>
        </div>
        <p>Apache HBase unit tests are subdivided into four categories: small, medium, large, and integration with corresponding JUnit <a href="http://www.junit.org/node/581" target="_top">categories</a>: SmallTests, MediumTests, LargeTests,IntegrationTests. JUnit categories are denoted using java annotations and look like this in your unit test code.</p>
        <pre>...  @Category(SmallTests.class)  public class TestHRegionInfo {    @Test    public void testCreateHRegionInfoName() throws Exception {      // ...    }  }</pre>
        <p>The above example shows how to mark a unit test as belonging to the small category. All unit tests in HBase have a categorization.</p>
        <p>The first three categories, small, medium, and large are for tests run when you type $ mvn test; i.e. these three categorizations are for HBase unit tests. The integration category is for not for unit tests but for integration tests. These are run when you invoke $ mvn verify. Integration tests are described in <a href="#integration.tests" title="15.7.5. Integration Tests">Section 15.7.5, &ldquo;Integration Tests&rdquo;</a> and will not be discussed further in this section on HBase unit tests.</p>
        <p>Apache HBase uses a patched maven surefire plugin and maven profiles to implement its unit test characterizations.</p>
        <p>Read the below to figure which annotation of the set small, medium, and large to put on your new HBase unit test.</p>
        <div title="15.7.2.1. Small Tests">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.small"></a>15.7.2.1. Small Tests<a name="d2520e10591"></a></h4>
              </div>
            </div>
          </div>
          <p><em>Small</em> tests are executed in a shared JVM. We put in this category all the tests that can be executed quickly in a shared JVM. The maximum execution time for a small test is 15 seconds, and small tests should not use a (mini)cluster.</p>
        </div>
        <div title="15.7.2.2. Medium Tests">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.medium"></a>15.7.2.2. Medium Tests<a name="d2520e10602"></a></h4>
              </div>
            </div>
          </div>
          <p><em>Medium</em> tests represent tests that must be executed before proposing a patch. They are designed to run in less than 30 minutes altogether, and are quite stable in their results. They are designed to last less than 50 seconds individually. They can use a cluster, and each of them is executed in a separate JVM.</p>
        </div>
        <div title="15.7.2.3. Large Tests">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.large"></a>15.7.2.3. Large Tests<a name="d2520e10612"></a></h4>
              </div>
            </div>
          </div>
          <p><em>Large</em> tests are everything else. They are typically large-scale tests, regression tests for specific bugs, timeout tests, performance tests. They are executed before a commit on the pre-integration machines. They can be run on the developer machine as well.</p>
        </div>
        <div title="15.7.2.4. Integration Tests">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.integration"></a>15.7.2.4. Integration Tests<a name="d2520e10622"></a></h4>
              </div>
            </div>
          </div>
          <p><em>Integration</em> tests are system level tests. See <a href="#integration.tests" title="15.7.5. Integration Tests">Section 15.7.5, &ldquo;Integration Tests&rdquo;</a> for more info.</p>
        </div>
      </div>
      <div title="15.7.3. Running tests">
        <div>
          <div>
            <div>
              <h3><a name="hbase.unittests.cmds"></a>15.7.3. Running tests</h3>
            </div>
          </div>
        </div>
        <p>Below we describe how to run the Apache HBase junit categories.</p>
        <div title="15.7.3.1. Default: small and medium category tests">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.cmds.test"></a>15.7.3.1. Default: small and medium category tests</h4>
              </div>
            </div>
          </div>
          <p>Running</p>
          <pre>mvn test</pre>
          <p>will execute all small tests in a single JVM (no fork) and then medium tests in a separate JVM for each test instance. Medium tests are NOT executed if there is an error in a small test. Large tests are NOT executed. There is one report for small tests, and one report for medium tests if they are executed.</p>
        </div>
        <div title="15.7.3.2. Running all tests">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.cmds.test.runAllTests"></a>15.7.3.2. Running all tests</h4>
              </div>
            </div>
          </div>
          <p>Running</p>
          <pre>mvn test -P runAllTests</pre>
          <p>will execute small tests in a single JVM then medium and large tests in a separate JVM for each test. Medium and large tests are NOT executed if there is an error in a small test. Large tests are NOT executed if there is an error in a small or medium test. There is one report for small tests, and one report for medium and large tests if they are executed.</p>
        </div>
        <div title="15.7.3.3. Running a single test or all tests in a package">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.cmds.test.localtests.mytest"></a>15.7.3.3. Running a single test or all tests in a package</h4>
              </div>
            </div>
          </div>
          <p>To run an individual test, e.g. MyTest, do</p>
          <pre>mvn test -Dtest=MyTest</pre>
          <p>You can also pass multiple, individual tests as a comma-delimited list:</p>
          <pre>mvn test -Dtest=MyTest1,MyTest2,MyTest3</pre>
          <p>You can also pass a package, which will run all tests under the package:</p>
          <pre>mvn test -Dtest=org.apache.hadoop.hbase.client.*</pre>
          <p>When -Dtest is specified, localTests profile will be used. It will use the official release of maven surefire, rather than our custom surefire plugin, and the old connector (The HBase build uses a patched version of the maven surefire plugin). Each junit tests is executed in a separate JVM (A fork per test class). There is no parallelization when tests are running in this mode. You will see a new message at the end of the -report: "[INFO] Tests are skipped". It's harmless. While you need to make sure the sum of Tests run: in the Results : section of test reports matching the number of tests you specified because no error will be reported when a non-existent test case is specified.</p>
        </div>
        <div title="15.7.3.4. Other test invocation permutations">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.cmds.test.profiles"></a>15.7.3.4. Other test invocation permutations</h4>
              </div>
            </div>
          </div>
          <p>Running</p>
          <pre>mvn test -P runSmallTests</pre>
          <p>will execute "small" tests only, using a single JVM.</p>
          <p>Running</p>
          <pre>mvn test -P runMediumTests</pre>
          <p>will execute "medium" tests only, launching a new JVM for each test-class.</p>
          <p>Running</p>
          <pre>mvn test -P runLargeTests</pre>
          <p>will execute "large" tests only, launching a new JVM for each test-class.</p>
          <p>For convenience, you can run</p>
          <pre>mvn test -P runDevTests</pre>
          <p>to execute both small and medium tests, using a single JVM.</p>
        </div>
        <div title="15.7.3.5. Running tests faster">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.test.faster"></a>15.7.3.5. Running tests faster</h4>
              </div>
            </div>
          </div>
          <p>By default, $ mvn test -P runAllTests runs 5 tests in parallel. It can be increased on a developer's machine. Allowing that you can have 2 tests in parallel per core, and you need about 2Gb of memory per test (at the extreme), if you have an 8 core, 24Gb box, you can have 16 tests in parallel. but the memory available limits it to 12 (24/2), To run all tests with 12 tests in parallell, do this: <strong>mvn test -P runAllTests -Dsurefire.secondPartThreadCount=12</strong>. To increase the speed, you can as well use a ramdisk. You will need 2Gb of memory to run all tests. You will also need to delete the files between two test run. The typical way to configure a ramdisk on Linux is:</p>
          <pre>$ sudo mkdir /ram2G  sudo mount -t tmpfs -o size=2048M tmpfs /ram2G</pre>
          <p>You can then use it to run all HBase tests with the command: <strong>mvn test -P runAllTests -Dsurefire.secondPartThreadCount=12 -Dtest.build.data.basedirectory=/ram2G</strong></p>
        </div>
        <div title="15.7.3.6. hbasetests.sh">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.cmds.test.hbasetests"></a>15.7.3.6. <strong>hbasetests.sh</strong></h4>
              </div>
            </div>
          </div>
          <p>It's also possible to use the script <strong>hbasetests.sh</strong>. This script runs the medium and large tests in parallel with two maven instances, and provides a single report. This script does not use the hbase version of surefire so no parallelization is being done other than the two maven instances the script sets up. It must be executed from the directory which contains the pom.xml.</p>
          <p>For example running</p>
          <pre>./dev-support/hbasetests.sh</pre>
          <p>will execute small and medium tests. Running</p>
          <pre>./dev-support/hbasetests.sh runAllTests</pre>
          <p>will execute all tests. Running</p>
          <pre>./dev-support/hbasetests.sh replayFailed</pre>
          <p>will rerun the failed tests a second time, in a separate jvm and without parallelisation.</p>
        </div>
        <div title="15.7.3.7. Test Resource Checker">
          <div>
            <div>
              <div>
                <h4><a name="hbase.unittests.resource.checker"></a>15.7.3.7. Test Resource Checker<a name="d2520e10750"></a></h4>
              </div>
            </div>
          </div>
          <p>A custom Maven SureFire plugin listener checks a number of resources before and after each HBase unit test runs and logs its findings at the end of the test output files which can be found in target/surefire-reports per Maven module (Tests write test reports named for the test class into this directory. Check the *-out.txt files). The resources counted are the number of threads, the number of file descriptors, etc. If the number has increased, it adds a <em>LEAK?</em> comment in the logs. As you can have an HBase instance running in the background, some threads can be deleted/created without any specific action in the test. However, if the test does not work as expected, or if the test should not impact these resources, it's worth checking these log lines ...hbase.ResourceChecker(157): before... and ...hbase.ResourceChecker(157): after.... For example: 2012-09-26 09:22:15,315 INFO [pool-1-thread-1] hbase.ResourceChecker(157): after: regionserver.TestColumnSeeking#testReseeking Thread=65 (was 65), OpenFileDescriptor=107 (was 107), MaxFileDescriptor=10240 (was 10240), ConnectionCount=1 (was 1)</p>
        </div>
      </div>
      <div title="15.7.4. Writing Tests">
        <div>
          <div>
            <div>
              <h3><a name="hbase.tests.writing"></a>15.7.4. Writing Tests</h3>
            </div>
          </div>
        </div>
        <div title="15.7.4.1. General rules">
          <div>
            <div>
              <div>
                <h4><a name="hbase.tests.rules"></a>15.7.4.1. General rules</h4>
              </div>
            </div>
          </div>
          <div>
            <ul type="disc">
              <li>As much as possible, tests should be written as category small tests.</li>
              <li>All tests must be written to support parallel execution on the same machine, hence they should not use shared resources as fixed ports or fixed file names.</li>
              <li>Tests should not overlog. More than 100 lines/second makes the logs complex to read and use i/o that are hence not available for the other tests.</li>
              <li>Tests can be written with HBaseTestingUtility. This class offers helper functions to create a temp directory and do the cleanup, or to start a cluster.</li>
            </ul>
          </div>
        </div>
        <div title="15.7.4.2. Categories and execution time">
          <div>
            <div>
              <div>
                <h4><a name="hbase.tests.categories"></a>15.7.4.2. Categories and execution time</h4>
              </div>
            </div>
          </div>
          <div>
            <ul type="disc">
              <li>All tests must be categorized, if not they could be skipped.</li>
              <li>All tests should be written to be as fast as possible.</li>
              <li>Small category tests should last less than 15 seconds, and must not have any side effect.</li>
              <li>Medium category tests should last less than 50 seconds.</li>
              <li>Large category tests should last less than 3 minutes. This should ensure a good parallelization for people using it, and ease the analysis when the test fails.</li>
            </ul>
          </div>
        </div>
        <div title="15.7.4.3. Sleeps in tests">
          <div>
            <div>
              <div>
                <h4><a name="hbase.tests.sleeps"></a>15.7.4.3. Sleeps in tests</h4>
              </div>
            </div>
          </div>
          <p>Whenever possible, tests should not use Thread.sleep, but rather waiting for the real event they need. This is faster and clearer for the reader. Tests should not do aThread.sleep without testing an ending condition. This allows understanding what the test is waiting for. Moreover, the test will work whatever the machine performance is. Sleep should be minimal to be as fast as possible. Waiting for a variable should be done in a 40ms sleep loop. Waiting for a socket operation should be done in a 200 ms sleep loop.</p>
        </div>
        <div title="15.7.4.4. Tests using a cluster">
          <div>
            <div>
              <div>
                <h4><a name="hbase.tests.cluster"></a>15.7.4.4. Tests using a cluster</h4>
              </div>
            </div>
          </div>
          <p>Tests using a HRegion do not have to start a cluster: A region can use the local file system. Start/stopping a cluster cost around 10 seconds. They should not be started per test method but per test class. Started cluster must be shutdown using HBaseTestingUtility#shutdownMiniCluster, which cleans the directories. As most as possible, tests should use the default settings for the cluster. When they don't, they should document it. This will allow to share the cluster later.</p>
        </div>
      </div>
      <div title="15.7.5. Integration Tests">
        <div>
          <div>
            <div>
              <h3><a name="integration.tests"></a>15.7.5. Integration Tests</h3>
            </div>
          </div>
        </div>
        <p>HBase integration/system tests are tests that are beyond HBase unit tests. They are generally long-lasting, sizeable (the test can be asked to 1M rows or 1B rows), targetable (they can take configuration that will point them at the ready-made cluster they are to run against; integration tests do not include cluster start/stop code), and verifying success, integration tests rely on public APIs only; they do not attempt to examine server internals asserting success/fail. Integration tests are what you would run when you need to more elaborate proofing of a release candidate beyond what unit tests can do. They are not generally run on the Apache Continuous Integration build server, however, some sites opt to run integration tests as a part of their continuous testing on an actual cluster.</p>
        <p>Integration tests currently live under the src/test directory in the hbase-it submodule and will match the regex: **/IntegrationTest*.java. All integration tests are also annotated with @Category(IntegrationTests.class).</p>
        <p>Integration tests can be run in two modes: using a mini cluster, or against an actual distributed cluster. Maven failsafe is used to run the tests using the mini cluster. IntegrationTestsDriver class is used for executing the tests against a distributed cluster. Integration tests SHOULD NOT assume that they are running against a mini cluster, and SHOULD NOT use private API's to access cluster state. To interact with the distributed or mini cluster uniformly, IntegrationTestingUtility, and HBaseClusterclasses, and public client API's can be used.</p>
        <div title="15.7.5.1. Running integration tests against mini cluster">
          <div>
            <div>
              <div>
                <h4><a name="maven.build.commands.integration.tests.mini"></a>15.7.5.1. Running integration tests against mini cluster</h4>
              </div>
            </div>
          </div>
          <p>HBase 0.92 added a verify maven target. Invoking it, for example by doing mvn verify, will run all the phases up to and including the verify phase via the maven <a href="http://maven.apache.org/plugins/maven-failsafe-plugin/" target="_top">failsafe plugin</a>, running all the above mentioned HBase unit tests as well as tests that are in the HBase integration test group. After you have completed</p>
          <pre>mvn install -DskipTests</pre>
          <p>You can run just the integration tests by invoking:</p>
          <pre>cd hbase-it  mvn verify</pre>
          <p>If you just want to run the integration tests in top-level, you need to run two commands. First:</p>
          <pre>mvn failsafe:integration-test</pre>
          <p>This actually runs ALL the integration tests.</p>
          <div title="Note">
            <h3>Note</h3>
            <p>This command will always output BUILD SUCCESS even if there are test failures.</p>
          </div>
          <p>At this point, you could grep the output by hand looking for failed tests. However, maven will do this for us; just use:</p>
          <pre>mvn failsafe:verify</pre>
          <p>The above command basically looks at all the test results (so don't remove the 'target' directory) for test failures and reports the results.</p>
          <div title="15.7.5.1.1. Running a subset of Integration tests">
            <div>
              <div>
                <div>
                  <h5><a name="maven.build.commanas.integration.tests2"></a>15.7.5.1.1. Running a subset of Integration tests</h5>
                </div>
              </div>
            </div>
            <p>This is very similar to how you specify running a subset of unit tests (see above), but use the property it.test instead of test. To just run IntegrationTestClassXYZ.java, use:</p>
            <pre>mvn failsafe:integration-test -Dit.test=IntegrationTestClassXYZ</pre>
            <p>The next thing you might want to do is run groups of integration tests, say all integration tests that are named IntegrationTestClassX*.java:</p>
            <pre>mvn failsafe:integration-test -Dit.test=*ClassX*</pre>
            <p>This runs everything that is an integration test that matches *ClassX*. This means anything matching: "**/IntegrationTest*ClassX*". You can also run multiple groups of integration tests using comma-delimited lists (similar to unit tests). Using a list of matches still supports full regex matching for each of the groups.This would look something like:</p>
            <pre>mvn failsafe:integration-test -Dit.test=*ClassX*, *ClassY</pre>
          </div>
        </div>
        <div title="15.7.5.2. Running integration tests against distributed cluster">
          <div>
            <div>
              <div>
                <h4><a name="maven.build.commands.integration.tests.distributed"></a>15.7.5.2. Running integration tests against distributed cluster</h4>
              </div>
            </div>
          </div>
          <p>If you have an already-setup HBase cluster, you can launch the integration tests by invoking the class IntegrationTestsDriver. You may have to run test-compile first. The configuration will be picked by the bin/hbase script.</p>
          <pre>mvn test-compile</pre>
          <p>Then launch the tests with:</p>
          <pre>bin/hbase [--config config_dir] org.apache.hadoop.hbase.IntegrationTestsDriver [-test=class_regex]</pre>
          <p>This execution will launch the tests under hbase-it/src/test, having @Category(IntegrationTests.class) annotation, and a name starting with IntegrationTests. If specified, class_regex will be used to filter test classes. The regex is checked against full class name; so, part of class name can be used. IntegrationTestsDriver uses Junit to run the tests. Currently there is no support for running integration tests against a distributed cluster using maven (see <a href="https://issues.apache.org/jira/browse/HBASE-6201" target="_top">HBASE-6201</a>).</p>
          <p>The tests interact with the distributed cluster by using the methods in the DistributedHBaseCluster (implementing HBaseCluster) class, which in turn uses a pluggableClusterManager. Concrete implementations provide actual functionality for carrying out deployment-specific and environment-dependent tasks (SSH, etc). The defaultClusterManager is HBaseClusterManager, which uses SSH to remotely execute start/stop/kill/signal commands, and assumes some posix commands (ps, etc). Also assumes the user running the test has enough "power" to start/stop servers on the remote machines. By default, it picks up HBASE_SSH_OPTS, HBASE_HOME, HBASE_CONF_DIR from the env, and usesbin/hbase-daemon.sh to carry out the actions. Currently tarball deployments, deployments which uses hbase-daemons.sh, and <a href="http://incubator.apache.org/ambari/" target="_top">Apache Ambari</a> deployments are supported. /etc/init.d/ scripts are not supported for now, but it can be easily added. For other deployment options, a ClusterManager can be implemented and plugged in.</p>
        </div>
        <div title="15.7.5.3. Destructive integration / system tests">
          <div>
            <div>
              <div>
                <h4><a name="maven.build.commands.integration.tests.destructive"></a>15.7.5.3. Destructive integration / system tests</h4>
              </div>
            </div>
          </div>
          <p>In 0.96, a tool named ChaosMonkey has been introduced. It is modeled after the <a href="http://techblog.netflix.com/2012/07/chaos-monkey-released-into-wild.html" target="_top">same-named tool by Netflix</a>. Some of the tests use ChaosMonkey to simulate faults in the running cluster in the way of killing random servers, disconnecting servers, etc. ChaosMonkey can also be used as a stand-alone tool to run a (misbehaving) policy while you are running other tests.</p>
          <p>ChaosMonkey defines Action's and Policy's. Actions are sequences of events. We have at least the following actions:</p>
          <div>
            <ul type="disc">
              <li>Restart active master (sleep 5 sec)</li>
              <li>Restart random regionserver (sleep 5 sec)</li>
              <li>Restart random regionserver (sleep 60 sec)</li>
              <li>Restart META regionserver (sleep 5 sec)</li>
              <li>Restart ROOT regionserver (sleep 5 sec)</li>
              <li>Batch restart of 50% of regionservers (sleep 5 sec)</li>
              <li>Rolling restart of 100% of regionservers (sleep 5 sec)</li>
            </ul>
          </div>
          <p>Policies on the other hand are responsible for executing the actions based on a strategy. The default policy is to execute a random action every minute based on predefined action weights. ChaosMonkey executes predefined named policies until it is stopped. More than one policy can be active at any time.</p>
          <p>To run ChaosMonkey as a standalone tool deploy your HBase cluster as usual. ChaosMonkey uses the configuration from the bin/hbase script, thus no extra configuration needs to be done. You can invoke the ChaosMonkey by running:</p>
          <pre>bin/hbase org.apache.hadoop.hbase.util.ChaosMonkey</pre>
          <p>This will output smt like:</p>
          <pre>12/11/19 23:21:57 INFO util.ChaosMonkey: Using ChaosMonkey Policy: class org.apache.hadoop.hbase.util.ChaosMonkey$PeriodicRandomActionPolicy, period:60000  12/11/19 23:21:57 INFO util.ChaosMonkey: Sleeping for 26953 to add jitter  12/11/19 23:22:24 INFO util.ChaosMonkey: Performing action: Restart active master  12/11/19 23:22:24 INFO util.ChaosMonkey: Killing master:master.example.com,60000,1353367210440  12/11/19 23:22:24 INFO hbase.HBaseCluster: Aborting Master: master.example.com,60000,1353367210440  12/11/19 23:22:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:master.example.com  12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:  12/11/19 23:22:25 INFO hbase.HBaseCluster: Waiting service:master to stop: master.example.com,60000,1353367210440  12/11/19 23:22:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:master.example.com  12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:  12/11/19 23:22:25 INFO util.ChaosMonkey: Killed master server:master.example.com,60000,1353367210440  12/11/19 23:22:25 INFO util.ChaosMonkey: Sleeping for:5000  12/11/19 23:22:30 INFO util.ChaosMonkey: Starting master:master.example.com  12/11/19 23:22:30 INFO hbase.HBaseCluster: Starting Master on: master.example.com  12/11/19 23:22:30 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start master , hostname:master.example.com  12/11/19 23:22:31 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting master, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-master-master.example.com.out  ....  12/11/19 23:22:33 INFO util.ChaosMonkey: Started master: master.example.com,60000,1353367210440  12/11/19 23:22:33 INFO util.ChaosMonkey: Sleeping for:51321  12/11/19 23:23:24 INFO util.ChaosMonkey: Performing action: Restart random region server  12/11/19 23:23:24 INFO util.ChaosMonkey: Killing region server:rs3.example.com,60020,1353367027826  12/11/19 23:23:24 INFO hbase.HBaseCluster: Aborting RS: rs3.example.com,60020,1353367027826  12/11/19 23:23:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:rs3.example.com  12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:  12/11/19 23:23:25 INFO hbase.HBaseCluster: Waiting service:regionserver to stop: rs3.example.com,60020,1353367027826  12/11/19 23:23:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:rs3.example.com  12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:  12/11/19 23:23:25 INFO util.ChaosMonkey: Killed region server:rs3.example.com,60020,1353367027826. Reported num of rs:6  12/11/19 23:23:25 INFO util.ChaosMonkey: Sleeping for:60000  12/11/19 23:24:25 INFO util.ChaosMonkey: Starting region server:rs3.example.com  12/11/19 23:24:25 INFO hbase.HBaseCluster: Starting RS on: rs3.example.com  12/11/19 23:24:25 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start regionserver , hostname:rs3.example.com  12/11/19 23:24:26 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting regionserver, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-regionserver-rs3.example.com.out    12/11/19 23:24:27 INFO util.ChaosMonkey: Started region server:rs3.example.com,60020,1353367027826. Reported num of rs:6  </pre>
          <p>As you can see from the log, ChaosMonkey started the default PeriodicRandomActionPolicy, which is configured with all the available actions, and ran RestartActiveMaster and RestartRandomRs actions. ChaosMonkey tool, if run from command line, will keep on running until the process is killed.</p>
        </div>
      </div>
    </div>
    <div title="15.8. Maven Build Commands">
      <div>
        <div>
          <div>
            <h2><a name="maven.build.commands"></a>15.8. Maven Build Commands</h2>
          </div>
        </div>
      </div>
      <p>All commands executed from the local HBase project directory.</p>
      <p>Note: use Maven 3 (Maven 2 may work but we suggest you use Maven 3).</p>
      <div title="15.8.1. Compile">
        <div>
          <div>
            <div>
              <h3><a name="maven.build.commands.compile"></a>15.8.1. Compile</h3>
            </div>
          </div>
        </div>
        <pre>mvn compile            </pre>
      </div>
      <div title="15.8.2. Running all or individual Unit Tests">
        <div>
          <div>
            <div>
              <h3><a name="maven.build.commands.unitall"></a>15.8.2. Running all or individual Unit Tests</h3>
            </div>
          </div>
        </div>
        <p>See the <a href="#hbase.unittests.cmds" title="15.7.3. Running tests">Section 15.7.3, &ldquo;Running tests&rdquo;</a> section above in <a href="#hbase.unittests" title="15.7.2. Unit Tests">Section 15.7.2, &ldquo;Unit Tests&rdquo;</a></p>
      </div>
      <div title="15.8.3. Building against various hadoop versions.">
        <div>
          <div>
            <div>
              <h3><a name="maven.build.hadoop"></a>15.8.3. Building against various hadoop versions.</h3>
            </div>
          </div>
        </div>
        <p>As of 0.96, Apache HBase supports building against Apache Hadoop versions: 1.0.3, 2.0.0-alpha and 3.0.0-SNAPSHOT. By default, we will build with Hadoop-1.0.3. To change the version to run with Hadoop-2.0.0-alpha, you would run:</p>
        <pre>mvn -Dhadoop.profile=2.0 ...</pre>
        <p>That is, designate build with hadoop.profile 2.0. Pass 2.0 for hadoop.profile to build against hadoop 2.0. Tests may not all pass as of this writing so you may need to pass -DskipTests unless you are inclined to fix the failing tests.</p>
        <p>Similarly, for 3.0, you would just replace the profile value. Note that Hadoop-3.0.0-SNAPSHOT does not currently have a deployed maven artificat - you will need to build and install your own in your local maven repository if you want to run against this profile.</p>
        <p>In earilier verions of Apache HBase, you can build against older versions of Apache Hadoop, notably, Hadoop 0.22.x and 0.23.x. If you are running, for example HBase-0.94 and wanted to build against Hadoop 0.23.x, you would run with:</p>
        <pre>mvn -Dhadoop.profile=22 ...</pre>
      </div>
    </div>
    <div title="15.9. Getting Involved">
      <div>
        <div>
          <div>
            <h2><a name="getting.involved"></a>15.9. Getting Involved</h2>
          </div>
        </div>
      </div>
      <p>Apache HBase gets better only when people contribute!</p>
      <p>As Apache HBase is an Apache Software Foundation project, see <a href="#asf" title="Appendix H. HBase and the Apache Software Foundation">Appendix H, <em>HBase and the Apache Software Foundation</em></a> for more information about how the ASF functions.</p>
      <div title="15.9.1. Mailing Lists">
        <div>
          <div>
            <div>
              <h3><a name="mailing.list"></a>15.9.1. Mailing Lists</h3>
            </div>
          </div>
        </div>
        <p>Sign up for the dev-list and the user-list. See the <a href="http://hbase.apache.org/mail-lists.html" target="_top">mailing lists</a> page. Posing questions - and helping to answer other people's questions - is encouraged! There are varying levels of experience on both lists so patience and politeness are encouraged (and please stay on topic.)</p>
      </div>
      <div title="15.9.2. Jira">
        <div>
          <div>
            <div>
              <h3><a name="jira"></a>15.9.2. Jira</h3>
            </div>
          </div>
        </div>
        <p>Check for existing issues in <a href="https://issues.apache.org/jira/browse/HBASE" target="_top">Jira</a>. If it's either a new feature request, enhancement, or a bug, file a ticket.</p>
        <div title="15.9.2.1. Jira Priorities">
          <div>
            <div>
              <div>
                <h4><a name="jira.priorities"></a>15.9.2.1. Jira Priorities</h4>
              </div>
            </div>
          </div>
          <p>The following is a guideline on setting Jira issue priorities:</p>
          <div>
            <ul type="disc">
              <li>Blocker: Should only be used if the issue WILL cause data loss or cluster instability reliably.</li>
              <li>Critical: The issue described can cause data loss or cluster instability in some cases.</li>
              <li>Major: Important but not tragic issues, like updates to the client API that will add a lot of much-needed functionality or significant bugs that need to be fixed but that don't cause data loss.</li>
              <li>Minor: Useful enhancements and annoying but not damaging bugs.</li>
              <li>Trivial: Useful enhancements but generally cosmetic.</li>
            </ul>
          </div>
        </div>
        <div title="15.9.2.2. Code Blocks in Jira Comments">
          <div>
            <div>
              <div>
                <h4><a name="submitting.patches.jira.code"></a>15.9.2.2. Code Blocks in Jira Comments</h4>
              </div>
            </div>
          </div>
          <p>A commonly used macro in Jira is {code}. If you do this in a Jira comment...</p>
          <pre>{code}     code snippet  {code}  </pre>
          <p>... Jira will format the code snippet like code, instead of a regular comment. It improves readability.</p>
        </div>
      </div>
    </div>
    <div title="15.10. Developing">
      <div>
        <div>
          <div>
            <h2><a name="developing"></a>15.10. Developing</h2>
          </div>
        </div>
      </div>
      <div title="15.10.1. Codelines">
        <div>
          <div>
            <div>
              <h3><a name="codelines"></a>15.10.1. Codelines</h3>
            </div>
          </div>
        </div>
        <p>Most development is done on TRUNK. However, there are branches for minor releases (e.g., 0.90.1, 0.90.2, and 0.90.3 are on the 0.90 branch).</p>
        <p>If you have any questions on this just send an email to the dev dist-list.</p>
      </div>
      <div title="15.10.2. Unit Tests">
        <div>
          <div>
            <div>
              <h3><a name="unit.tests"></a>15.10.2. Unit Tests</h3>
            </div>
          </div>
        </div>
        <p>In HBase we use <a href="http://junit.org/" target="_top">JUnit</a> 4. If you need to run miniclusters of HDFS, ZooKeeper, HBase, or MapReduce testing, be sure to checkout the HBaseTestingUtility. Alex Baranau of Sematext describes how it can be used in <a href="http://blog.sematext.com/2010/08/30/hbase-case-study-using-hbasetestingutility-for-local-testing-development/" target="_top">HBase Case-Study: Using HBaseTestingUtility for Local Testing and Development</a> (2010).</p>
        <div title="15.10.2.1. Mockito">
          <div>
            <div>
              <div>
                <h4><a name="mockito"></a>15.10.2.1. Mockito</h4>
              </div>
            </div>
          </div>
          <p>Sometimes you don't need a full running server unit testing. For example, some methods can make do with a a org.apache.hadoop.hbase.Server instance or aorg.apache.hadoop.hbase.master.MasterServices Interface reference rather than a full-blown org.apache.hadoop.hbase.master.HMaster. In these cases, you maybe able to get away with a mocked Server instance. For example:</p>
          <pre>              TODO...                </pre>
        </div>
      </div>
      <div title="15.10.3. Code Standards">
        <div>
          <div>
            <div>
              <h3><a name="code.standards"></a>15.10.3. Code Standards</h3>
            </div>
          </div>
        </div>
        <p>See <a href="#eclipse.code.formatting" title="15.2.1.1. Code Formatting">Section 15.2.1.1, &ldquo;Code Formatting&rdquo;</a> and <a href="#common.patch.feedback" title="15.11.5. Common Patch Feedback">Section 15.11.5, &ldquo;Common Patch Feedback&rdquo;</a>.</p>
        <p>Also, please pay attention to the interface stability/audience classifications that you will see all over our code base. They look like this at the head of the class:</p>
        <pre>@InterfaceAudience.Public  @InterfaceStability.Stable</pre>
        <p>If the InterfaceAudience is Private, we can change the class (and we do not need to include a InterfaceStability mark). If a class is marked Public but its InterfaceStability is marked Unstable, we can change it. If it's marked Public/Evolving, we're allowed to change it but should try not to. If it's Public and Stable we can't change it without a deprecation path or with a really GREAT reason.</p>
        <p>When you add new classes, mark them with the annotations above if publically accessible. If you are not cleared on how to mark your additions, ask up on the dev list.</p>
        <p>This convention comes from our parent project Hadoop.</p>
      </div>
      <div title="15.10.4. Invariants">
        <div>
          <div>
            <div>
              <h3><a name="design.invariants"></a>15.10.4. Invariants</h3>
            </div>
          </div>
        </div>
        <p>We don't have many but what we have we list below. All are subject to challenge of course but until then, please hold to the rules of the road.</p>
        <div title="15.10.4.1. No permanent state in ZooKeeper">
          <div>
            <div>
              <div>
                <h4><a name="design.invariants.zk.data"></a>15.10.4.1. No permanent state in ZooKeeper</h4>
              </div>
            </div>
          </div>
          <p>ZooKeeper state should transient (treat it like memory). If deleted, hbase should be able to recover and essentially be in the same state[<a name="d2520e11190" href="#ftn.d2520e11190">31</a>].</p>
        </div>
      </div>
      <div title="15.10.5. Running In-Situ">
        <div>
          <div>
            <div>
              <h3><a name="run.insitu"></a>15.10.5. Running In-Situ</h3>
            </div>
          </div>
        </div>
        <p>If you are developing Apache HBase, frequently it is useful to test your changes against a more-real cluster than what you find in unit tests. In this case, HBase can be run directly from the source in local-mode. All you need to do is run:</p>
        <pre>${HBASE_HOME}/bin/start-hbase.sh</pre>
        <p>This will spin up a full local-cluster, just as if you had packaged up HBase and installed it on your machine.</p>
        <p>Keep in mind that you will need to have installed HBase into your local maven repository for the in-situ cluster to work properly. That is, you will need to run:</p>
        <pre>mvn clean install -DskipTests</pre>
        <p>to ensure that maven can find the correct classpath and dependencies. Generally, the above command is just a good thing to try running first, if maven is acting oddly.</p>
      </div>
    </div>
    <div title="15.11. Submitting Patches">
      <div>
        <div>
          <div>
            <h2><a name="submitting.patches"></a>15.11. Submitting Patches</h2>
          </div>
        </div>
      </div>
      <p>If you are new to submitting patches to open source or new to submitting patches to Apache, I'd suggest you start by reading the <a href="http://commons.apache.org/patches.html" target="_top">On Contributing Patches</a> page from <a href="http://commons.apache.org/" target="_top">Apache Commons Project</a>. Its a nice overview that applies equally to the Apache HBase Project.</p>
      <div title="15.11.1. Create Patch">
        <div>
          <div>
            <div>
              <h3><a name="submitting.patches.create"></a>15.11.1. Create Patch</h3>
            </div>
          </div>
        </div>
        <p>See the aforementioned Apache Commons link for how to make patches against a checked out subversion repository. Patch files can also be easily generated from Eclipse, for example by selecting "Team -&gt; Create Patch". Patches can also be created by git diff and svn diff.</p>
        <p>Please submit one patch-file per Jira. For example, if multiple files are changed make sure the selected resource when generating the patch is a directory. Patch files can reflect changes in multiple files.</p>
        <p>Make sure you review <a href="#eclipse.code.formatting" title="15.2.1.1. Code Formatting">Section 15.2.1.1, &ldquo;Code Formatting&rdquo;</a> for code style.</p>
      </div>
      <div title="15.11.2. Patch File Naming">
        <div>
          <div>
            <div>
              <h3><a name="submitting.patches.naming"></a>15.11.2. Patch File Naming</h3>
            </div>
          </div>
        </div>
        <p>The patch file should have the Apache HBase Jira ticket in the name. For example, if a patch was submitted for Foo.java, then a patch file called Foo_HBASE_XXXX.patch would be acceptable where XXXX is the Apache HBase Jira number.</p>
        <p>If you generating from a branch, then including the target branch in the filename is advised, e.g., HBASE-XXXX-0.90.patch.</p>
      </div>
      <div title="15.11.3. Unit Tests">
        <div>
          <div>
            <div>
              <h3><a name="submitting.patches.tests"></a>15.11.3. Unit Tests</h3>
            </div>
          </div>
        </div>
        <p>Yes, please. Please try to include unit tests with every code patch (and especially new classes and large changes). Make sure unit tests pass locally before submitting the patch.</p>
        <p>Also, see <a href="#mockito" title="15.10.2.1. Mockito">Section 15.10.2.1, &ldquo;Mockito&rdquo;</a>.</p>
        <p>If you are creating a new unit test class, notice how other unit test classes have classification/sizing annotations at the top and a static method on the end. Be sure to include these in any new unit test files you generate. See <a href="#hbase.tests" title="15.7. Tests">Section 15.7, &ldquo;Tests&rdquo;</a> for more on how the annotations work.</p>
      </div>
      <div title="15.11.4. Attach Patch to Jira">
        <div>
          <div>
            <div>
              <h3><a name="submitting.patches.jira"></a>15.11.4. Attach Patch to Jira</h3>
            </div>
          </div>
        </div>
        <p>The patch should be attached to the associated Jira ticket "More Actions -&gt; Attach Files". Make sure you click the ASF license inclusion, otherwise the patch can't be considered for inclusion.</p>
        <p>Once attached to the ticket, click "Submit Patch" and the status of the ticket will change. Committers will review submitted patches for inclusion into the codebase. Please understand that not every patch may get committed, and that feedback will likely be provided on the patch. Fear not, though, because the Apache HBase community is helpful!</p>
      </div>
      <div title="15.11.5. Common Patch Feedback">
        <div>
          <div>
            <div>
              <h3><a name="common.patch.feedback"></a>15.11.5. Common Patch Feedback</h3>
            </div>
          </div>
        </div>
        <p>The following items are representative of common patch feedback. Your patch process will go faster if these are taken into account <em>before</em> submission.</p>
        <p>See the <a href="http://www.oracle.com/technetwork/java/codeconv-138413.html" target="_top">Java coding standards</a> for more information on coding conventions in Java.</p>
        <div title="15.11.5.1. Space Invaders">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.space.invaders"></a>15.11.5.1. Space Invaders</h4>
              </div>
            </div>
          </div>
          <p>Rather than do this...</p>
          <pre>if ( foo.equals( bar ) ) {     // don't do this  </pre>
          <p>... do this instead...</p>
          <pre>if (foo.equals(bar)) {  </pre>
          <p>Also, rather than do this...</p>
          <pre>foo = barArray[ i ];     // don't do this  </pre>
          <p>... do this instead...</p>
          <pre>foo = barArray[i];  </pre>
        </div>
        <div title="15.11.5.2. Auto Generated Code">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.autogen"></a>15.11.5.2. Auto Generated Code</h4>
              </div>
            </div>
          </div>
          <p>Auto-generated code in Eclipse often looks like this...</p>
          <pre> public void readFields(DataInput arg0) throws IOException {    // don't do this     foo = arg0.readUTF();                                       // don't do this  </pre>
          <p>... do this instead ...</p>
          <pre> public void readFields(DataInput di) throws IOException {     foo = di.readUTF();  </pre>
          <p>See the difference? 'arg0' is what Eclipse uses for arguments by default.</p>
        </div>
        <div title="15.11.5.3. Long Lines">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.longlines"></a>15.11.5.3. Long Lines</h4>
              </div>
            </div>
          </div>
          <p>Keep lines less than 100 characters.</p>
          <pre>Bar bar = foo.veryLongMethodWithManyArguments(argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9);  // don't do this  </pre>
          <p>... do something like this instead ...</p>
          <pre>Bar bar = foo.veryLongMethodWithManyArguments(   argument1, argument2, argument3,argument4, argument5, argument6, argument7, argument8, argument9);  </pre>
        </div>
        <div title="15.11.5.4. Trailing Spaces">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.trailingspaces"></a>15.11.5.4. Trailing Spaces</h4>
              </div>
            </div>
          </div>
          <p>This happens more than people would imagine.</p>
          <pre>Bar bar = foo.getBar();     &lt;--- imagine there's an extra space(s) after the semicolon instead of a line break.  </pre>
          <p>Make sure there's a line-break after the end of your code, and also avoid lines that have nothing but whitespace.</p>
        </div>
        <div title="15.11.5.5. Implementing Writable">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.writable"></a>15.11.5.5. Implementing Writable</h4>
              </div>
            </div>
          </div>
          <div title="Applies pre-0.96 only">
            <h3>Applies pre-0.96 only</h3>
            <p>In 0.96, HBase moved to protobufs. The below section on Writables applies to 0.94.x and previous, not to 0.96 and beyond.</p>
          </div>
          <p>Every class returned by RegionServers must implement Writable. If you are creating a new class that needs to implement this interface, don't forget the default constructor.</p>
        </div>
        <div title="15.11.5.6. Javadoc">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.javadoc"></a>15.11.5.6. Javadoc</h4>
              </div>
            </div>
          </div>
          <p>This is also a very common feedback item. Don't forget Javadoc!</p>
          <p>Javadoc warnings are checked during precommit. If the precommit tool gives you a '-1', please fix the javadoc issue. Your patch won't be committed if it adds such warnings.</p>
        </div>
        <div title="15.11.5.7. Findbugs">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.findbugs"></a>15.11.5.7. Findbugs</h4>
              </div>
            </div>
          </div>
          <p>Findbugs is used to detect common bugs pattern. As Javadoc, it is checked during the precommit build up on Apache's Jenkins, and as with Javadoc, please fix them. You can run findbugs locally with 'mvn findbugs:findbugs': it will generate the findbugs files locally. Sometimes, you may have to write code smarter than Findbugs. You can annotate your code to tell Findbugs you know what you're doing, by annotating your class with:</p>
          <pre>@edu.umd.cs.findbugs.annotations.SuppressWarnings(                      value="HE_EQUALS_USE_HASHCODE",                      justification="I know what I'm doing")</pre>
          <p>Note that we're using the apache licensed version of the annotations.</p>
        </div>
        <div title="15.11.5.8. Javadoc - Useless Defaults">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.javadoc.defaults"></a>15.11.5.8. Javadoc - Useless Defaults</h4>
              </div>
            </div>
          </div>
          <p>Don't just leave the @param arguments the way your IDE generated them. Don't do this...</p>
          <pre>  /**     *     * @param bar             &lt;---- don't do this!!!!     * @return                &lt;---- or this!!!!     */    public Foo getFoo(Bar bar);  </pre>
          <p>... either add something descriptive to the @param and @return lines, or just remove them. But the preference is to add something descriptive and useful.</p>
        </div>
        <div title="15.11.5.9. One Thing At A Time, Folks">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.onething"></a>15.11.5.9. One Thing At A Time, Folks</h4>
              </div>
            </div>
          </div>
          <p>If you submit a patch for one thing, don't do auto-reformatting or unrelated reformatting of code on a completely different area of code.</p>
          <p>Likewise, don't add unrelated cleanup or refactorings outside the scope of your Jira.</p>
        </div>
        <div title="15.11.5.10. Ambigious Unit Tests">
          <div>
            <div>
              <div>
                <h4><a name="common.patch.feedback.tests"></a>15.11.5.10. Ambigious Unit Tests</h4>
              </div>
            </div>
          </div>
          <p>Make sure that you're clear about what you are testing in your unit tests and why.</p>
        </div>
      </div>
      <div title="15.11.6. ReviewBoard">
        <div>
          <div>
            <div>
              <h3><a name="reviewboard"></a>15.11.6. ReviewBoard</h3>
            </div>
          </div>
        </div>
        <p>Larger patches should go through <a href="http://reviews.apache.org/" target="_top">ReviewBoard</a>.</p>
        <p>For more information on how to use ReviewBoard, see <a href="http://www.reviewboard.org/docs/manual/1.5/" target="_top">the ReviewBoard documentation</a>.</p>
      </div>
      <div title="15.11.7. Committing Patches">
        <div>
          <div>
            <div>
              <h3><a name="committing.patches"></a>15.11.7. Committing Patches</h3>
            </div>
          </div>
        </div>
        <p>Committers do this. See <a href="http://wiki.apache.org/hadoop/Hbase/HowToCommit" target="_top">How To Commit</a> in the Apache HBase wiki.</p>
        <p>Commiters will also resolve the Jira, typically after the patch passes a build.</p>
        <div title="15.11.7.1. Committers are responsible for making sure commits do not break the build or tests">
          <div>
            <div>
              <div>
                <h4><a name="committer.tests"></a>15.11.7.1. Committers are responsible for making sure commits do not break the build or tests</h4>
              </div>
            </div>
          </div>
          <p>If a committer commits a patch it is their responsibility to make sure it passes the test suite. It is helpful if contributors keep an eye out that their patch does not break the hbase build and/or tests but ultimately, a contributor cannot be expected to be up on the particular vagaries and interconnections that occur in a project like hbase. A committer should.</p>
        </div>
      </div>
    </div>
    <div><br>
      <hr width="100" align="left">
      <div>
        <p>[<a id="ftn.d2520e10462" href="#d2520e10462">30</a>] Before 0.95.0, site and reference guide were at src/docbkx and src/site respectively</p>
      </div>
      <div>
        <p>[<a id="ftn.d2520e11190" href="#d2520e11190">31</a>] There are currently a few exceptions that we need to fix around whether a table is enabled or disabled</p>
      </div>
    </div>
  </div></div>
    <div class="section" title="15.9.&nbsp;Submitting Patches"><div class="section" title="15.9.7.&nbsp;Committing Patches">
      <div>
        <div>
              <div>
                <h1><a name="zookeeper"></a>16. ZooKeeper<a name="d1934e929"></a></h1>
              </div>
            </div>
        </div>
          <p>一个分布式运行的HBase依赖一个zookeeper集群。所有的节点和客户端都必须能够访问zookeeper。默认的情况下HBase会管理一个zookeep集群。这个集群会随着HBase的启动而启动。当然，你也可以自己管理一个zookeeper集群，但需要配置HBase。你需要修改<code class="filename">conf/hbase-env.sh</code>里面的<code class="varname">HBASE_MANAGES_ZK</code> 来切换。这个值默认是true的，作用是让HBase启动的时候同时也启动zookeeper.</p>
          <p>当HBase管理zookeeper的时候，你可以通过修改<code class="filename">zoo.cfg</code>来配置zookeeper，一个更加简单的方法是在 <code class="filename">conf/hbase-site.xml</code>里面修改zookeeper的配置。Zookeep的配置是作为property写在 <code class="filename">hbase-site.xml</code>里面的。option的名字是 <code class="varname">hbase.zookeeper.property</code>. 打个比方， <code class="varname">clientPort</code> 配置在xml里面的名字是 <code class="varname">hbase.zookeeper.property.clientPort</code>.
            所有的默认值都是HBase决定的，包括zookeeper, 参见 <a class="xref" href="#hbase_default_configurations" title="3.1.1. HBase 默认配置">Section&nbsp;2.3.1.1, “HBase 默认配置”</a>. 可以查找 <code class="varname">hbase.zookeeper.property</code> 前缀，找到关于zookeeper的配置。 <sup>[<a name="d613e690" href="#ftn.d352e10649" class="footnote">33</a>]</sup></p>
          <p>对于zookeepr的配置，你至少要在 <code class="filename">hbase-site.xml</code>中列出zookeepr的ensemble servers，具体的字段是 <code class="varname">hbase.zookeeper.quorum</code>. 该这个字段的默认值是 <code class="varname">localhost</code>，这个值对于分布式应用显然是不可以的. (远程连接无法使用). </p>
          <div class="note" title="我需要运行几个zookeeper?" style="margin-left: 0.5in; margin-right: 0.5in;">
            <h3 class="title"><a name="how_many_zks"></a>我需要运行几个zookeeper?</h3>
            <p>你运行一个zookeeper也是可以的，但是在生产环境中，你最好部署3，5，7个节点。部署的越多，可靠性就越高，当然只能部署奇数个，偶数个是不可以的。你需要给每个zookeeper 1G左右的内存，如果可能的话，最好有独立的磁盘。 (独立磁盘可以确保zookeeper是高性能的。).如果你的集群负载很重，不要把Zookeeper和RegionServer运行在同一台机器上面。就像DataNodes 和 TaskTrackers一样</p>
          </div>
          <p>举个例子，HBase管理着的ZooKeeper集群在节点 <span class="emphasis"><em>rs{1,2,3,4,5}.example.com</em></span>, 监听2222 端口(默认是2181)，并确保<code class="filename">conf/hbase-env.sh</code>文件中 <code class="varname">HBASE_MANAGE_ZK</code>的值是 <code class="varname">true</code> ，再编辑 <code class="filename">conf/hbase-site.xml</code> 设置 <code class="varname">hbase.zookeeper.property.clientPort</code> 和 <code class="varname">hbase.zookeeper.quorum</code>。你还可以设置 <code class="varname">hbase.zookeeper.property.dataDir</code>属性来把ZooKeeper保存数据的目录地址改掉。默认值是 <code class="filename">/tmp</code> ，这里在重启的时候会被操作系统删掉，可以把它修改到 <code class="filename">/user/local/zookeeper</code>. </p>
          <pre class="programlisting">  &lt;configuration&gt;
    ...
    &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt;
      &lt;value&gt;2222&lt;/value&gt;
      &lt;description&gt;Property from ZooKeeper's config zoo.cfg.
      The port at which the clients will connect.
      &lt;/description&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
      &lt;value&gt;rs1.example.com,rs2.example.com,rs3.example.com,rs4.example.com,rs5.example.com&lt;/value&gt;
      &lt;description&gt;Comma separated list of servers in the ZooKeeper Quorum.
      For example, "host1.mydomain.com,host2.mydomain.com,host3.mydomain.com".
      By default this is set to localhost for local and pseudo-distributed modes
      of operation. For a fully-distributed setup, this should be set to a full
      list of ZooKeeper quorum servers. If HBASE_MANAGES_ZK is set in hbase-env.sh
      this is the list of servers which we will start/stop ZooKeeper on.
      &lt;/description&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
      &lt;value&gt;/usr/local/zookeeper&lt;/value&gt;
      &lt;description&gt;Property from ZooKeeper's config zoo.cfg.
      The directory where the snapshot is stored.
      &lt;/description&gt;
    &lt;/property&gt;
    ...
  &lt;/configuration&gt;</pre>
          <h3>ZooKeeper 维护</h3>
          <p>Be sure to set up the data dir cleaner described under <a href="http://zookeeper.apache.org/doc/r3.1.2/zookeeperAdmin.html#sc_maintenance" target="_top">Zookeeper Maintenance</a> else you could have 'interesting' problems a couple of months in; i.e. zookeeper could start dropping sessions if it has to run through a directory of hundreds of thousands of logs which is wont to do around leader reelection time -- a process rare but run on occasion whether because a machine is dropped or happens to hiccup.</p>
          <div class="section" title="2.2.2.2.2.1. 使用现有的ZooKeeper例子">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title"><a name="d352e10721" id="d352e10721"></a>16.1.&nbsp;和已有的ZooKeeper一起使用</h2>
                </div>
              </div>
            </div>
            <p>让HBase使用一个已有的不被HBase托管的Zookeep集群，需要设置 <code class="filename">conf/hbase-env.sh</code>文件中的<code class="varname">HBASE_MANAGES_ZK</code> 属性为 false </p>
            <pre class="programlisting">  ...
  # Tell HBase whether it should manage it's own instance of Zookeeper or not.
  export HBASE_MANAGES_ZK=false</pre>
            <p> 接下来，指明Zookeeper的host和端口。可以在 <code class="filename">hbase-site.xml</code>中设置, 也可以在HBase的<code class="filename">CLASSPATH</code>下面加一个<code class="filename">zoo.cfg</code>配置文件。
              HBase 会优先加载 <code class="filename">zoo.cfg</code> 里面的配置，把<code class="filename">hbase-site.xml</code>里面的覆盖掉.</p>
            <p>当HBase托管ZooKeeper的时候，Zookeeper集群的启动是HBase启动脚本的一部分。但现在，你需要自己去运行。你可以这样做</p>
            <pre class="programlisting">${HBASE_HOME}/bin/hbase-daemons.sh {start,stop} zookeeper
            </pre>
            <p>你可以用这条命令启动ZooKeeper而不启动HBase. <code class="varname">HBASE_MANAGES_ZK</code> 的值是 <code class="varname">false</code>，
              如果你想在HBase重启的时候不重启ZooKeeper,你可以这样做</p>
            <p>对于独立Zoopkeeper的问题，你可以在 <a class="link" href="http://hadoop.apache.org/zookeeper/docs/current/zookeeperStarted.html" target="_top">Zookeeper启动</a>得到帮助.</p>
        </div>
          <div title="2.5.1. Using existing ZooKeeper ensemble">
            <div>
              <div>
                <div></div>
              </div>
            </div>
          </div>
          <div class="section" title="2.5.&nbsp;ZooKeeper">
            <div class="section" title="2.5.2.&nbsp;SASL Authentication with ZooKeeper">
              <div class="titlepage">
                <div>
                  <div>
                    <h2 class="title"><a name="zk.sasl.auth"></a>16.2.&nbsp; 通过ZooKeeper 的SASL 认证</h2>
                  </div>
                </div>
              </div>
              <p>新版 HBase (&gt;= 0.92)将支持连接到 ZooKeeper Quorum 进行SASL 认证。 ( Zookeeper
                3.4.0 以上可用).</p>
              <p>这里描述如何设置 HBase，以同 ZooKeeper Quorum实现互相认证. ZooKeeper/HBase
                互相认证 (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-2418" target="_top">HBASE-2418</a>)
                是 HBase安全配置所必不可少的一部分
                (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-3025" target="_top">HBASE-3025</a>)。
                
                为简化说明, 本节忽略所必需的额外配置 ( HDFS 安全和 Coprocessor
                配置)。  推荐使用HBase内置 Zookeeper 配置 (相对独立 Zookeeper quorum) 以简化学习. </p>
              <div class="section" title="2.5.2.1.&nbsp;Operating System Prerequisites">
                <div class="titlepage">
                  <div>
                    <div>
                      <h3 class="title"><a name="d1934e1097"></a>16.2.1.&nbsp;操作系统预置</h3>
                    </div>
                  </div>
                </div>
              </div>
              <p> 需要一个工作 Kerberos KDC 配置. 每个 <code class="code">$HOST</code> 运行一个 ZooKeeper
                服务器, 应该有个主要的 <code class="code">zookeeper/$HOST</code>.  对每个主机，为 <code class="code">zookeeper/$HOST</code>添加一个 key (使用 <code class="code">kadmin</code> 或 <code class="code">kadmin.local</code> 工具的 <code class="code">ktadd</code> 命令) ，将该key文件复制到 <code class="code">$HOST</code>, 并设置仅对该 <code class="code">$HOST</code>上运行 zookeeper 的用户只读。注意文件位置,
                我们将在下面以 <code class="filename">$PATH_TO_ZOOKEEPER_KEYTAB</code> 使用。 </p>
              <p> Similarly, for each <code class="code">$HOST</code> that will run
                an HBase server (master or regionserver), you should
                have a principle: <code class="code">hbase/$HOST</code>. For each
                host, add a keytab file called <code class="filename">hbase.keytab</code> containing a service
                key for <code class="code">hbase/$HOST</code>, copy this file to <code class="code">$HOST</code>, and make it readable only to the
                user that will run an HBase service on <code class="code">$HOST</code>. Note the location of this file,
                which we will use below as <code class="filename">$PATH_TO_HBASE_KEYTAB</code>. </p>
              <p> Each user who will be an HBase client should also be
                given a Kerberos principal. This principal should
                usually have a password assigned to it (as opposed to,
                as with the HBase servers, a keytab file) which only
                this user knows. The client's principal's <code class="code">maxrenewlife</code> should be set so that it can
                be renewed enough so that the user can complete their
                HBase client processes. For example, if a user runs a
                long-running HBase client process that takes at most 3
                days, we might create this user's principal within <code class="code">kadmin</code> with: <code class="code">addprinc -maxrenewlife
                  3days</code>. The Zookeeper client and server
                libraries manage their own ticket refreshment by
                running threads that wake up periodically to do the
                refreshment. </p>
              <p>On each host that will run an HBase client
                (e.g. <code class="code">hbase shell</code>), add the following
                file to the HBase home directory's <code class="filename">conf</code> directory:</p>
              <pre class="programlisting">                  Client {
                    com.sun.security.auth.module.Krb5LoginModule required
                    useKeyTab=false
                    useTicketCache=true;
                  };
                </pre>
              <p>We'll refer to this JAAS configuration file as <code class="filename">$CLIENT_CONF</code> below.</p>
              <div class="section" title="2.5.2.2.&nbsp;HBase-managed Zookeeper Configuration">
                <div class="titlepage">
                  <div>
                    <div>
                      <h3 class="title"><a name="d1934e1178"></a>16.2.2.&nbsp;HBase内置的 Zookeeper 配置</h3>
                    </div>
                  </div>
                </div>
                <p>每个节点要运行一个 zookeeper, 一个主服务, 或一个 regionserver,在<code class="filename">HBASE_HOME</code>的conf目录中创建如下所示的 <a class="link" href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jgss/tutorials/LoginConfigFile.html" target="_top">JAAS</a> 配置文件:</p>
                <pre class="programlisting">                  Server {
                    com.sun.security.auth.module.Krb5LoginModule required
                    useKeyTab=true
                    keyTab="$PATH_TO_ZOOKEEPER_KEYTAB"
                    storeKey=true
                    useTicketCache=false
                    principal="zookeeper/$HOST";
                  };
                  Client {
                    com.sun.security.auth.module.Krb5LoginModule required
                    useKeyTab=true
                    useTicketCache=false
                    keyTab="$PATH_TO_HBASE_KEYTAB"
                    principal="hbase/$HOST";
                  };
                </pre>
                <code class="filename">$PATH_TO_HBASE_KEYTAB</code> 和 <code class="filename">$PATH_TO_ZOOKEEPER_KEYTAB</code>文件是上面创建的。 <code class="code">$HOST</code> 该节点主机名.
                <p><code class="code">Server</code> 由 Zookeeper quorum 服务器使用, <code class="code">Client</code> 节由 HBase
                  master 和 regionserver使用。 The path to this file should
                  be substituted for the text <code class="filename">$HBASE_SERVER_CONF</code> in the <code class="filename">hbase-env.sh</code> listing below.</p>
                <p> The path to this file should be substituted for the
                  text <code class="filename">$CLIENT_CONF</code> in the <code class="filename">hbase-env.sh</code> listing below. </p>
                <p>Modify your <code class="filename">hbase-env.sh</code> to include the
                  following:</p>
                <pre class="programlisting">                  export HBASE_OPTS="-Djava.security.auth.login.config=$CLIENT_CONF"
                  export HBASE_MANAGES_ZK=true
                  export HBASE_ZOOKEEPER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
                  export HBASE_MASTER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
                  export HBASE_REGIONSERVER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
                </pre>
                where <code class="filename">$HBASE_SERVER_CONF</code> and <code class="filename">$CLIENT_CONF</code> are the full paths to the
                JAAS configuration files created above.
                <p>Modify your <code class="filename">hbase-site.xml</code> on each node
                  that will run zookeeper, master or regionserver to contain:</p>
                <pre class="programlisting">                  &lt;configuration&gt;
                    &lt;property&gt;
                      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
                      &lt;value&gt;$ZK_NODES&lt;/value&gt;
                    &lt;/property&gt;
                    &lt;property&gt;
                      &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
                      &lt;value&gt;true&lt;/value&gt;
                    &lt;/property&gt;
                    &lt;property&gt;
                      &lt;name&gt;hbase.zookeeper.property.authProvider.1&lt;/name&gt;
                      &lt;value&gt;org.apache.zookeeper.server.auth.SASLAuthenticationProvider&lt;/value&gt;
                    &lt;/property&gt;
                    &lt;property&gt;
                      &lt;name&gt;hbase.zookeeper.property.kerberos.removeHostFromPrincipal&lt;/name&gt;
                      &lt;value&gt;true&lt;/value&gt;
                    &lt;/property&gt;
                    &lt;property&gt;
                      &lt;name&gt;hbase.zookeeper.property.kerberos.removeRealmFromPrincipal&lt;/name&gt;
                      &lt;value&gt;true&lt;/value&gt;
                    &lt;/property&gt;
                  &lt;/configuration&gt;
                  </pre>
                <p>where <code class="code">$ZK_NODES</code> is the
                  comma-separated list of hostnames of the Zookeeper
                  Quorum hosts.</p>
                <p>Start your hbase cluster by running one or more
                  of the following set of commands on the appropriate
                  hosts: </p>
                <pre class="programlisting">                  bin/hbase zookeeper start
                  bin/hbase master start
                  bin/hbase regionserver start
                </pre>
              </div>
              <div class="section" title="2.5.2.3.&nbsp;External Zookeeper Configuration">
                <div class="titlepage">
                  <div>
                    <div>
                      <h3 class="title"><a name="d1934e1253"></a>16.2.3.&nbsp;外部 Zookeeper 配置</h3>
                    </div>
                  </div>
                </div>
                <p>增加 JAAS 配置文件: </p>
                <pre class="programlisting">                  Client {
                    com.sun.security.auth.module.Krb5LoginModule required
                    useKeyTab=true
                    useTicketCache=false
                    keyTab="$PATH_TO_HBASE_KEYTAB"
                    principal="hbase/$HOST";
                  };
                </pre>
                <p><code class="filename">$PATH_TO_HBASE_KEYTAB</code> 是上面创建的keytab，以便 HBase 服务可以在本主机运行 , <code class="code">$HOST</code> 是该节点的
                  hostname . 将该配置放到 HBase home配置目录.在下面的 <code class="filename">$HBASE_SERVER_CONF</code> 进行引用.</p>
                <p>修改 hbase-env.sh 增加如下项:</p>
                <pre class="programlisting">                  export HBASE_OPTS="-Djava.security.auth.login.config=$CLIENT_CONF"
                  export HBASE_MANAGES_ZK=false
                  export HBASE_MASTER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
                  export HBASE_REGIONSERVER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
                </pre>
                <p>修改每个节点的 <code class="filename">hbase-site.xml</code> 包含下面内容:</p>
                <pre class="programlisting">                  &lt;configuration&gt;
                    &lt;property&gt;
                      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
                      &lt;value&gt;$ZK_NODES&lt;/value&gt;
                    &lt;/property&gt;
                    &lt;property&gt;
                      &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
                      &lt;value&gt;true&lt;/value&gt;
                    &lt;/property&gt;
                  &lt;/configuration&gt;
                  
                </pre>
                <p> <code class="code">$ZK_NODES</code>是逗号分隔的Zookeeper
                  Quorum主机名列表。</p>
                <p> 每个Zookeeper Quorum节点增加 <code class="filename">zoo.cfg</code> 包含下列内容: </p>
                <pre class="programlisting">                      authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProvider
                      kerberos.removeHostFromPrincipal=true
                      kerberos.removeRealmFromPrincipal=true
                  </pre>
                <p> 在每个主机创建 JAAS 配置并包含: </p>
                <pre class="programlisting">                  Server {
                    com.sun.security.auth.module.Krb5LoginModule required
                    useKeyTab=true
                    keyTab="$PATH_TO_ZOOKEEPER_KEYTAB"
                    storeKey=true
                    useTicketCache=false
                    principal="zookeeper/$HOST";
                  };
                  </pre>
                <p><code class="code">$HOST</code> 每个Quorum 的主机名. 我们会在下面的<code class="filename">$ZK_SERVER_CONF</code>引用本文件的全路径名称. </p>
                <p> 在每个 Zookeeper Quorum主机启动 Zookeeper: </p>
                <pre class="programlisting">                    SERVER_JVMFLAGS="-Djava.security.auth.login.config=$ZK_SERVER_CONF" bin/zkServer start
                  </pre>
                <p></p>
                <p> 启动HBase 集群。在适当的节点运行下面的一到多个命令：</p>
                <pre class="programlisting">                  bin/hbase master start
                  bin/hbase regionserver start
                </pre>
              </div>
              <div class="section" title="2.5.2.4.&nbsp;Zookeeper Server Authentication Log Output">
                <div class="titlepage">
                  <div>
                    <div>
                      <h3 class="title"><a name="d1934e1312"></a>16.2.4.&nbsp;Zookeeper 服务端认证日志输出 </h3>
                    </div>
                  </div>
                </div>
                <p>如果上面配置成功,
                  你应该可以看到如下所示的Zookeeper 服务器日志: </p>
                <pre class="programlisting">11/12/05 22:43:39 INFO zookeeper.Login: successfully logged in.
11/12/05 22:43:39 INFO server.NIOServerCnxnFactory: binding to port 0.0.0.0/0.0.0.0:2181
11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh thread started.
11/12/05 22:43:39 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:39 UTC 2011
11/12/05 22:43:39 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:39 UTC 2011
11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:36:42 UTC 2011
..
11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler: 
  Successfully authenticated client: authenticationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN; 
  authorizationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN.
11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler: Setting authorizedID: hbase
11/12/05 22:43:59 INFO server.ZooKeeperServer: adding SASL authorization for authorizationID: hbase
                </pre>
                <p></p>
              </div>
              <div class="section" title="2.5.2.5.&nbsp;Zookeeper Client Authentication Log Output">
                <div class="titlepage">
                  <div>
                    <div>
                      <h3 class="title"><a name="d1934e1320"></a>16.2.5.&nbsp;Zookeeper 客户端认证日志输出 </h3>
                    </div>
                  </div>
                </div>
                <p> Zookeeper 客户端侧 (HBase master 或 regionserver),
                  应该可以看到如下所示的东西: </p>
                <pre class="programlisting">11/12/05 22:43:59 INFO zookeeper.ZooKeeper: Initiating client connection, connectString=ip-10-166-175-249.us-west-1.compute.internal:2181 sessionTimeout=180000 watcher=master:60000
11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Opening socket connection to server /10.166.175.249:2181
11/12/05 22:43:59 INFO zookeeper.RecoverableZooKeeper: The identifier of this process is 14851@ip-10-166-175-249
11/12/05 22:43:59 INFO zookeeper.Login: successfully logged in.
11/12/05 22:43:59 INFO client.ZooKeeperSaslClient: Client will use GSSAPI as SASL mechanism.
11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh thread started.
11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Socket connection established to ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, initiating session
11/12/05 22:43:59 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:59 UTC 2011
11/12/05 22:43:59 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:59 UTC 2011
11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:30:37 UTC 2011
11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Session establishment complete on server ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, sessionid = 0x134106594320000, negotiated timeout = 180000
                </pre>
                <p></p>
              </div>
              <div class="section" title="2.5.2.6.&nbsp;Configuration from Scratch">
                <div class="titlepage">
                  <div>
                    <div>
                      <h3 class="title"><a name="d1934e1328"></a>16.2.6.&nbsp;从头开始配置</h3>
                    </div>
                  </div>
                </div>
                在当前标准的 Amazon
                Linux AMI上测试通过.  先按上面的描述配置 KDC 和 主要节点. 然后获取代码并执行检测.
                <pre class="programlisting">                git clone git://git.apache.org/hbase.git
                cd hbase
                mvn -Psecurity,localTests clean test -Dtest=TestZooKeeperACL
                </pre>
                再按上面描述配置 HBase. 手工编辑target/cached_classpath.txt (如下)..
                <pre class="programlisting">                bin/hbase zookeeper &amp;
                bin/hbase master &amp;
                bin/hbase regionserver &amp;
                </pre>
              </div>
              <div class="section" title="2.5.2.7.&nbsp;Future improvements">
                <div class="titlepage">
                  <div>
                    <div>
                      <h3 class="title"><a name="d1934e1337"></a>16.2.7.&nbsp;未来改进</h3>
                    </div>
                  </div>
                </div>
                <div class="section" title="2.5.2.7.1.&nbsp;Fix target/cached_classpath.txt">
                  <div class="titlepage">
                    <div>
                      <div>
                        <h4 class="title"><a name="d1934e1340"></a>16.2.7.1.&nbsp;完善 target/cached_classpath.txt</h4>
                      </div>
                    </div>
                  </div>
                  <p> 必须在 <code class="code">target/cached_classpath.txt</code> 重写标准 hadoop-core jar 文件为包含 HADOOP-7070 修改的版本。可以使用下列脚本完成: </p>
                  <pre class="programlisting">                  echo `find ~/.m2 -name "*hadoop-core*7070*SNAPSHOT.jar"` ':' `cat target/cached_classpath.txt` | sed 's/ //g' &gt; target/tmp.txt 
                  mv target/tmp.txt target/cached_classpath.txt
                  </pre>
                  <p></p>
                </div>
                <div class="section" title="2.5.2.7.2.&nbsp;Set JAAS configuration programmatically">
                  <div class="titlepage">
                    <div>
                      <div>
                        <h4 class="title"><a name="d1934e1351"></a>16.2.7.2.&nbsp;用程序配置 JAAS </h4>
                      </div>
                    </div>
                  </div>
                  可以避免分离的 Hadoop 修复 <a class="link" href="https://issues.apache.org/jira/browse/HADOOP-7070" target="_top">HADOOP-7070</a> 的jar文件. </div>
                <div class="section" title="2.5.2.7.3.&nbsp;Elimination of kerberos.removeHostFromPrincipal and kerberos.removeRealmFromPrincipal">
                  <div class="titlepage">
                    <div>
                      <div>
                        <h4 class="title"><a name="d1934e1358"></a>16.2.7.3.&nbsp;排除 <code class="code">kerberos.removeHostFromPrincipal</code> 和 <code class="code">kerberos.removeRealmFromPrincipal</code></h4>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <p>[<a id="ftn.d352e10649" href="#d352e10649">33</a>] 要查看全部 ZooKeeper 配置项列表，参考 ZooKeeper的 zoo.cfg. HBase 没有附带 zoo.cfg ，所以你需要查看合适的ZooKeeper下载的conf目录。</p>
          <div>
            <div>
              <div>
                <h2>Chapter 17. 社区</h2>
              </div>
            </div>
          </div>
          <div>
            <p><strong>Table of Contents</strong></p>
            <dl>
              <dt><a href="#decisions">17.1. 决策</a></dt>
              <dd>
                <dl>
                  <dt><a href="#feature_branches">17.1.1. 特征分支</a></dt>
                  <dt><a href="#patchplusonepolicy">17.1.2. 补丁 +1 政策</a></dt>
                </dl>
              </dd>
              <dt><a href="#community.roles">17.2. 社区角色</a></dt>
              <dd>
                <dl>
                  <dt><a href="#OWNER">17.2.1. 组件所有者</a></dt>
                  </dl>
              </dd>
            </dl>
          </div>
          <div title="17.1. Decisions">
            <div>
              <div>
                <div>
                  <h2><a name="decisions"></a>17.1. 决策</h2>
                </div>
              </div>
            </div>
            <div title="17.1.1. Feature Branches">
              <div>
                <div>
                  <div>
                    <h3><a name="feature_branches"></a>17.1.1. 特征分支</h3>
                  </div>
                </div>
              </div>
              <p>特征分支很容易制作。你可以不是代码提交者。只需提供需要添加到JIRA上的分支名称到开发者邮件列表，代码提交者会为你添加。然后你可以在你的特征分支下提交发行文件到Apache HBase (TM) JIRA。你的代码保留在别处——一定要公开以便观察到——你可以在开发邮件列表更新进度。当特征已经准备好提交时，3+1 位代码提交者将合并你的特征。[<a name="d352e11068" href="#ftn.d352e11068">34</a>]</p>
            </div>
            <div title="17.1.2. Patch +1 Policy">
              <div>
                <div>
                  <div>
                    <h3><a name="patchplusonepolicy"></a>17.1.2. 补丁 +1 政策</h3>
                  </div>
                </div>
              </div>
              <p>The below policy is something we put in place 09/2012. It is a suggested policy rather than a hard requirement. We want to try it first to see if it works before we cast it in stone.</p>
              <p>Apache HBase is made of <a href="https://issues.apache.org/jira/browse/HBASE#selectedTab=com.atlassian.jira.plugin.system.project%3Acomponents-panel" target="_top">components</a>. Components have one or more <a href="#OWNER" title="17.2.1. Component Owner">Section 17.2.1, &ldquo;Component Owner&rdquo;</a>s. See the 'Description' field on the <a href="https://issues.apache.org/jira/browse/HBASE#selectedTab=com.atlassian.jira.plugin.system.project%3Acomponents-panel" target="_top">components</a> JIRA page for who the current owners are by component.</p>
              <p>Patches that fit within the scope of a single Apache HBase component require, at least, a +1 by one of the component's owners before commit. If owners are absent -- busy or otherwise -- two +1s by non-owners will suffice.</p>
              <p>Patches that span components need at least two +1s before they can be committed, preferably +1s by owners of components touched by the x-component patch (TODO: This needs tightening up but I think fine for first pass).</p>
              <p>Any -1 on a patch by anyone vetos a patch; it cannot be committed until the justification for the -1 is addressed.</p>
            </div>
          </div>
          <div title="17.2. Community Roles">
            <div>
              <div>
                <div>
                  <h2><a name="community.roles"></a>17.2. 社区角色</h2>
                </div>
              </div>
            </div>
            <div title="17.2.1. Component Owner">
              <div>
                <div>
                  <div>
                    <h3><a name="OWNER"></a>17.2.1. 组件所有者</h3>
                  </div>
                </div>
              </div>
              <p>组件所有者列在Apache HBase JIRA <a href="https://issues.apache.org/jira/browse/HBASE#selectedTab=com.atlassian.jira.plugin.system.project%3Acomponents-panel" target="_top">components</a>页的描述域内。所有者列在描述域而不是“组件领导者”域，因为后者只允许列一个人，而我们鼓励组件由多人所有。</p>
              <p>Owners are volunteers who are (usually, but not necessarily) expert in their component domain and may have an agenda on how they think their Apache HBase component should evolve.</p>
              <p>Duties include:</p>
              <div>
                <ol type="1">
                  <li>
                    <p>Owners will try and review patches that land within their component's scope.</p>
                  </li>
                  <li>
                    <p>If applicable, if an owner has an agenda, they will publish their goals or the design toward which they are driving their component</p>
                  </li>
                </ol>
              </div>
              <p>If you would like to be volunteer as a component owner, just write the dev list and we'll sign you up. Owners do not need to be committers.</p>
            </div>
          </div>
          <div><br>
            <hr width="100" align="left">
            <div>
              <p>[<a id="ftn.d352e11068" href="#d352e11068">34</a>] See <a href="http://search-hadoop.com/m/asM982C5FkS1" target="_top">HBase, mail # dev - Thoughts about large feature dev branches</a></p>
            </div>
          </div>
          <p>&nbsp;</p>
        </div></div>
          
          </div>
                     <div class="appendix" title="Appendix&nbsp;A.&nbsp;FAQ"><div class="titlepage"><div><div>
                       <h2 class="title"><a name="faq"></a>附录&nbsp;A.&nbsp;FAQ</h2></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a name="d1952e10408"></a><dl><dt>A.1.  <a href="#d1952e10409">General</a></dt><dd><dl><dt> <a href="#d1952e10412">When should I use HBase?</a></dt><dt> <a href="#d1952e10421">Are there other HBase FAQs?</a></dt><dt> <a href="#faq.sql">Does HBase support SQL?</a></dt><dt> <a href="#d1952e10443">How can I find examples of NoSQL/HBase?</a></dt><dt> <a href="#d1952e10452">What is the history of HBase?</a></dt></dl></dd><dt>A.2.  <a href="#faq.arch">Architecture</a></dt><dd><dl><dt> <a href="#faq.arch.regions">How does HBase handle Region-RegionServer assignment and locality?</a></dt></dl></dd><dt>A.3.  <a href="#faq.config">Configuration</a></dt><dd><dl><dt> <a href="#faq.config.started">How can I get started with my first cluster?</a></dt><dt> <a href="#faq.config.started">Where can I learn about the rest of the configuration options?</a></dt></dl></dd><dt>A.4.  <a href="#faq.design">Schema Design / Data Access</a></dt><dd><dl><dt> <a href="#faq.design.schema">How should I design my schema in HBase?</a></dt><dt> <a href="#d1952e10508">
                    How can I store (fill in the blank) in HBase?
            </a></dt><dt> <a href="#secondary.indices">
                    How can I handle secondary indexes in HBase?
            </a></dt><dt> <a href="#faq.changing.rowkeys">Can I change a table's rowkeys?</a></dt><dt> <a href="#faq.apis">What APIs does HBase support?</a></dt></dl></dd><dt>A.5.  <a href="#faq.mapreduce">MapReduce</a></dt><dd><dl><dt> <a href="#faq.mapreduce.use">How can I use MapReduce with HBase?</a></dt></dl></dd><dt>A.6.  <a href="#d1952e10560">Performance and Troubleshooting</a></dt><dd><dl><dt> <a href="#d1952e10563">
                   How can I improve HBase cluster performance?
            </a></dt><dt> <a href="#d1952e10572">
                    How can I troubleshoot my HBase cluster?
            </a></dt></dl></dd><dt>A.7.  <a href="#ec2">Amazon EC2</a></dt><dd><dl><dt> <a href="#d1952e10584">
            I am running HBase on Amazon EC2 and...
            </a></dt></dl></dd><dt>A.8.  <a href="#d1952e10595">Operations</a></dt><dd><dl><dt> <a href="#d1952e10598">
                    How do I manage my HBase cluster?
            </a></dt><dt> <a href="#d1952e10607">
                    How do I back up my HBase cluster?
            </a></dt></dl></dd><dt>A.9.  <a href="#d1952e10616">HBase in Action</a></dt><dd><dl><dt> <a href="#d1952e10619">Where can I find interesting videos and presentations on HBase?</a></dt></dl></dd></dl><table border="0" width="100%" summary="Q and A Set"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d1952e10409"></a>A.1. 通用</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2">&nbsp;</td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10412"></a><a name="d1952e10413"></a></td><td align="left" valign="top"><p>什么情况下应该用HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>参考 the <a class="xref" href="#arch.overview" title="9.1.&nbsp;Overview">Section&nbsp;9.1, “概述”</a> in the Architecture chapter.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10421"></a><a name="d1952e10422"></a></td><td align="left" valign="top"><p>还有别的 HBase FAQ吗?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              参考 the FAQ that is up on the wiki, <a class="link" href="http://wiki.apache.org/hadoop/HBase/FAQ" target="_top">HBase Wiki FAQ</a>.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="faq.sql"></a><a name="d1952e10432"></a></td><td align="left" valign="top"><p> HBase 支持SQL吗?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    事实上不支持。  SQL-ish support for HBase via <a class="link" href="http://hive.apache.org/" target="_top">Hive</a> is in development, however Hive is based on MapReduce which is not generally suitable for low-latency requests.
                    参考 the <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a> section for examples on the HBase client.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10443"></a><a name="d1952e10444"></a></td><td align="left" valign="top"><p>到哪里找到NoSQL/HBase的例子呢?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>参考附录中 BigTable 论文链接 <a class="xref" href="#other.info" title="Appendix&nbsp;F.&nbsp;Other Information About HBase">Appendix&nbsp;F, <i>Other Information About HBase</i></a> ，及其他论文.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10452"></a><a name="d1952e10453"></a></td><td align="left" valign="top"><p>HBase历史如何?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>参考 <a class="xref" href="#hbase.history" title="Appendix&nbsp;G.&nbsp;HBase History">Appendix&nbsp;G, <i>HBase History</i></a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.arch"></a>A.2. 结构</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>&nbsp;</dt></dl></td></tr><tr class="question"><td align="left" valign="top"><a name="faq.arch.regions"></a><a name="d1952e10465"></a></td><td align="left" valign="top"><p>HBase 如何处理 Region-RegionServer 分配和本地化?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#regions.arch" title="9.7.&nbsp;Regions">Section&nbsp;9.7, “Regions”</a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.config"></a>A.3. 配置</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2">&nbsp;</td></tr><tr class="question"><td align="left" valign="top"><a name="faq.config.started"></a><a name="d1952e10477"></a></td><td align="left" valign="top"><p>How can I get started with my first cluster?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start">Section&nbsp;1.2, “Quick Start”</a>.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="faq.config.started"></a><a name="d1952e10486"></a></td><td align="left" valign="top"><p>Where can I learn about the rest of the configuration options?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#configuration" title="Chapter&nbsp;2.&nbsp;Configuration">Chapter&nbsp;2, <i>Configuration</i></a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.design"></a>A.4. 模式设计 / 数据访问</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt> <a href="#faq.design.schema">How should I design my schema in HBase?</a></dt><dt> <a href="#d1952e10508">
                    How can I store (fill in the blank) in HBase?
            </a></dt><dt> <a href="#secondary.indices">
                    How can I handle secondary indexes in HBase?
            </a></dt><dt> <a href="#faq.changing.rowkeys">Can I change a table's rowkeys?</a></dt><dt> <a href="#faq.apis">What APIs does HBase support?</a></dt></dl></td></tr><tr class="question"><td align="left" valign="top"><a name="faq.design.schema"></a><a name="d1952e10498"></a></td><td align="left" valign="top"><p>How should I design my schema in HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a> and <a class="xref" href="#schema" title="Chapter&nbsp;6.&nbsp;HBase and Schema Design">Chapter&nbsp;6, <i>HBase and Schema Design</i></a>
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10508"></a><a name="d1952e10509"></a></td><td align="left" valign="top"><p>
                    How can I store (fill in the blank) in HBase?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                参考 <a class="xref" href="#supported.datatypes" title="6.5.&nbsp; Supported Datatypes">Section&nbsp;6.5, “
  Supported Datatypes
  ”</a>.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="secondary.indices"></a><a name="d1952e10518"></a></td><td align="left" valign="top"><p>
                    How can I handle secondary indexes in HBase?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                参考 <a class="xref" href="#secondary.indexes" title="6.9.&nbsp; Secondary Indexes and Alternate Query Paths">Section&nbsp;6.9, “
  Secondary Indexes and Alternate Query Paths
  ”</a>
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="faq.changing.rowkeys"></a><a name="d1952e10527"></a></td><td align="left" valign="top"><p>Can I change a table's rowkeys?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    This is a very common quesiton.  You can't.  参考 <a class="xref" href="#changing.rowkeys" title="6.3.5.&nbsp;Immutability of Rowkeys">Section&nbsp;6.3.5, “Immutability of Rowkeys”</a>.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="faq.apis"></a><a name="d1952e10536"></a></td><td align="left" valign="top"><p>What APIs does HBase support?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a>, <a class="xref" href="#client" title="9.3.&nbsp;Client">Section&nbsp;9.3, “Client”</a> and <a class="xref" href="#nonjava.jvm" title="10.1.&nbsp;Non-Java Languages Talking to the JVM">Section&nbsp;10.1, “非Java 语言和 JVM 通话”</a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.mapreduce"></a>A.5. MapReduce</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt> <a href="#faq.mapreduce.use">How can I use MapReduce with HBase?</a></dt></dl></td></tr><tr class="question"><td align="left" valign="top"><a name="faq.mapreduce.use"></a><a name="d1952e10552"></a></td><td align="left" valign="top"><p>How can I use MapReduce with HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#mapreduce" title="Chapter&nbsp;7.&nbsp;HBase and MapReduce">Chapter&nbsp;7, <i>HBase and MapReduce</i></a>
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d1952e10560"></a>A.6. 性能和问题定位</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt> <a href="#d1952e10563">
                   How can I improve HBase cluster performance?
            </a></dt><dt> <a href="#d1952e10572">
                    How can I troubleshoot my HBase cluster?
            </a></dt></dl></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10563"></a><a name="d1952e10564"></a></td><td align="left" valign="top"><p>
                   How can I improve HBase cluster performance?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                参考 <a class="xref" href="#performance" title="Chapter&nbsp;11.&nbsp;Performance Tuning">Chapter&nbsp;11, <i>Performance Tuning</i></a>.
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10572"></a><a name="d1952e10573"></a></td><td align="left" valign="top"><p>
                    How can I troubleshoot my HBase cluster?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                参考 <a class="xref" href="#trouble" title="Chapter&nbsp;12.&nbsp;Troubleshooting and Debugging HBase">Chapter&nbsp;12, <i>Troubleshooting and Debugging HBase</i></a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="ec2"></a>A.7. Amazon EC2</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt> <a href="#d1952e10584">
            I am running HBase on Amazon EC2 and...
            </a></dt></dl></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10584"></a><a name="d1952e10585"></a></td><td align="left" valign="top"><p>
            I am running HBase on Amazon EC2 and...
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
 	            EC2 issues are a special case.  参考 Troubleshooting <a class="xref" href="#trouble.ec2" title="12.12.&nbsp;Amazon EC2">Section&nbsp;12.12, “Amazon EC2”</a> and Performance <a class="xref" href="#perf.ec2" title="11.11.&nbsp;Amazon EC2">Section&nbsp;11.11, “Amazon EC2”</a> sections.                
               </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d1952e10595"></a>A.8. 操作</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt> <a href="#d1952e10598">
                    How do I manage my HBase cluster?
            </a></dt><dt> <a href="#d1952e10607">
                    How do I back up my HBase cluster?
            </a></dt></dl></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10598"></a><a name="d1952e10599"></a></td><td align="left" valign="top"><p>
                    How do I manage my HBase cluster?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#ops_mgt" title="Chapter&nbsp;14.&nbsp;HBase Operational Management">Chapter&nbsp;14, <i>HBase Operational Management</i></a>
                </p></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10607"></a><a name="d1952e10608"></a></td><td align="left" valign="top"><p>
                    How do I back up my HBase cluster?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#ops.backup" title="14.7.&nbsp;HBase Backup">Section&nbsp;14.7, “HBase Backup”</a>
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d1952e10616"></a>A.9. HBase 实践</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt> <a href="#d1952e10619">Where can I find interesting videos and presentations on HBase?</a></dt></dl></td></tr><tr class="question"><td align="left" valign="top"><a name="d1952e10619"></a><a name="d1952e10620"></a></td><td align="left" valign="top"><p>到哪里找到感兴趣的 HBase 相关视频和幻灯?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                    参考 <a class="xref" href="#other.info" title="Appendix&nbsp;F.&nbsp;Other Information About HBase">Appendix&nbsp;F, <i>Other Information About HBase</i></a>
                </p></td></tr></tbody></table></div></div>
                
            <div class="appendix" title="Appendix&nbsp;B.&nbsp;hbck In Depth"><div class="titlepage"><div><div>
              <h2 class="title"><a name="hbck.in.depth"></a>附录B.&nbsp;深入hbck </h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d1952e10633">B.1. 运行 hbck 定位不一致的地方</a></span></dt><dt><span class="section"><a href="#d1952e10646">B.2. 不一致</a></span></dt><dt><span class="section"><a href="#d1952e10665">B.3. 本地修复</a></span></dt><dt><span class="section"><a href="#d1952e10703">B.4. 区域叠加修复</a></span></dt><dd><dl><dt><span class="section"><a href="#d1952e10742">B.4.1. 特例: Meta 没有正确分配</a></span></dt><dt><span class="section"><a href="#d1952e10751">B.4.2. <span class="title">特例: HBase 版本文件丢失</span></a></span></dt><dt><span class="section"><a href="#d1952e10758">B.4.3. <span class="title">特例: Root 和 META 损毁</span>.</a></span></dt></dl></dd></dl></div>
              <p>HBaseFsck (hbck) 是一个检查区域一致性和表完整性问题的工具，可以修复损坏的HBase. 它工作在两个基本模式-- 只读不一致性定位模式和多相读写修复模式。</p><div class="section" title="B.1.&nbsp;Running hbck to identify inconsistencies"><div class="titlepage"><div><div>
	  <h2 class="title" style="clear: both"><a name="d1952e10633"></a>B.1.&nbsp;运行 hbck 定位不一致性</h2></div></div></div>
要检查HBase集群是否损坏，在HBase集群中运行 hbck ：
<pre class="programlisting">$ ./bin/hbase hbck
</pre>
<p>
命令输出结束的地方，会打印OK 或告诉你多少损坏(INCONSISTENCIES)出现。你也许想运行hbck几次，因为一些损坏可能是暂时的。(如集群正启动或区域正分裂)。 从运维来说，你可能希望有规律运行hbck 并在反复报告不一致性时设置报警(如通过 nagios) 。
A run of hbck will report a list of inconsistencies along with a brief description of the regions and
tables affected. The using the <code class="code">-details</code> option will report more details including a representative
listing of all the splits present in all the tables.	
	</p><pre class="programlisting">$ ./bin/hbase hbck -details
</pre></div><div class="section" title="B.2.&nbsp;Inconsistencies"><div class="titlepage"><div><div>
  <h2 class="title" style="clear: both"><a name="d1952e10646"></a>B.2.&nbsp;不一致</h2></div></div></div><p>
	If after several runs, inconsistencies continue to be reported, you may have encountered a
corruption. These should be rare, but in the event they occur newer versions of HBase include
the hbck tool enabled with automatic repair options.
	</p><p>
	There are two invariants that when violated create inconsistencies in HBase:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">HBase’s region consistency invariant is satisfied if every region is assigned and
deployed on exactly one region server, and all places where this state kept is in
accordance.
	</li><li class="listitem">HBase’s table integrity invariant is satisfied if for each table, every possible row key
resolves to exactly one region.
	</li></ul></div><p>
Repairs generally work in three phases -- a read-only information gathering phase that identifies
inconsistencies, a table integrity repair phase that restores the table integrity invariant, and then
finally a region consistency repair phase that restores the region consistency invariant.
Starting from version 0.90.0, hbck could detect region consistency problems report on a subset
of possible table integrity problems. It also included the ability to automatically fix the most
common inconsistency, region assignment and deployment consistency problems. This repair
could be done by using the <code class="code">-fix</code> command line option. These problems close regions if they are
open on the wrong server or on multiple region servers and also assigns regions to region
servers if they are not open.
</p><p>
Starting from HBase versions 0.90.7, 0.92.2 and 0.94.0, several new command line options are
introduced to aid repairing a corrupted HBase. This hbck sometimes goes by the nickname
“uberhbck”. Each particular version of uber hbck is compatible with the HBase’s of the same
major version (0.90.7 uberhbck can repair a 0.90.4). However, versions &lt;=0.90.6 and versions
&lt;=0.92.1 may require restarting the master or failing over to a backup master.
</p></div><div class="section" title="B.3.&nbsp;Localized repairs"><div class="titlepage"><div><div>
  <h2 class="title" style="clear: both"><a name="d1952e10665"></a>B.3.&nbsp;本地修复</h2></div></div></div><p>
	When repairing a corrupted HBase, it is best to repair the lowest risk inconsistencies first.
These are generally region consistency repairs -- localized single region repairs, that only modify
in-memory data, ephemeral zookeeper data, or patch holes in the META table.
Region consistency requires that the HBase instance has the state of the region’s data in HDFS
(.regioninfo files), the region’s row in the .META. table., and region’s deployment/assignments on
region servers and the master in accordance. Options for repairing region consistency include:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">-fixAssignments</code> (equivalent to the 0.90 <code class="code">-fix</code> option) repairs unassigned, incorrectly
assigned or multiply assigned regions.
		</li><li class="listitem"><code class="code">-fixMeta</code> which removes meta rows when corresponding regions are not present in
HDFS and adds new meta rows if they regions are present in HDFS while not in META.
		</li></ul></div><p>
	To fix deployment and assignment problems you can run this command:
</p><pre class="programlisting">$ ./bin/hbase hbck -fixAssignments
</pre>
To fix deployment and assignment problems as well as repairing incorrect meta rows you can
run this command:.
<pre class="programlisting">$ ./bin/hbase hbck -fixAssignments -fixMeta
</pre>
There are a few classes of table integrity problems that are low risk repairs. The first two are
degenerate (startkey == endkey) regions and backwards regions (startkey &gt; endkey). These are
automatically handled by sidelining the data to a temporary directory (/hbck/xxxx).
The third low-risk class is hdfs region holes. This can be repaired by using the:
	<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">-fixHdfsHoles</code> option for fabricating new empty regions on the file system.
If holes are detected you can use -fixHdfsHoles and should include -fixMeta and -fixAssignments to make the new region consistent.
		</li></ul></div><pre class="programlisting">$ ./bin/hbase hbck -fixAssignments -fixMeta -fixHdfsHoles
</pre>
Since this is a common operation, we’ve added a the <code class="code">-repairHoles</code> flag that is equivalent to the
previous command:
<pre class="programlisting">$ ./bin/hbase hbck -repairHoles
</pre>
If inconsistencies still remain after these steps, you most likely have table integrity problems
related to orphaned or overlapping regions.
	</div><div class="section" title="B.4.&nbsp;Region Overlap Repairs"><div class="titlepage"><div><div>
	  <h2 class="title" style="clear: both"><a name="d1952e10703"></a>B.4.&nbsp;区域叠加修复</h2></div></div></div>
Table integrity problems can require repairs that deal with overlaps. This is a riskier operation
because it requires modifications to the file system, requires some decision making, and may
require some manual steps. For these repairs it is best to analyze the output of a <code class="code">hbck -details</code>
run so that you isolate repairs attempts only upon problems the checks identify. Because this is
riskier, there are safeguard that should be used to limit the scope of the repairs.
WARNING: This is a relatively new and have only been tested on online but idle HBase instances
(no reads/writes). Use at your own risk in an active production environment!
The options for repairing table integrity violations include:
	<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">-fixHdfsOrphans</code> option for “adopting” a region directory that is missing a region
metadata file (the .regioninfo file).
		</li><li class="listitem"><code class="code">-fixHdfsOverlaps</code> ability for fixing overlapping regions
		</li></ul></div>
When repairing overlapping regions, a region’s data can be modified on the file system in two
ways: 1) by merging regions into a larger region or 2) by sidelining regions by moving data to
“sideline” directory where data could be restored later. Merging a large number of regions is
technically correct but could result in an extremely large region that requires series of costly
compactions and splitting operations. In these cases, it is probably better to sideline the regions
that overlap with the most other regions (likely the largest ranges) so that merges can happen on
a more reasonable scale. Since these sidelined regions are already laid out in HBase’s native
directory and HFile format, they can be restored by using HBase’s bulk load mechanism.
The default safeguard thresholds are conservative. These options let you override the default
thresholds and to enable the large region sidelining feature.
	<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">-maxMerge &lt;n&gt;</code> maximum number of overlapping regions to merge
		</li><li class="listitem"><code class="code">-sidelineBigOverlaps</code> if more than maxMerge regions are overlapping, sideline attempt
to sideline the regions overlapping with the most other regions.
		</li><li class="listitem"><code class="code">-maxOverlapsToSideline &lt;n&gt;</code> if sidelining large overlapping regions, sideline at most n
regions.
		</li></ul></div>
		
Since often times you would just want to get the tables repaired, you can use this option to turn
on all repair options:
	<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">-repair</code> includes all the region consistency options and only the hole repairing table
integrity options.
		</li></ul></div>
Finally, there are safeguards to limit repairs to only specific tables. For example the following
command would only attempt to repair table TableFoo and TableBar.
<pre class="programlisting">$ ./bin/hbase/ hbck -repair TableFoo TableBar
</pre><div class="section" title="B.4.1.&nbsp;Special cases: Meta is not properly assigned"><div class="titlepage"><div><div>
  <h3 class="title"><a name="d1952e10742"></a>B.4.1.&nbsp;特例: Meta 没有正确分配</h3></div></div></div>
There are a few special cases that hbck can handle as well.
Sometimes the meta table’s only region is inconsistently assigned or deployed. In this case
there is a special <code class="code">-fixMetaOnly</code> option that can try to fix meta assignments.
<pre class="programlisting">$ ./bin/hbase hbck -fixMetaOnly -fixAssignments
</pre></div><div class="section" title="B.4.2.&nbsp;Special cases: HBase version file is missing"><div class="titlepage"><div><div>
  <h3 class="title"><a name="d1952e10751"></a>B.4.2.&nbsp;特例: HBase 版本文件丢失</h3></div></div></div>
HBase’s data on the file system requires a version file in order to start. If this flie is missing, you
can use the <code class="code">-fixVersionFile</code> option to fabricating a new HBase version file. This assumes that
the version of hbck you are running is the appropriate version for the HBase cluster.	
	</div><div class="section" title="B.4.3.&nbsp;Special case: Root and META are corrupt."><div class="titlepage"><div><div>
	  <h3 class="title"><a name="d1952e10758"></a>B.4.3.&nbsp;特例: Root 和 META 损毁.</h3></div></div></div>
最严重损坏场景是 ROOT 或 META 损坏，HBase 启动失败。这种情况可以使用OfflineMetaRepair 工具创建新的ROOT和META 区域和表。
This tool assumes that HBase is offline. It then marches through the existing HBase home
directory, loads as much information from region metadata files (.regioninfo files) as possible
from the file system. If the region metadata has proper table integrity, it sidelines the original root
and meta table directories, and builds new ones with pointers to the region directories and their
data.
<pre class="programlisting">$ ./bin/hbase org.apache.hadoop.hbase.util.OfflineMetaRepair
</pre>
NOTE: This tool is not as clever as uberhbck but can be used to bootstrap repairs that uberhbck
can complete.
If the tool succeeds you should be able to start hbase and run online repairs if necessary.
	</div></div></div>    
                
                <div class="section" title="B.2.&nbsp;Inconsistencies"><div class="titlepage"><div><div></div></div></div></div>
	
        </p></div></div></div><div class="appendix" title="Appendix B. HBase中的压缩"><div class="titlepage"><div><div>
          <h2 class="title"><a name="compression"></a>Appendix&nbsp;C.&nbsp;HBase中的压缩</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#compression.test">B.1. 测试压缩工具</a></span></dt><dt><span class="section"><a href="#hbase.regionserver.codecs">B.2. 
    <code class="varname">
    hbase.regionserver.codecs
    </code>
    </a></span></dt><dt><span class="section"><a href="#lzo.compression">B.3. 
    LZO
    </a></span></dt><dt><span class="section"><a href="#gzip.compression">B.4. 
    GZIP
    </a></span></dt></dl></div><div class="section" title="B.1. 测试压缩工具"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compression.test"></a>C.1.&nbsp;测试压缩工具</h2></div></div></div><p>
    HBase有一个用来测试压缩新的工具。要想运行它，输入<code class="code">/bin/hbase org.apache.hadoop.hbase.util.CompressionTest</code>. 就会有提示这个工具的具体用法
    </p></div><div class="section" title="B.2.  hbase.regionserver.codecs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.regionserver.codecs"></a>C.2.&nbsp;
    <code class="varname">
    hbase.regionserver.codecs
    </code>
    </h2></div></div></div><p>
    如果你的安装错误，就会测试不成功，或者无法启动。可以在你的<code class="filename">hbase-site.xml</code>加上配置
    <code class="varname">
    hbase.regionserver.codecs
    </code>
    值你需要的codecs。例如，如果
    <code class="varname">
    hbase.regionserver.codecs
    </code> 的值是 <code class="code">lzo,gz</code> 同时lzo不存在或者没有正确安装， RegionServer在启动的时候会提示配置错误。
    </p><p>
     当一台新机器加入到集群中的时候，管理员一定要注意，这台新机器有可能要安装特定的压缩解码器。

    </p></div><div class="section" title="B.3.  LZO"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lzo.compression"></a>C.3.&nbsp;
    LZO
    </h2></div></div></div>
      <p>很不幸，HBase是Apache的协议，而LZO是GPL的协议。HBase不能自带LZO，因此LZO需要在安装HBase之前安装。参见 <a class="link" href="http://wiki.apache.org/hadoop/UsingLzoCompression" target="_top">使用 LZO 压缩</a>介绍了如何在HBase中使用LZO </p>
    <p>一个常见的问题是，用户在一开始使用LZO的时候会很好，但是数月过去，管理员在给集群添加集群的时候，他们忘记了LZO的事情。在0.90.0版本之后，我们会运行失败，但也有可能不。</p>
    <p> 参考 <a href="#hbase.regionserver.codecs.html" title="C.2.  hbase.regionserver.codecs">Section C.2, “ hbase.regionserver.codecs ”</a> for a feature to help protect against failed LZO install. </p>
    </div><div class="section" title="B.4.  GZIP"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gzip.compression"></a>C.4.&nbsp;
    GZIP
    </h2></div></div></div><p>
	相对于LZO，GZIP的压缩率更高但是速度更慢。在某些特定情况下，压缩率是优先考量的。Java会使用Java自带的GZIP，除非Hadoop的本地库在CLASSPATH中。在这种情况下，最好使用本地压缩器。(如果本地库不存在，可以在Log看到很多<span class="emphasis"><em>Got brand-new compressor</em></span>。参见<a class="xref" href="#brand.new.compressor">Q:&nbsp;</a>)
<div class="section" title="C.5.&nbsp; SNAPPY"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="snappy.compression"></a>C.5.&nbsp;
    SNAPPY
    </h2></div></div></div><p>
        If snappy is installed, HBase can make use of it (courtesy of
        <a class="link" href="http://code.google.com/p/hadoop-snappy/" target="_top">hadoop-snappy</a>
        <sup>[<a name="d1934e10793" href="#ftn.d1934e10793" class="footnote">29</a>]</sup>).

        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Build and install <a class="link" href="http://code.google.com/p/snappy/" target="_top">snappy</a> on all nodes
                    of your cluster.
                </p></li><li class="listitem"><p>
        Use CompressionTest to verify snappy support is enabled and the libs can be loaded ON ALL NODES of your cluster:
        </p><pre class="programlisting">$ hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://host/path/to/hbase snappy</pre><p>
                </p></li><li class="listitem"><p>
        Create a column family with snappy compression and verify it in the hbase shell:
        </p><pre class="programlisting">$ hbase&gt; create 't1', { NAME =&gt; 'cf1', COMPRESSION =&gt; 'SNAPPY' }
hbase&gt; describe 't1'</pre><p>
        In the output of the "describe" command, you need to ensure it lists "COMPRESSION =&gt; 'SNAPPY'"
                </p></li></ol></div><p>

    </p><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d1934e10793" href="#d1934e10793" class="para">29</a>] </sup>参考 <a class="link" href="http://search-hadoop.com/m/Ds8d51c263B1/%2522Hadoop-Snappy+in+synch+with+Hadoop+trunk%2522&amp;subj=Hadoop+Snappy+in+synch+with+Hadoop+trunk" target="_top">Alejandro's note</a> up on the list on difference between Snappy in Hadoop
        and Snappy in HBase</p></div></div></div>
        <div class="section" title="C.6.&nbsp;Changing Compression Schemes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="changing.compression"></a>C.6.&nbsp;Changing Compression Schemes</h2></div></div></div><p>A frequent question on the dist-list is how to change compression schemes for ColumnFamilies.  This is actually quite simple, 
      and can be done via an alter command.  Because the compression scheme is encoded at the block-level in StoreFiles, the table does 
      <span class="emphasis"><em>not</em></span> need to be re-created and the data does <span class="emphasis"><em>not</em></span> copied somewhere else.  Just make sure
      the old codec is still available until you are sure that all of the old StoreFiles have been compacted.
      </p></div>
      
    </p></div></div><div class="appendix" title="Appendix C. FAQ"><div class="titlepage"><div><div></div></div></div></div><div class="appendix" title="Appendix D. YCSB: 雅虎云服务 测试 和HBase"><div class="titlepage"><div><div><h2 class="title"><a name="apd" id="apd"></a>Appendix&nbsp;D.&nbsp;<a class="link" href="https://github.com/brianfrankcooper/YCSB/" target="_top">YCSB: 雅虎云服务 测试</a> 和HBase</h2></div></div></div><p>TODO: YCSB不能很多的增加集群负载.</p><p>TODO: 如果给HBase安装</p><p>Ted Dunning重做了YCSV,这个是用maven管理了，加入了核实工作量的功能。参见 <a class="link" href="https://github.com/tdunning/YCSB" target="_top">Ted Dunning's YCSB</a>.</p></div>
    
    <div class="appendix" title="Appendix&nbsp;E.&nbsp;HFile format version 2"><div class="titlepage"><div><div><h2 class="title"><a name="hfilev2"></a>Appendix&nbsp;E.&nbsp;HFile format version 2</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d1934e10848">E.1. Motivation </a></span></dt><dt><span class="section"><a href="#apes02">E.2. HFile format version 1 overview </a></span></dt><dd><dl><dt><span class="section"><a href="#d1934e10883">E.2.1.  Block index format in version 1 </a></span></dt></dl></dd><dt><span class="section"><a href="#apes03">E.3. 
      HBase file format with inline blocks (version 2)
      </a></span></dt><dd><dl><dt><span class="section"><a href="#d1934e10910">E.3.1.  概述</a></span></dt><dt><span class="section"><a href="#d1934e10925">E.3.2. Unified version 2 block format</a></span></dt><dt><span class="section"><a href="#d1934e10994">E.3.3.  Block index in version 2</a></span></dt><dt><span class="section"><a href="#d1934e11019">E.3.4. 
      Root block index format in version 2</a></span></dt><dt><span class="section"><a href="#d1934e11072">E.3.5. 
      Non-root block index format in version 2</a></span></dt><dt><span class="section"><a href="#d1934e11097">E.3.6. 
      Bloom filters in version 2</a></span></dt><dt><span class="section"><a href="#d1934e11134">E.3.7. File Info format in versions 1 and 2</a></span></dt><dt><span class="section"><a href="#d1934e11180">E.3.8. 
      Fixed file trailer format differences between versions 1 and 2</a></span></dt></dl></dd></dl></div><div class="section" title="E.1.&nbsp;Motivation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d1934e10848"></a>E.1.&nbsp;Motivation </h2></div></div></div><p>Note:  this feature was introduced in HBase 0.92</p><p>We found it necessary to revise the HFile format after encountering high memory usage and slow startup times caused by large Bloom filters and block indexes in the region server. Bloom filters can get as large as 100 MB per HFile, which adds up to 2 GB when aggregated over 20 regions. Block indexes can grow as large as 6 GB in aggregate size over the same set of regions. A region is not considered opened until all of its block index data is loaded. Large Bloom filters produce a different performance problem: the first get request that requires a Bloom filter lookup will incur the latency of loading the entire Bloom filter bit array.</p><p>To speed up region server startup we break Bloom filters and block indexes into multiple blocks and write those blocks out as they fill up, which also reduces the HFile writer’s memory footprint. In the Bloom filter case, “filling up a block” means accumulating enough keys to efficiently utilize a fixed-size bit array, and in the block index case we accumulate an “index block” of the desired size. Bloom filter blocks and index blocks (we call these “inline blocks”) become interspersed with data blocks, and as a side effect we can no longer rely on the difference between block offsets to determine data block length, as it was done in version 1.</p><p>HFile is a low-level file format by design, and it should not deal with application-specific details such as Bloom filters, which are handled at StoreFile level. Therefore, we call Bloom filter blocks in an HFile "inline" blocks. We also supply HFile with an interface to write those inline blocks. </p><p>Another format modification aimed at reducing the region server startup time is to use a contiguous “load-on-open” section that has to be loaded in memory at the time an HFile is being opened. Currently, as an HFile opens, there are separate seek operations to read the trailer, data/meta indexes, and file info. To read the Bloom filter, there are two more seek operations for its “data” and “meta” portions. In version 2, we seek once to read the trailer and seek again to read everything else we need to open the file from a contiguous block.</p></div></div>
      
      <div class="section" title="E.2.&nbsp;HFile format version 1 overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apes02" id="apes02"></a>E.2.&nbsp;HFile format version 1 overview </h2></div></div></div><p>As we will be discussing the changes we are making to the HFile format, it is useful to give a short overview of the previous (HFile version 1) format. An HFile in the existing format is structured as follows:
           <span class="inlinemediaobject"><img src="images/hfile.png" alt="HFile Version 1" align="middle"></span>
           <sup>[<a name="d1934e10876" href="#ftn.d1934e10876" class="footnote">30</a>]</sup>
       </p><div class="section" title="E.2.1.&nbsp; Block index format in version 1"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e10883"></a>E.2.1.&nbsp; Block index format in version 1 </h3></div></div></div><p>The block index in version 1 is very straightforward. For each entry, it contains: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Offset (long)</p></li><li class="listitem"><p>Uncompressed size (int)</p></li><li class="listitem"><p>Key (a serialized byte array written using Bytes.writeByteArray) </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Key length as a variable-length integer (VInt)
                  </p></li><li class="listitem"><p>
                     Key bytes
                 </p></li></ol></div></li></ol></div><p>The number of entries in the block index is stored in the fixed file trailer, and has to be passed in to the method that reads the block index. One of the limitations of the block index in version 1 is that it does not provide the compressed size of a block, which turns out to be necessary for decompression. Therefore, the HFile reader has to infer this compressed size from the offset difference between blocks. We fix this limitation in version 2, where we store on-disk block size instead of uncompressed size, and get uncompressed size from the block header.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d1934e10876" href="#d1934e10876" class="para">30</a>] </sup>Image courtesy of Lars George, <a class="link" href="http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html" target="_top">hbase-architecture-101-storage.html</a>.</p></div></div></div>
                 
                 <div class="section" title="E.3.&nbsp; HBase file format with inline blocks (version 2)"><div class="titlepage"><div><div>
                   <h2 class="title" style="clear: both"><a name="apes03" id="apes03"></a>E.3.&nbsp;
      HBase 带内嵌数据块的文件格式 (version 2)
      </h2></div></div></div><div class="section" title="E.3.1.&nbsp; Overview"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e10910"></a>E.3.1.&nbsp; 概述</h3></div></div></div><p>The version of HBase introducing the above features reads both version 1 and 2 HFiles, but only writes version 2 HFiles. A version 2 HFile is structured as follows:
           <span class="inlinemediaobject"><img src="images/hfilev2.png" align="middle" alt="HFile Version 2"></span>

   </p></div><div class="section" title="E.3.2.&nbsp;Unified version 2 block format"><div class="titlepage"><div><div>
     <h3 class="title"><a name="d1934e10925"></a>E.3.2.&nbsp;统一版本 2 的块格式</h3></div></div></div><p>In the version 2 every block in the data section contains the following fields: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>8 bytes: Block type, a sequence of bytes equivalent to version 1's "magic records". Supported block types are: </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>DATA – data blocks
                  </p></li><li class="listitem"><p>
                     LEAF_INDEX – leaf-level index blocks in a multi-level-block-index
                 </p></li><li class="listitem"><p>
                     BLOOM_CHUNK – Bloom filter chunks
                  </p></li><li class="listitem"><p>
                     META – meta blocks (not used for Bloom filters in version 2 anymore) 
                  </p></li><li class="listitem"><p>
                     INTERMEDIATE_INDEX – intermediate-level index blocks in a multi-level blockindex
                  </p></li><li class="listitem"><p>
                     ROOT_INDEX – root&gt;level index blocks in a multi&gt;level block index
                  </p></li><li class="listitem"><p>
                     FILE_INFO – the “file info” block, a small key&gt;value map of metadata
                  </p></li><li class="listitem"><p>
                     BLOOM_META – a Bloom filter metadata block in the load&gt;on&gt;open section
                  </p></li><li class="listitem"><p>
                     TRAILER – a fixed&gt;size file trailer. As opposed to the above, this is not an 
                     HFile v2 block but a fixed&gt;size (for each HFile version) data structure
                  </p></li><li class="listitem"><p>
                      INDEX_V1 – this block type is only used for legacy HFile v1 block
                  </p></li></ol></div></li><li class="listitem"><p>Compressed size of the block's data, not including the header (int).
         </p><p>
Can be used for skipping the current data block when scanning HFile data. 
                  </p></li><li class="listitem"><p>Uncompressed size of the block's data, not including the header (int)</p><p>
 This is equal to the compressed size if the compression algorithm is NON
                  </p></li><li class="listitem"><p>File offset of the previous block of the same type (long)</p><p>
 Can be used for seeking to the previous data/index block
                  </p></li><li class="listitem"><p>Compressed data (or uncompressed data if the compression algorithm is NONE).</p></li></ol></div><p>The above format of blocks is used in the following HFile sections:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Scanned block section. The section is named so because it contains all data blocks that need to be read when an HFile is scanned sequentially. &nbsp;Also contains leaf block index and Bloom chunk blocks. </p></li><li class="listitem"><p>Non-scanned block section. This section still contains unified-format v2 blocks but it does not have to be read when doing a sequential scan. This section contains “meta” blocks and intermediate-level index blocks.
         </p></li></ol></div><p>We are supporting “meta” blocks in version 2 the same way they were supported in version 1, even though we do not store Bloom filter data in these blocks anymore. </p></div><div class="section" title="E.3.3.&nbsp; Block index in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e10994"></a>E.3.3.&nbsp; Block index in version 2</h3></div></div></div><p>There are three types of block indexes in HFile version 2, stored in two different formats (root and non-root): </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Data index — version 2 multi-level block index, consisting of:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
 Version 2 root index, stored in the data block index section of the file
             </p></li><li class="listitem"><p>
Optionally, version 2 intermediate levels, stored in the non%root format in   the data index section of the file.    Intermediate levels can only be present if leaf level blocks are present
             </p></li><li class="listitem"><p>
Optionally, version 2 leaf levels, stored in the non%root format inline with   data blocks
             </p></li></ol></div></li><li class="listitem"><p>Meta index — version 2 root index format only, stored in the meta index section of the file</p></li><li class="listitem"><p>Bloom index — version 2 root index format only, stored in the “load-on-open” section as part of Bloom filter metadata.</p></li></ol></div></div><div class="section" title="E.3.4.&nbsp; Root block index format in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e11019"></a>E.3.4.&nbsp;
      Root block index format in version 2</h3></div></div></div><p>This format applies to:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Root level of the version 2 data index</p></li><li class="listitem"><p>Entire meta and Bloom indexes in version 2, which are always single-level. </p></li></ol></div><p>A version 2 root index block is a sequence of entries of the following format, similar to entries of a version 1 block index, but storing on-disk size instead of uncompressed size. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Offset (long) </p><p>
This offset may point to a data block or to a deeper&gt;level index block.
             </p></li><li class="listitem"><p>On-disk size (int) </p></li><li class="listitem"><p>Key (a serialized byte array stored using Bytes.writeByteArray) </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Key (VInt)
             </p></li><li class="listitem"><p>Key bytes
             </p></li></ol></div></li></ol></div><p>A single-level version 2 block index consists of just a single root index block. To read a root index block of version 2, one needs to know the number of entries. For the data index and the meta index the number of entries is stored in the trailer, and for the Bloom index it is stored in the compound Bloom filter metadata.</p><p>For a multi-level block index we also store the following fields in the root index block in the load-on-open section of the HFile, in addition to the data structure described above:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Middle leaf index block offset</p></li><li class="listitem"><p>Middle leaf block on-disk size (meaning the leaf index block containing the reference to the “middle” data block of the file) </p></li><li class="listitem"><p>The index of the mid-key (defined below) in the middle leaf-level block.</p></li></ol></div><p></p><p>These additional fields are used to efficiently retrieve the mid-key of the HFile used in HFile splits, which we define as the first key of the block with a zero-based index of (n – 1) / 2, if the total number of blocks in the HFile is n. This definition is consistent with how the mid-key was determined in HFile version 1, and is reasonable in general, because blocks are likely to be the same size on average, but we don’t have any estimates on individual key/value pair sizes. </p><p></p><p>When writing a version 2 HFile, the total number of data blocks pointed to by every leaf-level index block is kept track of. When we finish writing and the total number of leaf-level blocks is determined, it is clear which leaf-level block contains the mid-key, and the fields listed above are computed. &nbsp;When reading the HFile and the mid-key is requested, we retrieve the middle leaf index block (potentially from the block cache) and get the mid-key value from the appropriate position inside that leaf block.</p></div><div class="section" title="E.3.5.&nbsp; Non-root block index format in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e11072"></a>E.3.5.&nbsp;
      Non-root block index format in version 2</h3></div></div></div><p>This format applies to intermediate-level and leaf index blocks of a version 2 multi-level data block index. Every non-root index block is structured as follows. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>numEntries: the number of entries (int). </p></li><li class="listitem"><p>entryOffsets: the “secondary index” of offsets of entries in the block, to facilitate a quick binary search on the key (numEntries + 1 int values). The last value is the total length of all entries in this index block. For example, in a non-root index block with entry sizes 60, 80, 50 the “secondary index” will contain the following int array: {0, 60, 140, 190}.</p></li><li class="listitem"><p>Entries. Each entry contains: </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
Offset of the block referenced by this entry in the file (long) 
             </p></li><li class="listitem"><p>
On&gt;disk size of the referenced block (int) 
             </p></li><li class="listitem"><p>
Key. The length can be calculated from entryOffsets.
             </p></li></ol></div></li></ol></div></div><div class="section" title="E.3.6.&nbsp; Bloom filters in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e11097"></a>E.3.6.&nbsp;
      Bloom filters in version 2</h3></div></div></div><p>In contrast with version 1, in a version 2 HFile Bloom filter metadata is stored in the load-on-open section of the HFile for quick startup. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A compound Bloom filter. </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
 Bloom filter version = 3 (int). There used to be a DynamicByteBloomFilter class that had the Bloom   filter version number 2
             </p></li><li class="listitem"><p>
The total byte size of all compound Bloom filter chunks (long)
             </p></li><li class="listitem"><p>
 Number of hash functions (int
             </p></li><li class="listitem"><p>
Type of hash functions (int)
             </p></li><li class="listitem"><p>
The total key count inserted into the Bloom filter (long)
             </p></li><li class="listitem"><p>
The maximum total number of keys in the Bloom filter (long)
             </p></li><li class="listitem"><p>
The number of chunks (int)
             </p></li><li class="listitem"><p>
Comparator class used for Bloom filter keys, a UTF&gt;8 encoded string stored   using Bytes.writeByteArray
             </p></li><li class="listitem"><p>
 Bloom block index in the version 2 root block index format
             </p></li></ol></div></li></ol></div></div><div class="section" title="E.3.7.&nbsp;File Info format in versions 1 and 2"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e11134"></a>E.3.7.&nbsp;File Info format in versions 1 and 2</h3></div></div></div><p>The file info block is a serialized <a class="ulink" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/HBaseMapWritable.html" target="_top">HBaseMapWritable</a> (essentially a map from byte arrays to byte arrays) with the following keys, among others. StoreFile-level logic adds more keys to this.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>
               <p>hfile.LASTKEY </p>
            </td><td>
               <p>The last key of the file (byte array) </p>
            </td></tr><tr><td>
               <p>hfile.AVG_KEY_LEN </p>
            </td><td>
               <p>The average key length in the file (int) </p>
            </td></tr><tr><td>
               <p>hfile.AVG_VALUE_LEN </p>
            </td><td>
               <p>The average value length in the file (int) </p>
            </td></tr></tbody></table></div><p>File info format did not change in version 2. However, we moved the file info to the final section of the file, which can be loaded as one block at the time the HFile is being opened. Also, we do not store comparator in the version 2 file info anymore. Instead, we store it in the fixed file trailer. This is because we need to know the comparator at the time of parsing the load-on-open section of the HFile.</p></div><div class="section" title="E.3.8.&nbsp; Fixed file trailer format differences between versions 1 and 2"><div class="titlepage"><div><div><h3 class="title"><a name="d1934e11180"></a>E.3.8.&nbsp;
      Fixed file trailer format differences between versions 1 and 2</h3></div></div></div><p>The following table shows common and different fields between fixed file trailers in versions 1 and 2. Note that the size of the trailer is different depending on the version, so it is “fixed” only within one version. However, the version is always stored as the last four-byte integer in the file. </p><p></p><div class="informaltable"><table border="1"><colgroup><col class="c1"><col class="c2"></colgroup><tbody><tr><td>
               <p>Version 1 </p>
            </td><td>
               <p>Version 2 </p>
            </td></tr><tr><td colspan="2" align="center">
               <p>File info offset (long) </p>
            </td></tr><tr><td>
               <p>Data index offset (long) </p>
            </td><td>
                <p>loadOnOpenOffset (long)</p>
                <p><span class="emphasis"><em>The offset of the section that we need toload when opening the file.</em></span></p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Number of data index entries (int) </p>
            </td></tr><tr><td>
               <p>metaIndexOffset (long)</p>
               <p>This field is not being used by the version 1 reader, so we removed it from version 2.</p>
            </td><td>
               <p>uncompressedDataIndexSize (long)</p>
               <p>The total uncompressed size of the whole data block index, including root-level, intermediate-level, and leaf-level blocks.</p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Number of meta index entries (int) </p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Total uncompressed bytes (long) </p>
            </td></tr><tr><td>
               <p>numEntries (int) </p>
            </td><td>
               <p>numEntries (long) </p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int) </p>
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p>The number of levels in the data block index (int) </p>
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p>firstDataBlockOffset (long)</p>
               <p>The offset of the first first data block. Used when scanning. </p>
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p>lastDataBlockEnd (long)</p>
               <p>The offset of the first byte after the last key/value data block. We don't need to go beyond this offset when scanning. </p>
            </td></tr><tr><td>
               <p>Version: 1 (int) </p>
            </td><td>
               <p>Version: 2 (int) </p>
            </td></tr></tbody></table></div><p></p></div></div>
            
            <div class="appendix" title="Appendix&nbsp;F.&nbsp;Other Information About HBase"><div class="titlepage"><div><div><h2 class="title"><a name="other.info"></a>Appendix&nbsp;F.&nbsp;Other Information About HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#other.info.videos">F.1. HBase Videos</a></span></dt><dt><span class="section"><a href="#other.info.pres">F.2. HBase Presentations (Slides)</a></span></dt><dt><span class="section"><a href="#other.info.papers">F.3. HBase Papers</a></span></dt><dt><span class="section"><a href="#other.info.sites">F.4. HBase Sites</a></span></dt><dt><span class="section"><a href="#other.info.books">F.5. HBase Books</a></span></dt><dt><span class="section"><a href="#other.info.books.hadoop">F.6. Hadoop Books</a></span></dt></dl></div><div class="section" title="F.1.&nbsp;HBase Videos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.videos"></a>F.1.&nbsp;HBase Videos</h2></div></div></div><p>Introduction to HBase
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="http://www.cloudera.com/videos/chicago_data_summit_apache_hbase_an_introduction_todd_lipcon" target="_top">Introduction to HBase</a> by Todd Lipcon (Chicago Data Summit 2011).
			  </li><li class="listitem"><a class="link" href="http://www.cloudera.com/videos/intorduction-hbase-todd-lipcon" target="_top">Introduction to HBase</a> by Todd Lipcon (2010).
			  </li></ul></div><p>
         </p><p><a class="link" href="http://www.cloudera.com/videos/hadoop-world-2011-presentation-video-building-realtime-big-data-services-at-facebook-with-hadoop-and-hbase" target="_top">Building Real Time Services at Facebook with HBase</a> by Jonathan Gray (Hadoop World 2011).
         </p><p><a class="link" href="http://www.cloudera.com/videos/hw10_video_how_stumbleupon_built_and_advertising_platform_using_hbase_and_hadoop" target="_top">HBase and Hadoop, Mixing Real-Time and Batch Processing at StumbleUpon</a> by JD Cryans (Hadoop World 2010).
         </p></div><div class="section" title="F.2.&nbsp;HBase Presentations (Slides)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.pres"></a>F.2.&nbsp;HBase Presentations (Slides)</h2></div></div></div><p><a class="link" href="http://www.cloudera.com/resource/hadoop-world-2011-presentation-slides-advanced-hbase-schema-design" target="_top">Advanced HBase Schema Design</a> by Lars George (Hadoop World 2011).
         </p><p><a class="link" href="http://www.slideshare.net/cloudera/chicago-data-summit-apache-hbase-an-introduction" target="_top">Introduction to HBase</a> by Todd Lipcon (Chicago Data Summit 2011).
         </p><p><a class="link" href="http://www.slideshare.net/cloudera/hw09-practical-h-base-getting-the-most-from-your-h-base-install" target="_top">Getting The Most From Your HBase Install</a> by Ryan Rawson, Jonathan Gray (Hadoop World 2009).
         </p></div><div class="section" title="F.3.&nbsp;HBase Papers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.papers"></a>F.3.&nbsp;HBase Papers</h2></div></div></div><p><a class="link" href="http://research.google.com/archive/bigtable.html" target="_top">BigTable</a> by Google (2006).
         </p><p><a class="link" href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html" target="_top">HBase and HDFS Locality</a> by Lars George (2010).
         </p><p><a class="link" href="http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf" target="_top">No Relation: The Mixed Blessings of Non-Relational Databases</a> by Ian Varley (2009).
         </p></div><div class="section" title="F.4.&nbsp;HBase Sites"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.sites"></a>F.4.&nbsp;HBase Sites</h2></div></div></div><p><a class="link" href="http://www.cloudera.com/blog/category/hbase/" target="_top">Cloudera's HBase Blog</a> has a lot of links to useful HBase information.
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="http://www.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/" target="_top">CAP Confusion</a> is a relevant entry for background information on
			distributed storage systems.
			</li></ul></div><p>
         </p><p><a class="link" href="http://wiki.apache.org/hadoop/HBase/HBasePresentations" target="_top">HBase Wiki</a> has a page with a number of presentations.
         </p></div><div class="section" title="F.5.&nbsp;HBase Books"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.books"></a>F.5.&nbsp;HBase Books</h2></div></div></div><p><a class="link" href="http://shop.oreilly.com/product/0636920014348.do" target="_top">HBase:  The Definitive Guide</a> by Lars George.
         </p></div><div class="section" title="F.6.&nbsp;Hadoop Books"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.books.hadoop"></a>F.6.&nbsp;Hadoop Books</h2></div></div></div><p><a class="link" href="http://shop.oreilly.com/product/9780596521981.do" target="_top">Hadoop:  The Definitive Guide</a> by Tom White.
         </p></div></div>
	  
	  <div class="appendix" title="Appendix&nbsp;H.&nbsp;HBase and the Apache Software Foundation"><div class="titlepage"><div><div><h2 class="title"><a name="asf"></a>Appendix&nbsp;H.&nbsp;HBase and the Apache Software Foundation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#asf.devprocess">H.1. ASF Development Process</a></span></dt><dt><span class="section"><a href="#asf.reporting">H.2. ASF Board Reporting</a></span></dt></dl></div><p>HBase is a project in the Apache Software Foundation and as such there are responsibilities to the ASF to ensure
    a healthy project.</p><div class="section" title="H.1.&nbsp;ASF Development Process"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="asf.devprocess"></a>H.1.&nbsp;ASF Development Process</h2></div></div></div><p>参考 the <a class="link" href="http://www.apache.org/dev/#committers" target="_top">Apache Development Process page</a> 
        for all sorts of information on how the ASF is structured (e.g., PMC, committers, contributors), to tips on contributing
        and getting involved, and how open-source works at ASF.     
        </p></div></div>
        
        <div class="section" title="H.2.&nbsp;ASF Board Reporting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="asf.reporting"></a>H.2.&nbsp;ASF Board Reporting</h2></div></div></div><p>Once a quarter, each project in the ASF portfolio submits a report to the ASF board.  This is done by the HBase project
         lead and the committers.  参考 <a class="link" href="http://www.apache.org/foundation/board/reporting" target="_top">ASF board reporting</a> 获取更多信息。
         </p>
          <div>
            <div>
              <div>
                <h2>Appendix I. Enabling Dapper-like Tracing in HBase</h2>
              </div>
            </div>
          </div>
          <div>
            <p><strong>Table of Contents</strong></p>
            <dl>
              <dt><a href="#tracing.spanreceivers">I.1. SpanReceivers</a></dt>
              <dt><a href="#tracing.client.modifications">I.2. Client Modifications</a></dt>
            </dl>
          </div>
          <p><a href="https://issues.apache.org/jira/browse/HBASE-6449" target="_top">HBASE-6449</a> added support for tracing requests through HBase, using the open source tracing library, <a href="http://github.com/cloudera/htrace" target="_top">HTrace</a>. Setting up tracing is quite simple, however it currently requires some very minor changes to your client code (it would not be very difficult to remove this requirement).</p>
          <div title="I.1. SpanReceivers">
            <div>
              <div>
                <div>
                  <h2><a name="tracing.spanreceivers"></a>I.1. SpanReceivers</h2>
                </div>
              </div>
            </div>
            <p>The tracing system works by collecting information in structs called &lsquo;Spans&rsquo;. It is up to you to choose how you want to receive this information by implementing the SpanReceiver interface, which defines one method:</p>
            <pre>public void receiveSpan(Span span);</pre>
            <p>This method serves as a callback whenever a span is completed. HTrace allows you to use as many SpanReceivers as you want so you can easily send trace information to multiple destinations.</p>
            <p>Configure what SpanReceivers you&rsquo;d like to use by putting a comma separated list of the fully-qualified class name of classes implementing SpanReceiver in hbase-site.xml property: hbase.trace.spanreceiver.classes.</p>
            <p>HBase includes a HBaseLocalFileSpanReceiver that writes all span information to local files in a JSON-based format. TheHBaseLocalFileSpanReceiver looks in hbase-site.xml for a hbase.trace.spanreceiver.localfilespanreceiver.filename property with a value describing the name of the file to which nodes should write their span information.</p>
            <p>If you do not want to use the included HBaseLocalFileSpanReceiver, you are encouraged to write your own receiver (take a look at HBaseLocalFileSpanReceiver for an example). If you think others would benefit from your receiver, file a JIRA or send a pull request to <a href="http://github.com/cloudera/htrace" target="_top">HTrace</a>.</p>
          </div>
          <div title="I.2. Client Modifications">
            <div>
              <div>
                <div>
                  <h2><a name="tracing.client.modifications"></a>I.2. Client Modifications</h2>
                </div>
              </div>
            </div>
            <p>Currently, you must turn on tracing in your client code. To do this, you simply turn on tracing for requests you think are interesting, and turn it off when the request is done.</p>
            <p>For example, if you wanted to trace all of your get operations, you change this:</p>
            <pre>HTable table = new HTable(...);  Get get = new Get(...);</pre>
            <p>into:</p>
            <pre>Span getSpan = Trace.startSpan(&ldquo;doing get&rdquo;, Sampler.ALWAYS);  try {    HTable table = new HTable(...);    Get get = new Get(...);  ...  } finally {    getSpan.stop();  }</pre>
            <p>If you wanted to trace half of your &lsquo;get&rsquo; operations, you would pass in:</p>
            <pre>new ProbabilitySampler(0.5)</pre>
            <p>in lieu of Sampler.ALWAYS to Trace.startSpan(). See the HTrace README for more information on Samplers.</p>
          </div>
          <div>
            <div>
              <div>
                <h2>Appendix J. 0.95 RPC Specification</h2>
              </div>
            </div>
          </div>
          <div>
            <p><strong>Table of Contents</strong></p>
            <dl>
              <dt><a href="#d2520e13181">J.1. Goals</a></dt>
              <dt><a href="#d2520e13194">J.2. TODO</a></dt>
              <dt><a href="#d2520e13210">J.3. RPC</a></dt>
              <dd>
                <dl>
                  <dt><a href="#d2520e13224">J.3.1. Connection Setup</a></dt>
                  <dt><a href="#d2520e13256">J.3.2. Request</a></dt>
                  <dt><a href="#d2520e13289">J.3.3. Response</a></dt>
                  <dt><a href="#d2520e13319">J.3.4. Exceptions</a></dt>
                  <dt><a href="#d2520e13326">J.3.5. CellBlocks</a></dt>
                </dl>
              </dd>
              <dt><a href="#d2520e13331">J.4. Notes</a></dt>
              <dd>
                <dl>
                  <dt><a href="#d2520e13334">J.4.1. Constraints</a></dt>
                  <dt><a href="#d2520e13339">J.4.2. One fat pb request or header+param</a></dt>
                  <dt><a href="#d2520e13359">J.4.3. Compression</a></dt>
                </dl>
              </dd>
            </dl>
          </div>
          <p>In 0.95, all client/server communication is done with <a href="https://code.google.com/p/protobuf/" target="_top">protobuf&rsquo;ed</a> Messages rather than with <a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html" target="_top">Hadoop Writables</a>. Our RPC wire format therefore changes. This document describes the client/server request/response protocol and our new RPC wire-format.</p>
          <p>For what RPC is like in 0.94 and previous, see Benoît/Tsuna&rsquo;s <a href="https://github.com/OpenTSDB/asynchbase/blob/master/src/HBaseRpc.java#L164" target="_top">Unofficial Hadoop / HBase RPC protocol documentation</a>. For more background on how we arrived at this spec., see <a href="https://docs.google.com/document/d/1WCKwgaLDqBw2vpux0jPsAu2WPTRISob7HGCO8YhfDTA/edit#" target="_top">HBase RPC: WIP</a></p>
          <div title="J.1. Goals">
            <div>
              <div>
                <div>
                  <h2><a name="d2520e13181"></a>J.1. Goals</h2>
                </div>
              </div>
            </div>
            <div>
              <ol type="1">
                <li>
                  <p>A wire-format we can evolve</p>
                </li>
                <li>
                  <p>A format that does not require our rewriting server core or radically changing its current architecture (for later).</p>
                </li>
              </ol>
            </div>
          </div>
          <div title="J.2. TODO">
            <div>
              <div>
                <div>
                  <h2><a name="d2520e13194"></a>J.2. TODO</h2>
                </div>
              </div>
            </div>
            <div>
              <ol type="1">
                <li>
                  <p>List of problems with currently specified format and where we would like to go in a version2, etc. For example, what would we have to change if anything to move server async or to support streaming/chunking?</p>
                </li>
                <li>
                  <p>Diagram on how it works</p>
                </li>
                <li>
                  <p>A grammar that succinctly describes the wire-format. Currently we have these words and the content of the rpc protobuf idl but a grammar for the back and forth would help with groking rpc. Also, a little state machine on client/server interactions would help with understanding (and ensuring correct implementation).</p>
                </li>
              </ol>
            </div>
          </div>
          <div title="J.3. RPC">
            <div>
              <div>
                <div>
                  <h2><a name="d2520e13210"></a>J.3. RPC</h2>
                </div>
              </div>
            </div>
            <p>The client will send setup information on connection establish. Thereafter, the client invokes methods against the remote server sending a protobuf Message and receiving a protobuf Message in response. Communication is synchronous. All back and forth is preceded by an int that has the total length of the request/response. Optionally, Cells(KeyValues) can be passed outside of protobufs in follow-behind Cell blocks (because <a href="https://docs.google.com/document/d/1WEtrq-JTIUhlnlnvA0oYRLp0F8MKpEBeBSCFcQiacdw/edit#" target="_top">we can&rsquo;t protobuf megabytes of KeyValues</a> or Cells). These CellBlocks are encoded and optionally compressed.</p>
            <p>For more detail on the protobufs involved, see the <a href="http://svn.apache.org/viewvc/hbase/trunk/hbase-protocol/src/main/protobuf/RPC.proto?view=markup" target="_top">RPC.proto</a> file in trunk.</p>
            <div title="J.3.1. Connection Setup">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13224"></a>J.3.1. Connection Setup</h3>
                  </div>
                </div>
              </div>
              <p>Client initiates connection.</p>
              <div title="J.3.1.1. Client">
                <div>
                  <div>
                    <div>
                      <h4><a name="d2520e13229"></a>J.3.1.1. Client</h4>
                    </div>
                  </div>
                </div>
                <p>On connection setup, client sends a preamble followed by a connection header.</p>
                <div title="J.3.1.1.1. <preamble>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13234"></a>J.3.1.1.1. &lt;preamble&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <pre>&lt;MAGIC 4 byte integer&gt; &lt;1 byte RPC Format Version&gt; &lt;1 byte auth type&gt;[<a name="d2520e13240" href="#ftn.d2520e13240">36</a>]</pre>
                  <p>E.g.: HBas0x000x80 -- 4 bytes of MAGIC -- &lsquo;HBas&rsquo; -- plus one-byte of version, 0 in this case, and one byte, 0x80 (SIMPLE). of an auth type.</p>
                </div>
                <div title="J.3.1.1.2. <Protobuf ConnectionHeader Message>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13245"></a>J.3.1.1.2. &lt;Protobuf ConnectionHeader Message&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>Has user info, and &ldquo;protocol&rdquo;, as well as the encoders and compression the client will use sending CellBlocks. CellBlock encoders and compressors are for the life of the connection. CellBlock encoders implement org.apache.hadoop.hbase.codec.Codec. CellBlocks may then also be compressed. Compressors implement org.apache.hadoop.io.compress.CompressionCodec. This protobuf is written using writeDelimited so is prefaced by a pb varint with its serialized length</p>
                </div>
              </div>
              <div title="J.3.1.2. Server">
                <div>
                  <div>
                    <div>
                      <h4><a name="d2520e13251"></a>J.3.1.2. Server</h4>
                    </div>
                  </div>
                </div>
                <p>After client sends preamble and connection header, server does NOT respond if successful connection setup. No response means server is READY to accept requests and to give out response. If the version or authentication in the preamble is not agreeable or the server has trouble parsing the preamble, it will throw a org.apache.hadoop.hbase.ipc.FatalConnectionException explaining the error and will then disconnect. If the client in the connection header -- i.e. the protobuf&rsquo;d Message that comes after the connection preamble -- asks for for a Service the server does not support or a codec the server does not have, again we throw a FatalConnectionException with explanation.</p>
              </div>
            </div>
            <div title="J.3.2. Request">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13256"></a>J.3.2. Request</h3>
                  </div>
                </div>
              </div>
              <p>After a Connection has been set up, client makes requests. Server responds.</p>
              <p>A request is made up of a protobuf RequestHeader followed by a protobuf Message parameter. The header includes the method name and optionally, metadata on the optional CellBlock that may be following. The parameter type suits the method being invoked: i.e. if we are doing a getRegionInfo request, the protobuf Message param will be an instance of GetRegionInfoRequest. The response will be a GetRegionInfoResponse. The CellBlock is optionally used ferrying the bulk of the RPC data: i.e Cells/KeyValues.</p>
              <div title="J.3.2.1. Request Parts">
                <div>
                  <div>
                    <div>
                      <h4><a name="d2520e13264"></a>J.3.2.1. Request Parts</h4>
                    </div>
                  </div>
                </div>
                <div title="J.3.2.1.1. <Total Length>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13267"></a>J.3.2.1.1. &lt;Total Length&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>The request is prefaced by an int that holds the total length of what follows.</p>
                </div>
                <div title="J.3.2.1.2. <Protobuf RequestHeader Message>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13272"></a>J.3.2.1.2. &lt;Protobuf RequestHeader Message&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>Will have call.id, trace.id, and method name, etc. including optional Metadata on the Cell block IFF one is following. Data is protobuf&rsquo;d inline in this pb Message or optionally comes in the following CellBlock</p>
                </div>
                <div title="J.3.2.1.3. <Protobuf Param Message>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13277"></a>J.3.2.1.3. &lt;Protobuf Param Message&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>If the method being invoked is getRegionInfo, if you study the Service descriptor for the client to regionserver protocol, you will find that the request sends a GetRegionInfoRequest protobuf Message param in this position.</p>
                </div>
                <div title="J.3.2.1.4. <CellBlock>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13282"></a>J.3.2.1.4. &lt;CellBlock&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>An encoded and optionally compressed Cell block.</p>
                </div>
              </div>
            </div>
            <div title="J.3.3. Response">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13289"></a>J.3.3. Response</h3>
                  </div>
                </div>
              </div>
              <p>Same as Request, it is a protobuf ResponseHeader followed by a protobuf Message response where the Message response type suits the method invoked. Bulk of the data may come in a following CellBlock.</p>
              <div title="J.3.3.1. Response Parts">
                <div>
                  <div>
                    <div>
                      <h4><a name="d2520e13294"></a>J.3.3.1. Response Parts</h4>
                    </div>
                  </div>
                </div>
                <div title="J.3.3.1.1. <Total Length>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13297"></a>J.3.3.1.1. &lt;Total Length&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>The response is prefaced by an int that holds the total length of what follows.</p>
                </div>
                <div title="J.3.3.1.2. <Protobuf ResponseHeader Message>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13302"></a>J.3.3.1.2. &lt;Protobuf ResponseHeader Message&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>Will have call.id, etc. Will include exception if failed processing.  Optionally includes metadata on optional, IFF there is a CellBlock following.</p>
                </div>
                <div title="J.3.3.1.3. <Protobuf Response Message>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13307"></a>J.3.3.1.3. &lt;Protobuf Response Message&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>Return or may be nothing if exception. If the method being invoked is getRegionInfo, if you study the Service descriptor for the client to regionserver protocol, you will find that the response sends a GetRegionInfoResponse protobuf Message param in this position.</p>
                </div>
                <div title="J.3.3.1.4. <CellBlock>">
                  <div>
                    <div>
                      <div>
                        <h5><a name="d2520e13312"></a>J.3.3.1.4. &lt;CellBlock&gt;</h5>
                      </div>
                    </div>
                  </div>
                  <p>An encoded and optionally compressed Cell block.</p>
                </div>
              </div>
            </div>
            <div title="J.3.4. Exceptions">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13319"></a>J.3.4. Exceptions</h3>
                  </div>
                </div>
              </div>
              <p>There are two distinct types. There is the request failed which is encapsulated inside the response header for the response. The connection stays open to receive new requests. The second type, the FatalConnectionException, kills the connection.</p>
              <p>Exceptions can carry extra information. See the ExceptionResponse protobuf type. It has a flag to indicate do-no-retry as well as other miscellaneous payload to help improve client responsiveness.</p>
            </div>
            <div title="J.3.5. CellBlocks">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13326"></a>J.3.5. CellBlocks</h3>
                  </div>
                </div>
              </div>
              <p>These are not versioned. Server can do the codec or it cannot. If new version of a codec with say, tighter encoding, then give it a new class name. Codecs will live on the server for all time so old clients can connect.</p>
            </div>
          </div>
          <div title="J.4. Notes">
            <div>
              <div>
                <div>
                  <h2><a name="d2520e13331"></a>J.4. Notes</h2>
                </div>
              </div>
            </div>
            <div title="J.4.1. Constraints">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13334"></a>J.4.1. Constraints</h3>
                  </div>
                </div>
              </div>
              <p>In some part, current wire-format -- i.e. all requests and responses preceeded by a length -- has been dictated by current server non-async architecture.</p>
            </div>
            <div title="J.4.2. One fat pb request or header+param">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13339"></a>J.4.2. One fat pb request or header+param</h3>
                  </div>
                </div>
              </div>
              <p>We went with pb header followed by pb param making a request and a pb header followed by pb response for now. Doing header+param rather than a single protobuf Message with both header and param content:</p>
              <div>
                <ol type="1">
                  <li>
                    <p>Is closer to what we currently have</p>
                  </li>
                  <li>
                    <p>Having a single fat pb requires extra copying putting the already pb&rsquo;d param into the body of the fat request pb (and same making result)</p>
                  </li>
                  <li>
                    <p>We can decide whether to accept the request or not before we read the param; for example, the request might be low priority.  As is, we read header+param in one go as server is currently implemented so this is a TODO.</p>
                  </li>
                </ol>
              </div>
              <p>The advantages are minor.  If later, fat request has clear advantage, can roll out a v2 later.</p>
            </div>
            <div title="J.4.3. Compression">
              <div>
                <div>
                  <div>
                    <h3><a name="d2520e13359"></a>J.4.3. Compression</h3>
                  </div>
                </div>
              </div>
              <p>Uses hadoops compression codecs.</p>
            </div>
          </div>
          <div><br>
            <hr width="100" align="left">
            <div>
              <p>[<a id="ftn.d2520e13240" href="#d2520e13240">36</a>] We need the auth method spec. here so the connection header is encoded if auth enabled.</p>
            </div>
          </div>
          <p>&nbsp;</p>
        </div>
         
    <div class="index" title="Index"><div class="titlepage"><div><div><h2 class="title"><a name="book_index"></a>Index</h2></div></div></div><div class="index"><div class="indexdiv"><h3>C</h3><dl><dt>Cells, <a class="indexterm" href="#cells">Cells</a></dt><dt>Column Family, <a class="indexterm" href="#columnfamily">Column Family</a></dt>
          <dt>Column Family Qualifier, <a href="#columnfamily">Column Family</a></dt>
            <dt>Compression, <a href="#compression">Compression In HBase</a></dt>
    </dl>
          <dl>
            <dd>&nbsp;</dd>
          </dl>
    </div><div class="indexdiv"><h3>H</h3><dl><dt>Hadoop, <a class="indexterm" href="#hadoop">hadoop</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt> LargeTests </dt>
    </dl></div><div class="indexdiv"><h3>M</h3>
      <dl>
        <dt>MediumTests,</dt>
        <dt>MSLAB, <a href="#gcpause">Long GC pauses</a></dt>
      </dl>
      <h3>N</h3>
      <dl><dt>nproc, <a class="indexterm" href="#ulimit">
          ulimit
            和
          nproc
        </a></dt></dl></div><div class="indexdiv"><h3>S</h3>
          <dl>
            <dt>SmallTests,</dt>
          </dl>
          <h3>U</h3>
          <dl><dt>ulimit, <a class="indexterm" href="#ulimit">
          ulimit
            和
          nproc
        </a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>Versions, <a class="indexterm" href="#versions">版本</a></dt></dl></div><div class="indexdiv"><h3>X</h3><dl><dt>xcievers, <a class="indexterm" href="#dfs.datanode.max.xcievers">dfs.datanode.max.xcievers</a></dt></dl></div><div class="indexdiv"><h3>Z</h3><dl><dt>ZooKeeper, <a class="indexterm" href="#zookeeper">ZooKeeper</a></dt></dl></div></div></div></div><script type="text/javascript">
    var disqus_shortname = 'hbase'; // required: replace example with your forum shortname
    var disqus_url = 'http://hbase.apache.org/book';
    var disqus_identifier = 'book';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<style id="_clearly_component__css" type="text/css">#next_pages_container { width: 5px; hight: 5px; position: absolute; top: -100px; left: -100px; z-index: 2147483647 !important; } </style><div id="_clearly_component__next_pages_container"></div><script src="http://s9.cnzz.com/stat.php?id=2465593&web_id=2465593" language="JavaScript"></script>
<!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools get-codes-bdshare">
<a class="bds_tsina"></a>
<a class="bds_qzone"></a>
<a class="bds_tqq"></a>
<a class="bds_renren"></a>
<a class="bds_t163"></a>
<span class="bds_more">更多</span>
<a class="shareCount"></a>
</div>
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=4319104" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->
</body></html>